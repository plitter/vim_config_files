!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	2	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
a1	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<1> > >::type const a1 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a2	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<2> > >::type const a2 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a3	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<3> > >::type const a3 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a4	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<4> > >::type const a4 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a5	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<5> > >::type const a5 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a6	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<6> > >::type const a6 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a7	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<7> > >::type const a7 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a8	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<8> > >::type const a8 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a9	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<9> > >::type const a9 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
absolute	/usr/include/boost/filesystem/operations.hpp	/^  path absolute(const path& p, const path& base=current_path());$/;"	p	namespace:boost::filesystem	signature:(const path& p, const path& base=current_path())
absorbed_dose	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^typedef unit<absorbed_dose_dimension,si::system>     absorbed_dose;$/;"	t	namespace:boost::units::si
abstract	/usr/include/boost/units/systems/abstract.hpp	/^namespace abstract {$/;"	n	namespace:boost::units
abstract_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^class BOOST_REGEX_DECL abstract_protected_call$/;"	c	namespace:boost::re_detail
acceleration	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^typedef unit<acceleration_dimension,cgs::system>     acceleration;$/;"	t	namespace:boost::units::cgs
acceleration	/usr/include/boost/units/systems/si/acceleration.hpp	/^typedef unit<acceleration_dimension,si::system>  acceleration;$/;"	t	namespace:boost::units::si
access	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef detail::core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::regex_iterator_impl	access:public
access_denied	/usr/include/boost/system/windows_error.hpp	/^        access_denied = ERROR_ACCESS_DENIED,$/;"	e	enum:boost::system::windows_error::windows_error_code
action	/usr/include/boost/units/systems/si/action.hpp	/^typedef unit<action_dimension,si::system>    action;$/;"	t	namespace:boost::units::si
action_arg	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct action_arg$/;"	s	namespace:boost::xpressive::detail
action_arg_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<detail::action_arg<T, mpl::int_<I> > >::type action_arg_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
activity	/usr/include/boost/units/systems/si/activity.hpp	/^typedef unit<activity_dimension,si::system>  activity;$/;"	t	namespace:boost::units::si
address	/usr/include/boost/regex/concepts.hpp	/^   const_pointer address(const_reference r);$/;"	p	class:allocator_architype	access:public	signature:(const_reference r)
address	/usr/include/boost/regex/concepts.hpp	/^   pointer address(reference r);$/;"	p	class:allocator_architype	access:public	signature:(reference r)
address_family_not_supported	/usr/include/boost/system/error_code.hpp	/^        address_family_not_supported = EAFNOSUPPORT,$/;"	e	enum:boost::system::errc::errc_t
address_in_use	/usr/include/boost/system/error_code.hpp	/^        address_in_use = EADDRINUSE,$/;"	e	enum:boost::system::errc::errc_t
address_not_available	/usr/include/boost/system/error_code.hpp	/^        address_not_available = EADDRNOTAVAIL,$/;"	e	enum:boost::system::errc::errc_t
add_class	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_class(m_type m)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(m_type m)
add_days	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type add_days(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
add_days	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type add_days(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
add_emacs_code	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool add_emacs_code(bool negate);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(bool negate)
add_emacs_code	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::add_emacs_code(bool negate)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(bool negate)
add_equivalent	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_equivalent(const digraph_type& s)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(const digraph_type& s)
add_negated_class	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_negated_class(m_type m)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(m_type m)
add_perms	/usr/include/boost/filesystem/operations.hpp	/^    add_perms = 0x1000,     \/\/ adds the given permission bits to the current bits$/;"	e	enum:boost::filesystem::perms
add_range	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_range(const digraph_type& first, const digraph_type& end)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(const digraph_type& first, const digraph_type& end)
add_single	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_single(const digraph_type& s)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(const digraph_type& s)
add_time_duration	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type add_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, time_duration_type td)
add_time_duration	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type add_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, time_duration_type td)
advertise_error	/usr/include/boost/system/linux_error.hpp	/^        advertise_error = EADV,$/;"	e	enum:boost::system::linux_error::linux_errno
after	/usr/include/boost/xpressive/regex_primitives.hpp	/^after(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
algorithm	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
algorithm	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
algorithm	/usr/include/boost/algorithm/string/regex.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
algorithm	/usr/include/boost/algorithm/string/regex_find_format.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
align	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void BOOST_REGEX_CALL align()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
allocate	/usr/include/boost/regex/concepts.hpp	/^   pointer allocate(size_type);$/;"	p	class:allocator_architype	access:public	signature:(size_type)
allocate	/usr/include/boost/regex/concepts.hpp	/^   pointer allocate(size_type, pointer);$/;"	p	class:allocator_architype	access:public	signature:(size_type, pointer)
allocator_architype	/usr/include/boost/regex/concepts.hpp	/^   allocator_architype();$/;"	p	class:allocator_architype	access:public	signature:()
allocator_architype	/usr/include/boost/regex/concepts.hpp	/^   allocator_architype(const allocator_architype&);$/;"	p	class:allocator_architype	access:public	signature:(const allocator_architype&)
allocator_architype	/usr/include/boost/regex/concepts.hpp	/^   allocator_architype(const allocator_architype<Other>&);$/;"	p	class:allocator_architype	access:public	signature:(const allocator_architype<Other>&)
allocator_architype	/usr/include/boost/regex/concepts.hpp	/^class allocator_architype$/;"	c
allocator_architype::address	/usr/include/boost/regex/concepts.hpp	/^   const_pointer address(const_reference r);$/;"	p	class:allocator_architype	access:public	signature:(const_reference r)
allocator_architype::address	/usr/include/boost/regex/concepts.hpp	/^   pointer address(reference r);$/;"	p	class:allocator_architype	access:public	signature:(reference r)
allocator_architype::allocate	/usr/include/boost/regex/concepts.hpp	/^   pointer allocate(size_type);$/;"	p	class:allocator_architype	access:public	signature:(size_type)
allocator_architype::allocate	/usr/include/boost/regex/concepts.hpp	/^   pointer allocate(size_type, pointer);$/;"	p	class:allocator_architype	access:public	signature:(size_type, pointer)
allocator_architype::allocator_architype	/usr/include/boost/regex/concepts.hpp	/^   allocator_architype();$/;"	p	class:allocator_architype	access:public	signature:()
allocator_architype::allocator_architype	/usr/include/boost/regex/concepts.hpp	/^   allocator_architype(const allocator_architype&);$/;"	p	class:allocator_architype	access:public	signature:(const allocator_architype&)
allocator_architype::allocator_architype	/usr/include/boost/regex/concepts.hpp	/^   allocator_architype(const allocator_architype<Other>&);$/;"	p	class:allocator_architype	access:public	signature:(const allocator_architype<Other>&)
allocator_architype::construct	/usr/include/boost/regex/concepts.hpp	/^   void construct(pointer, const_reference);$/;"	p	class:allocator_architype	access:public	signature:(pointer, const_reference)
allocator_architype::const_pointer	/usr/include/boost/regex/concepts.hpp	/^   typedef const T* const_pointer;$/;"	t	class:allocator_architype	access:public
allocator_architype::const_reference	/usr/include/boost/regex/concepts.hpp	/^   typedef const T& const_reference;$/;"	t	class:allocator_architype	access:public
allocator_architype::deallocate	/usr/include/boost/regex/concepts.hpp	/^   void deallocate(pointer, size_type);$/;"	p	class:allocator_architype	access:public	signature:(pointer, size_type)
allocator_architype::destroy	/usr/include/boost/regex/concepts.hpp	/^   void destroy(pointer);$/;"	p	class:allocator_architype	access:public	signature:(pointer)
allocator_architype::difference_type	/usr/include/boost/regex/concepts.hpp	/^   typedef int difference_type;$/;"	t	class:allocator_architype	access:public
allocator_architype::max_size	/usr/include/boost/regex/concepts.hpp	/^   size_type max_size()const;$/;"	p	class:allocator_architype	access:public	signature:() const
allocator_architype::pointer	/usr/include/boost/regex/concepts.hpp	/^   typedef T* pointer;$/;"	t	class:allocator_architype	access:public
allocator_architype::rebind	/usr/include/boost/regex/concepts.hpp	/^   struct rebind$/;"	s	class:allocator_architype	access:public
allocator_architype::rebind::other	/usr/include/boost/regex/concepts.hpp	/^      typedef allocator_architype<U> other;$/;"	t	struct:allocator_architype::rebind	access:public
allocator_architype::reference	/usr/include/boost/regex/concepts.hpp	/^   typedef T& reference;$/;"	t	class:allocator_architype	access:public
allocator_architype::size_type	/usr/include/boost/regex/concepts.hpp	/^   typedef unsigned size_type;$/;"	t	class:allocator_architype	access:public
allocator_architype::value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef T value_type;$/;"	t	class:allocator_architype	access:public
allocator_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          Allocator                                               allocator_type;$/;"	t	class:boost::match_results	access:public
all_all	/usr/include/boost/filesystem/operations.hpp	/^    all_all = owner_all|group_all|others_all,  \/\/ 0777$/;"	e	enum:boost::filesystem::perms
all_ctype_masks	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const all_ctype_masks = std_ctype_reserved$/;"	m	namespace:boost::xpressive::detail
alnum	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alnum = {{"alnum", false}};$/;"	m	class:boost::xpressive::proto::terminal
alpha	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alpha = {{"alpha", false}};$/;"	m	class:boost::xpressive::proto::terminal
already_connected	/usr/include/boost/system/error_code.hpp	/^        already_connected = EISCONN,$/;"	e	enum:boost::system::errc::errc_t
already_exists	/usr/include/boost/system/windows_error.hpp	/^        already_exists = ERROR_ALREADY_EXISTS$/;"	e	enum:boost::system::windows_error::windows_error_code
alt	/usr/include/boost/regex/v4/states.hpp	/^   offset_type     alt;                 \/\/ location to jump to$/;"	m	struct:boost::re_detail::re_jump	access:public
alternate_matcher	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef detail::alternate_matcher<detail::alternates_vector<BidiIter>, RegexTraits> alternate_matcher;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
amount	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<amount_dimension,system>                amount;                 \/\/\/< abstract unit of amount$/;"	t	namespace:boost::units::abstract
amount	/usr/include/boost/units/systems/si/amount.hpp	/^typedef unit<amount_dimension,si::system>    amount;$/;"	t	namespace:boost::units::si
amount_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct amount_unit_tag : base_unit<amount_unit_tag, amount_dimension, -25> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
angular_acceleration	/usr/include/boost/units/systems/si/angular_acceleration.hpp	/^typedef unit<angular_acceleration_dimension,si::system>      angular_acceleration;$/;"	t	namespace:boost::units::si
angular_momentum	/usr/include/boost/units/systems/si/angular_momentum.hpp	/^typedef unit<angular_momentum_dimension,si::system>      angular_momentum;$/;"	t	namespace:boost::units::si
angular_velocity	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^typedef unit<angular_velocity_dimension,si::system>      angular_velocity;$/;"	t	namespace:boost::units::si
answer	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef typename bound_type::type answer;$/;"	t	struct:boost::is_random_access_iterator	access:private
any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   any_type(const T&); $/;"	p	struct:boost::re_detail::any_type	access:public	signature:(const T&)
any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   any_type(const T&, const U&); $/;"	p	struct:boost::re_detail::any_type	access:public	signature:(const T&, const U&)
any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   any_type(const T&, const U&, const V&); $/;"	p	struct:boost::re_detail::any_type	access:public	signature:(const T&, const U&, const V&)
any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^struct any_type $/;"	s	namespace:boost::re_detail
append	/usr/include/boost/filesystem/path.hpp	/^    path& append(const value_type* ptr, const codecvt_type&)  \/\/ required in case ptr overlaps *this$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr, const codecvt_type&)
append	/usr/include/boost/filesystem/path.hpp	/^    path& append(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
append	/usr/include/boost/filesystem/path.hpp	/^    path& append(InputIterator begin, InputIterator end, const codecvt_type& cvt);$/;"	p	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
append	/usr/include/boost/filesystem/path.hpp	/^    path& append(Source const& source, const codecvt_type& cvt);$/;"	p	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
append	/usr/include/boost/filesystem/path.hpp	/^  path& path::append(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
append	/usr/include/boost/filesystem/path.hpp	/^  path& path::append(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	signature:(Source const& source, const codecvt_type& cvt)
append_literal	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_literal* append_literal(charT c);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(charT c)
append_literal	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_literal* basic_regex_creator<charT, traits>::append_literal(charT c)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(charT c)
append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const basic_char_set<charT, traits>& char_set)
append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, mpl::false_*);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const basic_char_set<charT, traits>& char_set, mpl::false_*)
append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, mpl::true_*);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const basic_char_set<charT, traits>& char_set, mpl::true_*)
append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline re_syntax_base* basic_regex_creator<charT, traits>::append_set($/;"	f	class:boost::re_detail::basic_regex_creator	signature:( const basic_char_set<charT, traits>& char_set)
append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::append_set($/;"	f	class:boost::re_detail::basic_regex_creator	signature:( const basic_char_set<charT, traits>& char_set, mpl::false_*)
append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::append_set($/;"	f	class:boost::re_detail::basic_regex_creator	signature:( const basic_char_set<charT, traits>& char_set, mpl::true_*)
append_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_state(syntax_element_type t, std::size_t s = sizeof(re_syntax_base));$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(syntax_element_type t, std::size_t s = sizeof(re_syntax_base))
append_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::append_state(syntax_element_type t, std::size_t s)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(syntax_element_type t, std::size_t s)
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply : mpl::less<typename T0::tag_type, typename T1::tag_type> {};$/;"	s	struct:boost::mpl::less_impl	inherits:mpl::less	access:public
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::divides_impl	access:public
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::negate_impl	access:public
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::plus_impl	access:public
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::times_impl	access:public
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::units::detail::get_scale_list_of_heterogeneous_system_impl	access:public
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::units::detail::make_heterogeneous_system_impl	access:public
apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::units::detail::unscale_heterogeneous_system_impl	access:public
area	/usr/include/boost/units/systems/cgs/area.hpp	/^typedef unit<area_dimension,cgs::system>     area;$/;"	t	namespace:boost::units::cgs
area	/usr/include/boost/units/systems/si/area.hpp	/^typedef unit<area_dimension,si::system>      area;$/;"	t	namespace:boost::units::si
arena_trashed	/usr/include/boost/system/windows_error.hpp	/^        arena_trashed = ERROR_ARENA_TRASHED,$/;"	e	enum:boost::system::windows_error::windows_error_code
argument_list_too_long	/usr/include/boost/system/error_code.hpp	/^        argument_list_too_long = E2BIG,$/;"	e	enum:boost::system::errc::errc_t
argument_out_of_domain	/usr/include/boost/system/error_code.hpp	/^        argument_out_of_domain = EDOM,$/;"	e	enum:boost::system::errc::errc_t
as	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct as$/;"	s	namespace:boost::xpressive::op
as	/usr/include/boost/xpressive/regex_actions.hpp	/^    as(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
asio	/usr/include/boost/asio/system_timer.hpp	/^namespace asio {$/;"	n	namespace:boost
assert_word_begin	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_begin> assert_word_begin;$/;"	t	namespace:boost::xpressive::detail
assert_word_boundary	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_boundary<mpl::true_> > assert_word_boundary;$/;"	t	namespace:boost::xpressive::detail
assert_word_end	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_end> assert_word_end;$/;"	t	namespace:boost::xpressive::detail
assign	/usr/include/boost/filesystem/operations.hpp	/^  void assign(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st = file_status(), file_status symlink_st = file_status())
assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(const value_type* ptr, const codecvt_type&)  \/\/ required in case ptr overlaps *this$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr, const codecvt_type&)
assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const basic_regex& that)$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const charT* p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const charT* p, size_type len, flag_type f)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, size_type len, flag_type f)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const charT* p1,$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL assign($/;"	f	class:boost::basic_regex	access:public	signature:( const std::basic_string<charT, string_traits, A>& s, flag_type f = regex_constants::normal)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL assign($/;"	f	class:boost::basic_regex	access:public	signature:( const std::basic_string<charT>& s, flag_type f = regex_constants::normal)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL assign(InputIterator arg_first,$/;"	f	class:boost::basic_regex	access:public	signature:(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   void assign(const charT* arg_first,$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(const charT* arg_first, const charT* arg_last, flag_type f)
assign	/usr/include/boost/system/error_code.hpp	/^      void assign( int val, const error_category & cat )$/;"	f	class:boost::system::error_code	access:public	signature:( int val, const error_category & cat )
assign	/usr/include/boost/system/error_code.hpp	/^      void assign( int val, const error_category & cat )$/;"	f	class:boost::system::error_condition	access:public	signature:( int val, const error_category & cat )
as_xpr	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::functional::as_expr<> const as_xpr = {};$/;"	m	class:boost::xpressive::proto::functional
as_xpr	/usr/include/boost/xpressive/regex_primitives.hpp	/^template<typename Literal> detail::unspecified as_xpr(Literal const &literal) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Literal const &literal)
at	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct at$/;"	s	namespace:boost::xpressive::op
at	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::at>::type const at = {{}};$/;"	m	class:boost::xpressive::function
available	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t available; \/\/ <= free$/;"	m	struct:boost::filesystem::space_info	access:public
awk	/usr/include/boost/regex/v4/regbase.hpp	/^      awk = ::boost::regbase::awk,$/;"	e	enum:boost::regex_constants::flag_type_
awk	/usr/include/boost/regex/v4/regbase.hpp	/^      awk = no_bk_refs | collate | no_perl_ex,$/;"	e	enum:boost::regbase::flag_type_
back	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct back$/;"	s	namespace:boost::xpressive::op
back	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::back>::type const back = {{}};$/;"	m	class:boost::xpressive::function
backstop	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator backstop;$/;"	m	class:boost::re_detail::perl_matcher	access:private
backtrack_till_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool backtrack_till_match(std::size_t count);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(std::size_t count)
backtrack_till_match	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::backtrack_till_match(std::size_t count)$/;"	f	class:boost::re_detail::perl_matcher	signature:(std::size_t count)
backup_subex	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   backup_subex(const match_results<BidiIterator, A>& w, int i)$/;"	f	class:boost::re_detail::backup_subex	access:public	signature:(const match_results<BidiIterator, A>& w, int i)
backup_subex	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^class backup_subex$/;"	c	namespace:boost::re_detail
bad_address	/usr/include/boost/system/error_code.hpp	/^        bad_address = EFAULT,$/;"	e	enum:boost::system::errc::errc_t
bad_command	/usr/include/boost/system/windows_error.hpp	/^        bad_command = ERROR_BAD_COMMAND,$/;"	e	enum:boost::system::windows_error::windows_error_code
bad_environment	/usr/include/boost/system/windows_error.hpp	/^        bad_environment = ERROR_BAD_ENVIRONMENT,$/;"	e	enum:boost::system::windows_error::windows_error_code
bad_exchange	/usr/include/boost/system/linux_error.hpp	/^        bad_exchange = EBADE,$/;"	e	enum:boost::system::linux_error::linux_errno
bad_expression	/usr/include/boost/regex/pattern_except.hpp	/^typedef regex_error bad_expression;$/;"	t	namespace:boost
bad_file_descriptor	/usr/include/boost/system/error_code.hpp	/^        bad_file_descriptor = EBADF,$/;"	e	enum:boost::system::errc::errc_t
bad_file_number	/usr/include/boost/system/linux_error.hpp	/^        bad_file_number = EBADFD,$/;"	e	enum:boost::system::linux_error::linux_errno
bad_font_format	/usr/include/boost/system/linux_error.hpp	/^        bad_font_format = EBFONT,$/;"	e	enum:boost::system::linux_error::linux_errno
bad_format	/usr/include/boost/system/windows_error.hpp	/^        bad_format = ERROR_BAD_FORMAT,$/;"	e	enum:boost::system::windows_error::windows_error_code
bad_length	/usr/include/boost/system/windows_error.hpp	/^        bad_length = ERROR_BAD_LENGTH,$/;"	e	enum:boost::system::windows_error::windows_error_code
bad_message	/usr/include/boost/system/error_code.hpp	/^        bad_message = EBADMSG,$/;"	e	enum:boost::system::errc::errc_t
bad_net_path	/usr/include/boost/system/windows_error.hpp	/^        bad_net_path = ERROR_BAD_NETPATH,$/;"	e	enum:boost::system::windows_error::windows_error_code
bad_pattern	/usr/include/boost/regex/pattern_except.hpp	/^typedef regex_error bad_pattern;$/;"	t	namespace:boost
bad_request_code	/usr/include/boost/system/linux_error.hpp	/^        bad_request_code = EBADRQC,$/;"	e	enum:boost::system::linux_error::linux_errno
bad_request_descriptor	/usr/include/boost/system/linux_error.hpp	/^        bad_request_descriptor = EBADR,$/;"	e	enum:boost::system::linux_error::linux_errno
bad_slot	/usr/include/boost/system/linux_error.hpp	/^        bad_slot = EBADSLT,$/;"	e	enum:boost::system::linux_error::linux_errno
bad_unit	/usr/include/boost/system/windows_error.hpp	/^        bad_unit = ERROR_BAD_UNIT,$/;"	e	enum:boost::system::windows_error::windows_error_code
base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:() const
base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:() const
base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:() const
base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:() const
base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::utf16_output_iterator	access:public	signature:() const
base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::utf8_output_iterator	access:public	signature:() const
base	/usr/include/boost/regex/v4/match_results.hpp	/^   BidiIterator base()const$/;"	f	class:boost::match_results	access:public	signature:() const
base	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator base;$/;"	m	class:boost::re_detail::perl_matcher	access:private
base	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state *base, *end;$/;"	m	struct:boost::re_detail::saved_extra_block	access:public
base	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   BidirectionalIterator                base;  \/\/ start of sequence$/;"	m	class:boost::regex_iterator_implementation	access:private
base	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   BidirectionalIterator                base;    \/\/ start of search area$/;"	m	class:boost::regex_token_iterator_implementation	access:private
base	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   BidirectionalIterator                base;  \/\/ start of sequence$/;"	m	class:boost::u32regex_iterator_implementation	access:private
base	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   BidirectionalIterator                base;   \/\/ start of search area$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
base	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef power_typeof_helper<typename T1::value_type, static_rational<N,D> > base;$/;"	t	struct:boost::units::power_typeof_helper	access:public
basename	/usr/include/boost/filesystem/convenience.hpp	/^    inline std::string basename(const path & p)$/;"	f	namespace:boost::filesystem	signature:(const path & p)
BaseRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BaseRegexConcept();$/;"	p	struct:boost::BaseRegexConcept	access:public	signature:()
BaseRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BaseRegexConcept(const BaseRegexConcept&);$/;"	p	struct:boost::BaseRegexConcept	access:public	signature:(const BaseRegexConcept&)
BaseRegexConcept	/usr/include/boost/regex/concepts.hpp	/^struct BaseRegexConcept$/;"	s	namespace:boost
base_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef iterator_range<IteratorT> base_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
base_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef aggregate_filter<Ch, Alloc>                 base_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:private
base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u16_to_u32_iterator<BaseIterator, U32Type>, U32Type, std::bidirectional_iterator_tag, const U32Type> base_type;$/;"	t	class:boost::u16_to_u32_iterator	access:private
base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u32_to_u16_iterator<BaseIterator, U16Type>, U16Type, std::bidirectional_iterator_tag, const U16Type> base_type;$/;"	t	class:boost::u32_to_u16_iterator	access:private
base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u32_to_u8_iterator<BaseIterator, U8Type>, U8Type, std::bidirectional_iterator_tag, const U8Type> base_type;$/;"	t	class:boost::u32_to_u8_iterator	access:private
base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u8_to_u32_iterator<BaseIterator, U32Type>, U32Type, std::bidirectional_iterator_tag, const U32Type> base_type;$/;"	t	class:boost::u8_to_u32_iterator	access:private
base_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef regex_traits<char> base_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
base_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef regex_traits<wchar_t> base_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
base_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef ::std::basic_streambuf<charT, traits> base_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
base_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef proto::extends<pimpl_type, basic_regex<BidiIter>, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
base_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<reference_wrapper<T> >::type, reference<T> > base_type;$/;"	t	struct:boost::xpressive::reference	access:public
base_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<T>::type, value<T> > base_type;$/;"	t	struct:boost::xpressive::value	access:public
base_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<reference_wrapper<T> >::type base_type;$/;"	t	struct:boost::xpressive::local	access:public
base_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef proto::extends<detail::basic_mark_tag, mark_tag, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::mark_tag	access:private
base_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::cpp_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
base_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef detail::c_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::amount_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::current_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::length_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::luminous_intensity_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::mass_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::plane_angle_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::solid_angle_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::temperature_unit_tag> $/;"	s	namespace:boost::units
base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::time_unit_tag> $/;"	s	namespace:boost::units
base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u16_to_u32_iterator	access:private
base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u32_to_u16_iterator	access:private
base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u32_to_u8_iterator	access:private
base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u8_to_u32_iterator	access:private
basic	/usr/include/boost/regex/v4/regbase.hpp	/^      basic = ::boost::regbase::basic,$/;"	e	enum:boost::regex_constants::flag_type_
basic	/usr/include/boost/regex/v4/regbase.hpp	/^      basic = basic_syntax_group | collate | no_escape_in_lists,$/;"	e	enum:boost::regbase::flag_type_
basic_char_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_char_set()$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:()
basic_char_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^class basic_char_set$/;"	c	namespace:boost::re_detail
basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^    basic_filebuf() {}$/;"	f	class:boost::filesystem::basic_filebuf	access:public	signature:()
basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^    basic_filebuf(const basic_filebuf&);$/;"	p	class:boost::filesystem::basic_filebuf	access:private	signature:(const basic_filebuf&)
basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_filebuf : public std::basic_filebuf<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_filebuf
basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_fstream() {}$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:()
basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_fstream(const basic_fstream&);$/;"	p	class:boost::filesystem::basic_fstream	access:private	signature:(const basic_fstream&)
basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_fstream(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    explicit basic_fstream(const path& p)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p)
basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_fstream : public std::basic_fstream<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_fstream
basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ifstream() {}$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:()
basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ifstream(const basic_ifstream&);$/;"	p	class:boost::filesystem::basic_ifstream	access:private	signature:(const basic_ifstream&)
basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ifstream(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    explicit basic_ifstream(const path& p)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p)
basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_ifstream : public std::basic_ifstream<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_ifstream
basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ofstream() {}$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:()
basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ofstream(const basic_ofstream&);$/;"	p	class:boost::filesystem::basic_ofstream	access:private	signature:(const basic_ofstream&)
basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ofstream(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    explicit basic_ofstream(const path& p)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p)
basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_ofstream : public std::basic_ofstream<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_ofstream
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const basic_regex& that)$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that)
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const charT* p, size_type len, flag_type f)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, size_type len, flag_type f)
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit basic_regex(){}$/;"	f	class:boost::basic_regex	access:public	signature:()
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit basic_regex(const charT* p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit basic_regex(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^class basic_regex : public regbase$/;"	c	namespace:boost	inherits:regbase
basic_regex	/usr/include/boost/regex/v4/instances.hpp	/^template class BOOST_REGEX_DECL basic_regex< BOOST_REGEX_CHAR_T BOOST_REGEX_TRAITS_T >;$/;"	m	namespace:boost	typeref:class:boost::BOOST_REGEX_DECL
basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:()
basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(char_type const *);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(char_type const *)
basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(string_type const &);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(string_type const &)
basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^struct basic_regex$/;"	s	namespace:boost::xpressive	inherits:proto::extends
basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_regex_creator(const basic_regex_creator&);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(const basic_regex_creator&)
basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_regex_creator(regex_data<charT, traits>* data);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(regex_data<charT, traits>* data)
basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^basic_regex_creator<charT, traits>::basic_regex_creator(regex_data<charT, traits>* data)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(regex_data<charT, traits>* data)
basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^class basic_regex_creator$/;"	c	namespace:boost::re_detail
basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    basic_regex_filter( const regex_type& re,$/;"	f	class:boost::iostreams::basic_regex_filter	access:public	signature:( const regex_type& re, const char_type* fmt, flag_type flags = regex_constants::match_default, flag_type fmt_flags = regex_constants::format_default )
basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    basic_regex_filter( const regex_type& re,$/;"	f	class:boost::iostreams::basic_regex_filter	access:public	signature:( const regex_type& re, const formatter& replace, flag_type flags = regex_constants::match_default )
basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    basic_regex_filter( const regex_type& re,$/;"	f	class:boost::iostreams::basic_regex_filter	access:public	signature:( const regex_type& re, const string_type& fmt, flag_type flags = regex_constants::match_default, flag_type fmt_flags = regex_constants::format_default )
basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^class basic_regex_filter : public aggregate_filter<Ch, Alloc> {$/;"	c	namespace:boost::iostreams	inherits:aggregate_filter
basic_regex_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^   basic_regex_formatter(const basic_regex_formatter&);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(const basic_regex_formatter&)
basic_regex_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^   basic_regex_formatter(OutputIterator o, const Results& r, const traits& t)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:public	signature:(OutputIterator o, const Results& r, const traits& t)
basic_regex_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^class basic_regex_formatter$/;"	c	namespace:boost::re_detail
basic_regex_implementation	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex_implementation(){}$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:()
basic_regex_implementation	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex_implementation(const ::boost::shared_ptr<$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(const ::boost::shared_ptr< ::boost::regex_traits_wrapper<traits> >& t)
basic_regex_implementation	/usr/include/boost/regex/v4/basic_regex.hpp	/^class basic_regex_implementation$/;"	c	namespace:boost::re_detail	inherits:regex_data
basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   basic_regex_parser(const basic_regex_parser&);$/;"	p	class:boost::re_detail::basic_regex_parser	access:private	signature:(const basic_regex_parser&)
basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   basic_regex_parser(regex_data<charT, traits>* data);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_data<charT, traits>* data)
basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^basic_regex_parser<charT, traits>::basic_regex_parser(regex_data<charT, traits>* data)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(regex_data<charT, traits>* data)
basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^class basic_regex_parser : public basic_regex_creator<charT, traits>$/;"	c	namespace:boost::re_detail	inherits:basic_regex_creator
basic_string	/usr/include/boost/regex/config.hpp	/^      extern template class __declspec(dllimport) std::basic_string<unsigned short>;$/;"	m	class:std
basic_syntax_group	/usr/include/boost/regex/v4/regbase.hpp	/^      basic_syntax_group = 1,                     \/\/ POSIX basic$/;"	e	enum:boost::regbase::flag_type_
before	/usr/include/boost/xpressive/regex_primitives.hpp	/^before(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
begin	/usr/include/boost/filesystem/path.hpp	/^    iterator begin() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
begin	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL begin()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
begin	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL begin()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
begin	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* begin(){ return _first; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
begin	/usr/include/boost/regex/v4/match_results.hpp	/^   const_iterator begin() const$/;"	f	class:boost::match_results	access:public	signature:() const
begin	/usr/include/boost/xpressive/regex_algorithms.hpp	/^        BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) begin$/;"	m	namespace:boost::xpressive::detail
BidiIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef bidirectional_iterator_archetype<value_type> BidiIterator;$/;"	t	struct:boost::BaseRegexConcept	access:public
BidiIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef bidirectional_iterator_archetype<value_type> BidiIterator;$/;"	t	struct:boost::BoostRegexConcept	access:public
BidiIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef boost::bidirectional_iterator_archetype<value_type> BidiIterator;$/;"	t	struct:boost::RegexConcept	access:public
binary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    typedef binary_type (*binary_fun)(any_type, any_type);$/;"	t	struct:boost::re_detail::unary_binary_ternary	access:public
binary_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char (&binary_type)[3];$/;"	t	namespace:boost::re_detail
BindArg	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct BindArg$/;"	s	namespace:boost::xpressive::detail
BindArgs	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct BindArgs$/;"	s	namespace:boost::xpressive::detail	inherits:proto::function
bind_args	/usr/include/boost/xpressive/regex_actions.hpp	/^        void bind_args(let_<Args> const &args, match_results<BidiIter> &what)$/;"	f	namespace:boost::xpressive::detail	signature:(let_<Args> const &args, match_results<BidiIter> &what)
BitmaskConcept	/usr/include/boost/regex/concepts.hpp	/^struct BitmaskConcept$/;"	s	namespace:boost
bitmask_archetype	/usr/include/boost/regex/concepts.hpp	/^typedef std::bitset<512> bitmask_archetype;$/;"	t	namespace:boost
bk_plus_qm	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_plus_qm = 1 << 10,                       \/\/ uses \\+ and \\?$/;"	e	enum:boost::regbase::flag_type_
bk_plus_qm	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_plus_qm = ::boost::regbase::bk_plus_qm,$/;"	e	enum:boost::regex_constants::flag_type_
bk_vbar	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_vbar = 1 << 11,                          \/\/ use \\| for alternatives$/;"	e	enum:boost::regbase::flag_type_
bk_vbar	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_vbar = ::boost::regbase::bk_vbar,$/;"	e	enum:boost::regex_constants::flag_type_
blank	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const blank = {{"blank", false}};$/;"	m	class:boost::xpressive::proto::terminal
block_file	/usr/include/boost/filesystem/operations.hpp	/^    block_file,$/;"	e	enum:boost::filesystem::file_type
bol	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bol_placeholder>::type const bol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/algorithm/string/regex.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/algorithm/string/regex_find_format.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/asio/detail/regex_fwd.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/asio/system_timer.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/chrono/system_clocks.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/date_time/posix_time/posix_time_system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/date_time/time_system_counted.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/date_time/time_system_split.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/detail/win/system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/filesystem/convenience.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/filesystem/fstream.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/filesystem/operations.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/filesystem/path.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/filesystem/path_traits.hpp	/^namespace boost { namespace filesystem {$/;"	n
boost	/usr/include/boost/geometry/core/coordinate_system.hpp	/^namespace boost { namespace geometry$/;"	n
boost	/usr/include/boost/iostreams/detail/system_failure.hpp	/^namespace boost { namespace iostreams { namespace detail {$/;"	n
boost	/usr/include/boost/iostreams/filter/regex.hpp	/^namespace boost { namespace iostreams {$/;"	n
boost	/usr/include/boost/regex/concepts.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/config.hpp	/^namespace boost{ namespace re_detail{$/;"	n
boost	/usr/include/boost/regex/config.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/icu.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/mfc.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/pattern_except.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/pending/object_cache.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/pending/static_mutex.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/basic_regex.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^namespace boost{ $/;"	n
boost	/usr/include/boost/regex/v4/cregex.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/error_type.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/fileiter.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/instances.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/iterator_category.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/iterator_traits.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/match_flags.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/match_results.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/perl_matcher.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/primary_transform.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/protected_call.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regbase.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_format.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_fwd.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_grep.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_iterator.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_match.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_merge.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_replace.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_search.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_split.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_traits.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^namespace boost{ namespace re_detail{$/;"	n
boost	/usr/include/boost/regex/v4/regex_workaround.hpp	/^namespace boost{ namespace re_detail{$/;"	n
boost	/usr/include/boost/regex/v4/states.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/sub_match.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/syntax_type.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^namespace boost{ $/;"	n
boost	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^namespace boost { namespace spirit {$/;"	n
boost	/usr/include/boost/system/cygwin_error.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/system/error_code.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/system/linux_error.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/system/system_error.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/system/windows_error.hpp	/^namespace boost$/;"	n
boost	/usr/include/boost/units/get_system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/heterogeneous_system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/homogeneous_system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/is_quantity_of_system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/is_unit_of_system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/make_system.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/abstract.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/angle/degrees.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/angle/gradians.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/angle/revolutions.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/area.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/base.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/current.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/dimensionless.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/energy.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/force.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/frequency.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/io.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/length.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/mass.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/mass_density.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/momentum.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/power.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/pressure.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/time.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/velocity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/volume.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/detail/constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/acceleration.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/action.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/activity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/amount.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/angular_acceleration.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/angular_momentum.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/area.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/base.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/capacitance.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/conductance.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/conductivity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/current.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/dimensionless.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/electric_charge.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/electric_potential.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/energy.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/force.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/frequency.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/illuminance.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/impedance.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/inductance.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/io.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/length.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/mass.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/mass_density.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/momentum.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/permeability.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/permittivity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/plane_angle.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/power.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/prefixes.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/pressure.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/reluctance.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/resistance.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/resistivity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/solid_angle.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/surface_density.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/surface_tension.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/temperature.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/time.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/torque.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/velocity.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/volume.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/si/wavenumber.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/temperature/celsius.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^namespace boost {$/;"	n
boost	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n
boost	/usr/include/boost/xpressive/basic_regex.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	/usr/include/boost/xpressive/regex_actions.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/regex_algorithms.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/regex_compiler.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n
boost	/usr/include/boost/xpressive/regex_error.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	/usr/include/boost/xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	/usr/include/boost/xpressive/regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost::algorithm	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
boost::algorithm	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
boost::algorithm	/usr/include/boost/algorithm/string/regex.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
boost::algorithm	/usr/include/boost/algorithm/string/regex_find_format.hpp	/^    namespace algorithm {$/;"	n	namespace:boost
boost::algorithm::detail	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^        namespace detail {$/;"	n	namespace:boost::algorithm
boost::algorithm::detail	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^        namespace detail {$/;"	n	namespace:boost::algorithm
boost::algorithm::detail::find_regexF	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^            struct find_regexF$/;"	s	namespace:boost::algorithm::detail
boost::algorithm::detail::find_regexF::find_regexF	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                find_regexF( regex_reference_type Rx, match_flag_type MatchFlags = match_default ) : $/;"	f	struct:boost::algorithm::detail::find_regexF	access:public	signature:( regex_reference_type Rx, match_flag_type MatchFlags = match_default )
boost::algorithm::detail::find_regexF::m_MatchFlags	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                match_flag_type m_MatchFlags;     \/\/ match flags$/;"	m	struct:boost::algorithm::detail::find_regexF	access:private
boost::algorithm::detail::find_regexF::m_Rx	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_reference_type m_Rx; \/\/ Regexp$/;"	m	struct:boost::algorithm::detail::find_regexF	access:private
boost::algorithm::detail::find_regexF::operator ()	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                operator()( $/;"	f	struct:boost::algorithm::detail::find_regexF	access:public	signature:( ForwardIteratorT Begin, ForwardIteratorT End ) const
boost::algorithm::detail::find_regexF::regex_reference_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef const RegExT& regex_reference_type;$/;"	t	struct:boost::algorithm::detail::find_regexF	access:public
boost::algorithm::detail::find_regexF::regex_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef RegExT regex_type;$/;"	t	struct:boost::algorithm::detail::find_regexF	access:public
boost::algorithm::detail::regex_formatF	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^            struct regex_formatF$/;"	s	namespace:boost::algorithm::detail
boost::algorithm::detail::regex_formatF::char_type	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                typedef BOOST_STRING_TYPENAME StringT::value_type char_type;$/;"	t	struct:boost::algorithm::detail::regex_formatF	access:private
boost::algorithm::detail::regex_formatF::m_Flags	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                match_flag_type m_Flags;$/;"	m	struct:boost::algorithm::detail::regex_formatF	access:private
boost::algorithm::detail::regex_formatF::m_Fmt	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                const StringT& m_Fmt;$/;"	m	struct:boost::algorithm::detail::regex_formatF	access:private
boost::algorithm::detail::regex_formatF::operator ()	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                result_type operator()( $/;"	f	struct:boost::algorithm::detail::regex_formatF	access:public	signature:( const regex_search_result<InputIteratorT>& Replace ) const
boost::algorithm::detail::regex_formatF::regex_formatF	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                regex_formatF( const StringT& Fmt, match_flag_type Flags=format_default ) :$/;"	f	struct:boost::algorithm::detail::regex_formatF	access:public	signature:( const StringT& Fmt, match_flag_type Flags=format_default )
boost::algorithm::detail::regex_formatF::result_type	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                typedef StringT result_type;$/;"	t	struct:boost::algorithm::detail::regex_formatF	access:private
boost::algorithm::detail::regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^            struct regex_search_result : $/;"	s	namespace:boost::algorithm::detail	inherits:iterator_range
boost::algorithm::detail::regex_search_result::base_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef iterator_range<IteratorT> base_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
boost::algorithm::detail::regex_search_result::const_iterator	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::const_iterator const_iterator;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
boost::algorithm::detail::regex_search_result::difference_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::difference_type difference_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
boost::algorithm::detail::regex_search_result::iterator	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::iterator iterator;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
boost::algorithm::detail::regex_search_result::match_results	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                const match_results_type& match_results() const$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:() const
boost::algorithm::detail::regex_search_result::match_results_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef boost::match_results<iterator> match_results_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
boost::algorithm::detail::regex_search_result::m_MatchResults	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                match_results_type m_MatchResults;$/;"	m	struct:boost::algorithm::detail::regex_search_result	access:private
boost::algorithm::detail::regex_search_result::operator =	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result& operator=( const regex_search_result& Other )$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( const regex_search_result& Other )
boost::algorithm::detail::regex_search_result::regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result( const match_results_type& MatchResults ) :$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( const match_results_type& MatchResults )
boost::algorithm::detail::regex_search_result::regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result( const regex_search_result& Other ) :$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( const regex_search_result& Other )
boost::algorithm::detail::regex_search_result::regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result( IteratorT End ) :$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( IteratorT End )
boost::algorithm::detail::regex_search_result::type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef regex_search_result<IteratorT> type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
boost::algorithm::detail::regex_search_result::value_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::value_type value_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
boost::algorithm::erase_all_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void erase_all_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::erase_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT erase_all_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::erase_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT erase_all_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::erase_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void erase_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::erase_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT erase_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::erase_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT erase_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::find_all_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceSequenceT& find_all_regex($/;"	f	namespace:boost::algorithm	signature:( SequenceSequenceT& Result, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::find_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        find_regex( $/;"	f	namespace:boost::algorithm	signature:( RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::join_if	/usr/include/boost/algorithm/string/regex.hpp	/^        join_if($/;"	f	namespace:boost::algorithm	signature:( const SequenceSequenceT& Input, const Range1T& Separator, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::join_if_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        join_if_regex($/;"	f	namespace:boost::algorithm	signature:( const SequenceSequenceT& Input, const Range1T& Separator, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::algorithm::regex_finder	/usr/include/boost/algorithm/string/regex_find_format.hpp	/^        regex_finder($/;"	f	namespace:boost::algorithm	signature:( const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type MatchFlags=match_default )
boost::algorithm::regex_formatter	/usr/include/boost/algorithm/string/regex_find_format.hpp	/^        regex_formatter( $/;"	f	namespace:boost::algorithm	signature:( const std::basic_string<CharT, TraitsT, AllocT>& Format, match_flag_type Flags=format_default )
boost::algorithm::replace_all_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void replace_all_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
boost::algorithm::replace_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT replace_all_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
boost::algorithm::replace_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT replace_all_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
boost::algorithm::replace_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void replace_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
boost::algorithm::replace_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT replace_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
boost::algorithm::replace_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT replace_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
boost::algorithm::split_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceSequenceT& split_regex($/;"	f	namespace:boost::algorithm	signature:( SequenceSequenceT& Result, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
boost::asio	/usr/include/boost/asio/system_timer.hpp	/^namespace asio {$/;"	n	namespace:boost
boost::asio::system_timer	/usr/include/boost/asio/system_timer.hpp	/^typedef basic_waitable_timer<chrono::system_clock> system_timer;$/;"	t	namespace:boost::asio
boost::bad_expression	/usr/include/boost/regex/pattern_except.hpp	/^typedef regex_error bad_expression;$/;"	t	namespace:boost
boost::bad_pattern	/usr/include/boost/regex/pattern_except.hpp	/^typedef regex_error bad_pattern;$/;"	t	namespace:boost
boost::BaseRegexConcept	/usr/include/boost/regex/concepts.hpp	/^struct BaseRegexConcept$/;"	s	namespace:boost
boost::BaseRegexConcept::BaseRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BaseRegexConcept();$/;"	p	struct:boost::BaseRegexConcept	access:public	signature:()
boost::BaseRegexConcept::BaseRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BaseRegexConcept(const BaseRegexConcept&);$/;"	p	struct:boost::BaseRegexConcept	access:public	signature:(const BaseRegexConcept&)
boost::BaseRegexConcept::BidiIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef bidirectional_iterator_archetype<value_type> BidiIterator;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::BaseRegexConcept	access:public	signature:()
boost::BaseRegexConcept::flag_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::flag_type flag_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::global_constraints	/usr/include/boost/regex/concepts.hpp	/^   void global_constraints()$/;"	f	struct:boost::BaseRegexConcept	access:public	signature:()
boost::BaseRegexConcept::in1	/usr/include/boost/regex/concepts.hpp	/^   input_iterator_type in1, in2;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::in2	/usr/include/boost/regex/concepts.hpp	/^   input_iterator_type in1, in2;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::input_iterator_type	/usr/include/boost/regex/concepts.hpp	/^   typedef input_iterator_archetype<value_type> input_iterator_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::locale_type locale_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::match_results_default_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::match_results_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_char	/usr/include/boost/regex/concepts.hpp	/^   const value_type m_char;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_cresults	/usr/include/boost/regex/concepts.hpp	/^   const match_results_type m_cresults;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_flags	/usr/include/boost/regex/concepts.hpp	/^   flag_type m_flags;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_in	/usr/include/boost/regex/concepts.hpp	/^   BidiIterator m_in;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_mft	/usr/include/boost/regex/concepts.hpp	/^   global_regex_namespace::regex_constants::match_flag_type m_mft;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_out	/usr/include/boost/regex/concepts.hpp	/^   OutIterator m_out;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_pmatch	/usr/include/boost/regex/concepts.hpp	/^      m_pmatch;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_pointer	/usr/include/boost/regex/concepts.hpp	/^   pointer_type m_pointer;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_results	/usr/include/boost/regex/concepts.hpp	/^   match_results_type m_results;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_size	/usr/include/boost/regex/concepts.hpp	/^   std::size_t m_size;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::m_sub	/usr/include/boost/regex/concepts.hpp	/^   const sub_match_type m_sub;$/;"	m	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::operator =	/usr/include/boost/regex/concepts.hpp	/^   BaseRegexConcept& operator=(const BaseRegexConcept&);$/;"	p	struct:boost::BaseRegexConcept	access:public	signature:(const BaseRegexConcept&)
boost::BaseRegexConcept::OutIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef output_iterator_archetype<value_type> OutIterator;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::pointer_type	/usr/include/boost/regex/concepts.hpp	/^   typedef const value_type* pointer_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::regex_iterator_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::regex_iterator<BidiIterator, value_type, traits_type> regex_iterator_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::regex_token_iterator_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::regex_token_iterator<BidiIterator, value_type, traits_type> regex_token_iterator_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::sub_match_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::traits_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename regex_traits_computer<Regex>::type traits_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::BaseRegexConcept::value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::value_type value_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
boost::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^class basic_regex : public regbase$/;"	c	namespace:boost	inherits:regbase
boost::basic_regex	/usr/include/boost/regex/v4/instances.hpp	/^template class BOOST_REGEX_DECL basic_regex< BOOST_REGEX_CHAR_T BOOST_REGEX_TRAITS_T >;$/;"	m	namespace:boost	typeref:class:boost::BOOST_REGEX_DECL
boost::basic_regex::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const basic_regex& that)$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that)
boost::basic_regex::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const charT* p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
boost::basic_regex::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const charT* p, size_type len, flag_type f)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, size_type len, flag_type f)
boost::basic_regex::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& assign(const charT* p1,$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
boost::basic_regex::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL assign($/;"	f	class:boost::basic_regex	access:public	signature:( const std::basic_string<charT, string_traits, A>& s, flag_type f = regex_constants::normal)
boost::basic_regex::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL assign($/;"	f	class:boost::basic_regex	access:public	signature:( const std::basic_string<charT>& s, flag_type f = regex_constants::normal)
boost::basic_regex::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL assign(InputIterator arg_first,$/;"	f	class:boost::basic_regex	access:public	signature:(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const basic_regex& that)$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that)
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const charT* p, size_type len, flag_type f)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, size_type len, flag_type f)
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit basic_regex(){}$/;"	f	class:boost::basic_regex	access:public	signature:()
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit basic_regex(const charT* p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
boost::basic_regex::basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit basic_regex(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
boost::basic_regex::begin	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL begin()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::can_be_null	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool can_be_null()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::char_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef charT                                 char_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::compare	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int BOOST_REGEX_CALL compare(const basic_regex& that) const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that) const
boost::basic_regex::const_iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const charT*                          const_iterator;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::const_reference	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const charT&                          const_reference;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::difference_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::ptrdiff_t                        difference_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::do_assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& do_assign(const charT* p1,$/;"	p	class:boost::basic_regex	access:private	signature:(const charT* p1, const charT* p2, flag_type f)
boost::basic_regex::do_assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^basic_regex<charT, traits>& basic_regex<charT, traits>::do_assign(const charT* p1,$/;"	f	class:boost::basic_regex	signature:(const charT* p1, const charT* p2, flag_type f)
boost::basic_regex::empty	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL empty()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::end	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL end()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::error_code	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL error_code()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const charT* BOOST_REGEX_CALL expression()const $/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::flags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type BOOST_REGEX_CALL flags()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef regex_constants::syntax_option_type   flag_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::getflags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type BOOST_REGEX_CALL getflags()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::getloc	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL getloc()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::get_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const re_detail::regex_data<charT, traits>& get_data()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::get_first_state	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const re_detail::re_syntax_base* get_first_state()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::get_map	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const unsigned char* get_map()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::get_named_subs	/usr/include/boost/regex/v4/basic_regex.hpp	/^   boost::shared_ptr<re_detail::named_subexpressions > get_named_subs()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::get_restart_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned get_restart_type()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::get_traits	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const ::boost::regex_traits_wrapper<traits>& get_traits()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::imbue	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL imbue(locale_type l);$/;"	p	class:boost::basic_regex	access:public	signature:(locale_type l)
boost::basic_regex::imbue	/usr/include/boost/regex/v4/basic_regex.hpp	/^typename basic_regex<charT, traits>::locale_type BOOST_REGEX_CALL basic_regex<charT, traits>::imbue(locale_type l)$/;"	f	class:boost::basic_regex	signature:(locale_type l)
boost::basic_regex::iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const_iterator                        iterator;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::locale_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename traits::locale_type          locale_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::mark_count	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL mark_count()const $/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::max_size	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL max_size()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::m_pimpl	/usr/include/boost/regex/v4/basic_regex.hpp	/^   shared_ptr<re_detail::basic_regex_implementation<charT, traits> > m_pimpl;$/;"	m	class:boost::basic_regex	access:private
boost::basic_regex::operator !=	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator != (const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
boost::basic_regex::operator <	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator<(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
boost::basic_regex::operator <=	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator<=(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
boost::basic_regex::operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const basic_regex& that)$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that)
boost::basic_regex::operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const charT* ptr)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* ptr)
boost::basic_regex::operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const std::basic_string<charT, ST, SA>& p)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT, ST, SA>& p)
boost::basic_regex::operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const std::basic_string<charT>& p)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT>& p)
boost::basic_regex::operator ==	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator==(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
boost::basic_regex::operator >	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator>(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
boost::basic_regex::operator >=	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator>=(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
boost::basic_regex::reference	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef charT&                                reference;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const charT* p, flag_type f = regex_constants::normal) $/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
boost::basic_regex::set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
boost::basic_regex::set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
boost::basic_regex::set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)
boost::basic_regex::size	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL size()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           size_type;   $/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::status	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int status()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::str	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::basic_string<charT> BOOST_REGEX_CALL str()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
boost::basic_regex::subexpression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::pair<const_iterator, const_iterator> BOOST_REGEX_CALL subexpression(std::size_t n)const$/;"	f	class:boost::basic_regex	access:public	signature:(std::size_t n) const
boost::basic_regex::swap	/usr/include/boost/regex/v4/basic_regex.hpp	/^   void BOOST_REGEX_CALL swap(basic_regex& that)throw()$/;"	f	class:boost::basic_regex	access:public	signature:(basic_regex& that)
boost::basic_regex::traits_size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           traits_size_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::traits_string_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename traits::string_type          traits_string_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::traits_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef traits                                traits_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::value_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef charT                                 value_type;$/;"	t	class:boost::basic_regex	access:public
boost::basic_regex::~basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   ~basic_regex(){}$/;"	f	class:boost::basic_regex	access:public	signature:()
boost::BitmaskConcept	/usr/include/boost/regex/concepts.hpp	/^struct BitmaskConcept$/;"	s	namespace:boost
boost::BitmaskConcept::constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::BitmaskConcept	access:public	signature:()
boost::BitmaskConcept::m_mask1	/usr/include/boost/regex/concepts.hpp	/^   Bitmask m_mask1, m_mask2, m_mask3;$/;"	m	struct:boost::BitmaskConcept	access:public
boost::BitmaskConcept::m_mask2	/usr/include/boost/regex/concepts.hpp	/^   Bitmask m_mask1, m_mask2, m_mask3;$/;"	m	struct:boost::BitmaskConcept	access:public
boost::BitmaskConcept::m_mask3	/usr/include/boost/regex/concepts.hpp	/^   Bitmask m_mask1, m_mask2, m_mask3;$/;"	m	struct:boost::BitmaskConcept	access:public
boost::bitmask_archetype	/usr/include/boost/regex/concepts.hpp	/^typedef std::bitset<512> bitmask_archetype;$/;"	t	namespace:boost
boost::BoostRegexConcept	/usr/include/boost/regex/concepts.hpp	/^struct BoostRegexConcept$/;"	s	namespace:boost
boost::BoostRegexConcept::BidiIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef bidirectional_iterator_archetype<value_type> BidiIterator;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::BoostRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BoostRegexConcept();$/;"	p	struct:boost::BoostRegexConcept	access:public	signature:()
boost::BoostRegexConcept::BoostRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BoostRegexConcept(const BoostRegexConcept&);$/;"	p	struct:boost::BoostRegexConcept	access:public	signature:(const BoostRegexConcept&)
boost::BoostRegexConcept::constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::BoostRegexConcept	access:public	signature:()
boost::BoostRegexConcept::const_iterator	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::const_iterator const_iterator;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::flag_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::flag_type flag_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::locale_type locale_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::match_results_default_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::match_results_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_char	/usr/include/boost/regex/concepts.hpp	/^   const value_type m_char;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_cresults	/usr/include/boost/regex/concepts.hpp	/^   const match_results_type m_cresults;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_in	/usr/include/boost/regex/concepts.hpp	/^   BidiIterator m_in;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_pointer	/usr/include/boost/regex/concepts.hpp	/^   pointer_type m_pointer;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_results	/usr/include/boost/regex/concepts.hpp	/^   match_results_type m_results;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_stream	/usr/include/boost/regex/concepts.hpp	/^   std::basic_ostream<value_type> m_stream;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_string	/usr/include/boost/regex/concepts.hpp	/^   string_type m_string;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::m_sub	/usr/include/boost/regex/concepts.hpp	/^   sub_match_type m_sub;$/;"	m	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::operator =	/usr/include/boost/regex/concepts.hpp	/^   BoostRegexConcept& operator=(const BoostRegexConcept&);$/;"	p	struct:boost::BoostRegexConcept	access:public	signature:(const BoostRegexConcept&)
boost::BoostRegexConcept::OutputIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef output_iterator_archetype<value_type> OutputIterator;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::pointer_type	/usr/include/boost/regex/concepts.hpp	/^   typedef const value_type* pointer_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::size_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::size_type size_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef std::basic_string<value_type> string_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::sub_match_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BoostRegexConcept::value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::value_type value_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
boost::BOOST_REGEX_DECL::boost::re_detail::perl_matcher	/usr/include/boost/regex/v4/instances.hpp	/^template class BOOST_REGEX_DECL ::boost::re_detail::perl_matcher<BOOST_REGEX_CHAR_T const *, match_results< const BOOST_REGEX_CHAR_T* >::allocator_type BOOST_REGEX_TRAITS_T >;$/;"	m	class:boost::BOOST_REGEX_DECL::boost::re_detail	typeref:class:boost::BOOST_REGEX_DECL::boost::re_detail::
boost::char_architype	/usr/include/boost/regex/concepts.hpp	/^struct char_architype$/;"	s	namespace:boost
boost::char_architype::char_architype	/usr/include/boost/regex/concepts.hpp	/^   char_architype();$/;"	p	struct:boost::char_architype	access:public	signature:()
boost::char_architype::char_architype	/usr/include/boost/regex/concepts.hpp	/^   char_architype(const char_architype&);$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&)
boost::char_architype::char_architype	/usr/include/boost/regex/concepts.hpp	/^   char_architype(unsigned long val);$/;"	p	struct:boost::char_architype	access:public	signature:(unsigned long val)
boost::char_architype::operator !=	/usr/include/boost/regex/concepts.hpp	/^   bool operator!=(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
boost::char_architype::operator <	/usr/include/boost/regex/concepts.hpp	/^   bool operator<(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
boost::char_architype::operator <=	/usr/include/boost/regex/concepts.hpp	/^   bool operator<=(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
boost::char_architype::operator =	/usr/include/boost/regex/concepts.hpp	/^   char_architype& operator=(const char_architype&);$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&)
boost::char_architype::operator ==	/usr/include/boost/regex/concepts.hpp	/^   bool operator==(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
boost::char_architype::operator >	/usr/include/boost/regex/concepts.hpp	/^   bool operator>(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
boost::char_architype::operator >=	/usr/include/boost/regex/concepts.hpp	/^   bool operator>=(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
boost::char_architype::operator long	/usr/include/boost/regex/concepts.hpp	/^   operator long()const;$/;"	p	struct:boost::char_architype	access:public	signature:() const
boost::chrono	/usr/include/boost/chrono/system_clocks.hpp	/^namespace chrono {$/;"	n	namespace:boost
boost::chrono::clock_string	/usr/include/boost/chrono/system_clocks.hpp	/^  struct clock_string<steady_clock, CharT>$/;"	s	namespace:boost::chrono
boost::chrono::clock_string	/usr/include/boost/chrono/system_clocks.hpp	/^  struct clock_string<system_clock, CharT>$/;"	s	namespace:boost::chrono
boost::chrono::clock_string::name	/usr/include/boost/chrono/system_clocks.hpp	/^    static std::basic_string<CharT> name()$/;"	f	struct:boost::chrono::clock_string	access:public	signature:()
boost::chrono::clock_string::since	/usr/include/boost/chrono/system_clocks.hpp	/^    static std::basic_string<CharT> since()$/;"	f	struct:boost::chrono::clock_string	access:public	signature:()
boost::chrono::high_resolution_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  typedef steady_clock high_resolution_clock;  \/\/ as permitted by [time.clock.hires]$/;"	t	namespace:boost::chrono
boost::chrono::high_resolution_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  typedef system_clock high_resolution_clock;  \/\/ as permitted by [time.clock.hires]$/;"	t	namespace:boost::chrono
boost::chrono::steady_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL steady_clock$/;"	c	namespace:boost::chrono
boost::chrono::steady_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL steady_clock;$/;"	m	namespace:boost::chrono	typeref:class:boost::chrono::BOOST_CHRONO_DECL
boost::chrono::steady_clock::BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now() BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::steady_clock	access:public
boost::chrono::steady_clock::duration	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef nanoseconds                          duration;$/;"	t	class:boost::chrono::steady_clock	access:public
boost::chrono::steady_clock::is_steady	/usr/include/boost/chrono/system_clocks.hpp	/^      BOOST_STATIC_CONSTEXPR bool is_steady =             true;$/;"	m	class:boost::chrono::steady_clock	access:public
boost::chrono::steady_clock::now	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now(system::error_code & ec);$/;"	p	class:boost::chrono::steady_clock	access:public	signature:(system::error_code & ec)
boost::chrono::steady_clock::period	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::period                     period;$/;"	t	class:boost::chrono::steady_clock	access:public
boost::chrono::steady_clock::rep	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::rep                        rep;$/;"	t	class:boost::chrono::steady_clock	access:public
boost::chrono::steady_clock::time_point	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef chrono::time_point<steady_clock>  time_point;$/;"	t	class:boost::chrono::steady_clock	access:public
boost::chrono::system_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL system_clock$/;"	c	namespace:boost::chrono
boost::chrono::system_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL system_clock;$/;"	m	namespace:boost::chrono	typeref:class:boost::chrono::BOOST_CHRONO_DECL
boost::chrono::system_clock::BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE std::time_t to_time_t(const time_point& t) BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::system_clock	access:public
boost::chrono::system_clock::BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  from_time_t(std::time_t t) BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::system_clock	access:public
boost::chrono::system_clock::BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now() BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::system_clock	access:public
boost::chrono::system_clock::duration	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef BOOST_SYSTEM_CLOCK_DURATION          duration;$/;"	t	class:boost::chrono::system_clock	access:public
boost::chrono::system_clock::is_steady	/usr/include/boost/chrono/system_clocks.hpp	/^      BOOST_STATIC_CONSTEXPR bool is_steady =             false;$/;"	m	class:boost::chrono::system_clock	access:public
boost::chrono::system_clock::now	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now(system::error_code & ec);$/;"	p	class:boost::chrono::system_clock	access:public	signature:(system::error_code & ec)
boost::chrono::system_clock::period	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::period                     period;$/;"	t	class:boost::chrono::system_clock	access:public
boost::chrono::system_clock::rep	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::rep                        rep;$/;"	t	class:boost::chrono::system_clock	access:public
boost::chrono::system_clock::time_point	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef chrono::time_point<system_clock>     time_point;$/;"	t	class:boost::chrono::system_clock	access:public
boost::cmatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<const char*> cmatch;$/;"	t	namespace:boost
boost::cpp_regex_traits	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class cpp_regex_traits$/;"	c	namespace:boost
boost::cpp_regex_traits::boost_extensions_tag	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   struct boost_extensions_tag{};$/;"	s	class:boost::cpp_regex_traits	access:public
boost::cpp_regex_traits::catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static std::string catalog_name(const std::string& name);$/;"	p	class:boost::cpp_regex_traits	access:public	signature:(const std::string& name)
boost::cpp_regex_traits::catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::string cpp_regex_traits<charT>::catalog_name(const std::string& name)$/;"	f	class:boost::cpp_regex_traits	signature:(const std::string& name)
boost::cpp_regex_traits::char_class_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef boost::uint_least32_t        char_class_type;$/;"	t	class:boost::cpp_regex_traits	access:public
boost::cpp_regex_traits::char_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef charT                        char_type;$/;"	t	class:boost::cpp_regex_traits	access:public
boost::cpp_regex_traits::cpp_regex_traits	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits()$/;"	f	class:boost::cpp_regex_traits	access:public	signature:()
boost::cpp_regex_traits::ctype_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::ctype<charT>            ctype_type;$/;"	t	class:boost::cpp_regex_traits	access:private
boost::cpp_regex_traits::error_string	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(regex_constants::error_type n) const
boost::cpp_regex_traits::escape_syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
boost::cpp_regex_traits::getloc	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   locale_type getloc()const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:() const
boost::cpp_regex_traits::get_catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static std::string get_catalog_name();$/;"	p	class:boost::cpp_regex_traits	access:public	signature:()
boost::cpp_regex_traits::get_catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::string cpp_regex_traits<charT>::get_catalog_name()$/;"	f	class:boost::cpp_regex_traits	signature:()
boost::cpp_regex_traits::get_catalog_name_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static std::string& get_catalog_name_inst();$/;"	p	class:boost::cpp_regex_traits	access:private	signature:()
boost::cpp_regex_traits::get_catalog_name_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::string& cpp_regex_traits<charT>::get_catalog_name_inst()$/;"	f	class:boost::cpp_regex_traits	signature:()
boost::cpp_regex_traits::get_mutex_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static static_mutex& get_mutex_inst();$/;"	p	class:boost::cpp_regex_traits	access:private	signature:()
boost::cpp_regex_traits::get_mutex_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^static_mutex& cpp_regex_traits<charT>::get_mutex_inst()$/;"	f	class:boost::cpp_regex_traits	signature:()
boost::cpp_regex_traits::imbue	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   locale_type imbue(locale_type l)$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(locale_type l)
boost::cpp_regex_traits::isctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool isctype(charT c, char_class_type f) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c, char_class_type f) const
boost::cpp_regex_traits::length	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static size_type length(const char_type* p)$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const char_type* p)
boost::cpp_regex_traits::locale_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::locale                  locale_type;$/;"	t	class:boost::cpp_regex_traits	access:public
boost::cpp_regex_traits::lookup_classname	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::cpp_regex_traits::lookup_collatename	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::cpp_regex_traits::m_pimpl	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   boost::shared_ptr<const re_detail::cpp_regex_traits_implementation<charT> > m_pimpl;$/;"	m	class:boost::cpp_regex_traits	access:private
boost::cpp_regex_traits::size_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::size_t                  size_type;$/;"	t	class:boost::cpp_regex_traits	access:public
boost::cpp_regex_traits::string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::basic_string<char_type> string_type;$/;"	t	class:boost::cpp_regex_traits	access:public
boost::cpp_regex_traits::syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
boost::cpp_regex_traits::toi	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   int toi(const charT*& p1, const charT* p2, int radix)const;$/;"	p	class:boost::cpp_regex_traits	access:public	signature:(const charT*& p1, const charT* p2, int radix) const
boost::cpp_regex_traits::toi	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^int cpp_regex_traits<charT>::toi(const charT*& first, const charT* last, int radix)const$/;"	f	class:boost::cpp_regex_traits	signature:(const charT*& first, const charT* last, int radix) const
boost::cpp_regex_traits::tolower	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT tolower(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
boost::cpp_regex_traits::toupper	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT toupper(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
boost::cpp_regex_traits::transform	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::cpp_regex_traits::transform_primary	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::cpp_regex_traits::translate	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT translate(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
boost::cpp_regex_traits::translate	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT translate(charT c, bool icase) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c, bool icase) const
boost::cpp_regex_traits::translate_nocase	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT translate_nocase(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
boost::cpp_regex_traits::value	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   int value(charT c, int radix)const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c, int radix) const
boost::cregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<const char*> cregex_iterator;$/;"	t	namespace:boost
boost::cregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<const char*> cregex_token_iterator;$/;"	t	namespace:boost
boost::csub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<const char*> csub_match;$/;"	t	namespace:boost
boost::c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^struct BOOST_REGEX_DECL c_regex_traits<char>$/;"	s	namespace:boost
boost::c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^struct BOOST_REGEX_DECL c_regex_traits<unsigned short>$/;"	s	namespace:boost
boost::c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^struct BOOST_REGEX_DECL c_regex_traits<wchar_t>$/;"	s	namespace:boost
boost::c_regex_traits::char_class_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef boost::uint32_t char_class_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::char_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef char char_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::char_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef unsigned short char_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::char_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef wchar_t char_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   c_regex_traits(){}$/;"	f	struct:boost::c_regex_traits	access:public	signature:()
boost::c_regex_traits::c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   c_regex_traits(const c_regex_traits&);$/;"	p	struct:boost::c_regex_traits	access:private	signature:(const c_regex_traits&)
boost::c_regex_traits::getloc	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   locale_type getloc()const$/;"	f	struct:boost::c_regex_traits	access:public	signature:() const
boost::c_regex_traits::imbue	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   locale_type imbue(locale_type l)$/;"	f	struct:boost::c_regex_traits	access:public	signature:(locale_type l)
boost::c_regex_traits::isctype	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static bool BOOST_REGEX_CALL isctype(char, char_class_type);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(char, char_class_type)
boost::c_regex_traits::isctype	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static bool BOOST_REGEX_CALL isctype(unsigned short, char_class_type);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(unsigned short, char_class_type)
boost::c_regex_traits::isctype	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static bool BOOST_REGEX_CALL isctype(wchar_t, char_class_type);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(wchar_t, char_class_type)
boost::c_regex_traits::length	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static size_type length(const char_type* p) $/;"	f	struct:boost::c_regex_traits	access:public	signature:(const char_type* p)
boost::c_regex_traits::locale_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   struct locale_type{};$/;"	s	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::lookup_classname	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static char_class_type BOOST_REGEX_CALL lookup_classname(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
boost::c_regex_traits::lookup_classname	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static char_class_type BOOST_REGEX_CALL lookup_classname(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
boost::c_regex_traits::lookup_classname	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static char_class_type BOOST_REGEX_CALL lookup_classname(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
boost::c_regex_traits::lookup_collatename	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL lookup_collatename(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
boost::c_regex_traits::lookup_collatename	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL lookup_collatename(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
boost::c_regex_traits::lookup_collatename	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL lookup_collatename(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
boost::c_regex_traits::operator =	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   c_regex_traits& operator=(const c_regex_traits&);$/;"	p	struct:boost::c_regex_traits	access:private	signature:(const c_regex_traits&)
boost::c_regex_traits::size_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::size_t size_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::string_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::basic_string<unsigned short> string_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::string_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::string string_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::string_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::wstring string_type;$/;"	t	struct:boost::c_regex_traits	access:public
boost::c_regex_traits::transform	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
boost::c_regex_traits::transform	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
boost::c_regex_traits::transform	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
boost::c_regex_traits::transform_primary	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform_primary(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
boost::c_regex_traits::transform_primary	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform_primary(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
boost::c_regex_traits::transform_primary	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform_primary(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
boost::c_regex_traits::translate	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   char translate(char c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(char c) const
boost::c_regex_traits::translate	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   unsigned short translate(unsigned short c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(unsigned short c) const
boost::c_regex_traits::translate	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   wchar_t translate(wchar_t c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(wchar_t c) const
boost::c_regex_traits::translate_nocase	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   char translate_nocase(char c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(char c) const
boost::c_regex_traits::translate_nocase	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   unsigned short translate_nocase(unsigned short c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(unsigned short c) const
boost::c_regex_traits::translate_nocase	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   wchar_t translate_nocase(wchar_t c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(wchar_t c) const
boost::c_regex_traits::value	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static int BOOST_REGEX_CALL value(char, int);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(char, int)
boost::c_regex_traits::value	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static int BOOST_REGEX_CALL value(unsigned short, int);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(unsigned short, int)
boost::c_regex_traits::value	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static int BOOST_REGEX_CALL value(wchar_t, int);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(wchar_t, int)
boost::date_time	/usr/include/boost/date_time/time_system_counted.hpp	/^namespace date_time {$/;"	n	namespace:boost
boost::date_time	/usr/include/boost/date_time/time_system_split.hpp	/^namespace date_time {$/;"	n	namespace:boost
boost::date_time::counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^  struct counted_time_rep$/;"	s	namespace:boost::date_time
boost::date_time::counted_time_rep::calendar_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename date_type::calendar_type calendar_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_rep::counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    counted_time_rep(const date_type& d, const time_duration_type& time_of_day) $/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:(const date_type& d, const time_duration_type& time_of_day)
boost::date_time::counted_time_rep::counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    explicit counted_time_rep(impl_type count) :$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:(impl_type count)
boost::date_time::counted_time_rep::counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    explicit counted_time_rep(int_type count) :$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:(int_type count)
boost::date_time::counted_time_rep::date	/usr/include/boost/date_time/time_system_counted.hpp	/^    date_type date() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::date_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename date_type::duration_type date_duration_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_rep::date_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::date_type  date_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_rep::day_count	/usr/include/boost/date_time/time_system_counted.hpp	/^    unsigned long day_count() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::frac_sec_per_day	/usr/include/boost/date_time/time_system_counted.hpp	/^    static int_type frac_sec_per_day()$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:()
boost::date_time::counted_time_rep::get_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    impl_type get_rep()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::impl_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::impl_type  impl_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_rep::int_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::int_type   int_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_rep::is_neg_infinity	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_neg_infinity()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::is_not_a_date_time	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_not_a_date_time()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::is_pos_infinity	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_pos_infinity()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::is_special	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_special()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::resolution_traits	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::resolution_traits   resolution_traits;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_rep::time_count	/usr/include/boost/date_time/time_system_counted.hpp	/^    int_type time_count() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::time_count_	/usr/include/boost/date_time/time_system_counted.hpp	/^    impl_type time_count_;$/;"	m	struct:boost::date_time::counted_time_rep	access:private
boost::date_time::counted_time_rep::time_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::time_duration_type time_duration_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_rep::tod	/usr/include/boost/date_time/time_system_counted.hpp	/^    int_type tod() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
boost::date_time::counted_time_rep::ymd_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename date_type::ymd_type ymd_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
boost::date_time::counted_time_system	/usr/include/boost/date_time/time_system_counted.hpp	/^  class counted_time_system$/;"	c	namespace:boost::date_time
boost::date_time::counted_time_system::add_days	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type add_days(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
boost::date_time::counted_time_system::add_time_duration	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type add_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, time_duration_type td)
boost::date_time::counted_time_system::date_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::date_duration_type date_duration_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
boost::date_time::counted_time_system::date_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::date_type date_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
boost::date_time::counted_time_system::fractional_seconds_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_duration_type::fractional_seconds_type fractional_seconds_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
boost::date_time::counted_time_system::get_date	/usr/include/boost/date_time/time_system_counted.hpp	/^    static date_type get_date(const time_rep_type& val)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& val)
boost::date_time::counted_time_system::get_time_of_day	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_duration_type get_time_of_day(const time_rep_type& val)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& val)
boost::date_time::counted_time_system::get_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type get_time_rep(const date_type& day,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const date_type& day, const time_duration_type& tod, date_time::dst_flags dst=not_dst)
boost::date_time::counted_time_system::get_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type get_time_rep(special_values sv)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(special_values sv)
boost::date_time::counted_time_system::impl_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::impl_type impl_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
boost::date_time::counted_time_system::is_equal	/usr/include/boost/date_time/time_system_counted.hpp	/^    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
boost::date_time::counted_time_system::is_less	/usr/include/boost/date_time/time_system_counted.hpp	/^    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
boost::date_time::counted_time_system::subtract_days	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type subtract_days(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
boost::date_time::counted_time_system::subtract_times	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_duration_type subtract_times(const time_rep_type& lhs,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
boost::date_time::counted_time_system::subtract_time_duration	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type subtract_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, const time_duration_type& td)
boost::date_time::counted_time_system::time_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::time_duration_type time_duration_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
boost::date_time::counted_time_system::time_rep_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef time_rep time_rep_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
boost::date_time::counted_time_system::unused_var	/usr/include/boost/date_time/time_system_counted.hpp	/^    template<class T> static void unused_var(const T&) {}$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const T&)
boost::date_time::counted_time_system::zone_name	/usr/include/boost/date_time/time_system_counted.hpp	/^    static std::string zone_name(const time_rep_type&)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type&)
boost::date_time::split_timedate_system	/usr/include/boost/date_time/time_system_split.hpp	/^  class split_timedate_system$/;"	c	namespace:boost::date_time
boost::date_time::split_timedate_system::add_days	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type add_days(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
boost::date_time::split_timedate_system::add_time_duration	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type add_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, time_duration_type td)
boost::date_time::split_timedate_system::BOOST_STATIC_CONSTANT	/usr/include/boost/date_time/time_system_split.hpp	/^     BOOST_STATIC_CONSTANT(int_type, ticks_per_day = INT64_C(86400) * config::tick_per_second);$/;"	p	class:boost::date_time::split_timedate_system	access:private	signature:(int_type, ticks_per_day = INT64_C(86400) * config::tick_per_second)
boost::date_time::split_timedate_system::date_duration_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::date_duration_type date_duration_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::date_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::date_type     date_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::get_date	/usr/include/boost/date_time/time_system_split.hpp	/^    static date_type get_date(const time_rep_type& val)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& val)
boost::date_time::split_timedate_system::get_time_of_day	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_duration_type get_time_of_day(const time_rep_type& val)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& val)
boost::date_time::split_timedate_system::get_time_rep	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type get_time_rep(const date_type& day,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const date_type& day, const time_duration_type& tod, date_time::dst_flags = not_dst)
boost::date_time::split_timedate_system::get_time_rep	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type get_time_rep(special_values sv)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(special_values sv)
boost::date_time::split_timedate_system::int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::int_type int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::is_equal	/usr/include/boost/date_time/time_system_split.hpp	/^    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
boost::date_time::split_timedate_system::is_less	/usr/include/boost/date_time/time_system_split.hpp	/^    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
boost::date_time::split_timedate_system::resolution_traits	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::resolution_traits   resolution_traits;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::subtract_days	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type subtract_days(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
boost::date_time::split_timedate_system::subtract_times	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_duration_type subtract_times(const time_rep_type& lhs,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
boost::date_time::split_timedate_system::subtract_time_duration	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type subtract_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, const time_duration_type& td)
boost::date_time::split_timedate_system::time_duration_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::time_duration_type time_duration_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::time_rep_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::time_rep_type time_rep_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::wrap_int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef date_time::wrapping_int< split_timedate_system::int_type, split_timedate_system::ticks_per_day> wrap_int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::wrap_int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef date_time::wrapping_int<int_type, INT64_C(86400) * ticks_per_second > wrap_int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::wrap_int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef date_time::wrapping_int<int_type, ticks_per_day> wrap_int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
boost::date_time::split_timedate_system::zone_name	/usr/include/boost/date_time/time_system_split.hpp	/^    static std::string zone_name(const time_rep_type&)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type&)
boost::deprecated	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^namespace deprecated{$/;"	n	namespace:boost
boost::deprecated::char_regex_traits_i	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^class char_regex_traits_i : public regex_traits<charT> {};$/;"	c	namespace:boost::deprecated	inherits:regex_traits
boost::deprecated::char_regex_traits_i	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^class char_regex_traits_i<char> : public regex_traits<char>$/;"	c	namespace:boost::deprecated	inherits:regex_traits
boost::deprecated::char_regex_traits_i	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^class char_regex_traits_i<wchar_t> : public regex_traits<wchar_t>$/;"	c	namespace:boost::deprecated	inherits:regex_traits
boost::deprecated::char_regex_traits_i::base_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef regex_traits<char> base_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
boost::deprecated::char_regex_traits_i::base_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef regex_traits<wchar_t> base_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
boost::deprecated::char_regex_traits_i::char_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef char char_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
boost::deprecated::char_regex_traits_i::char_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef wchar_t char_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
boost::deprecated::char_regex_traits_i::size_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef unsigned int size_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
boost::deprecated::char_regex_traits_i::uchar_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef unsigned char uchar_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
boost::deprecated::char_regex_traits_i::uchar_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef unsigned short uchar_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
boost::detail	/usr/include/boost/detail/win/system.hpp	/^namespace detail {$/;"	n	namespace:boost
boost::detail	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^namespace detail{$/;"	n	namespace:boost
boost::detail	/usr/include/boost/regex/v4/iterator_category.hpp	/^namespace detail{$/;"	n	namespace:boost
boost::detail	/usr/include/boost/system/error_code.hpp	/^  namespace detail { inline system::error_code * throws() { return 0; } }$/;"	n	namespace:boost
boost::detail::high_surrogate_base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^static const ::boost::uint16_t high_surrogate_base = 0xD7C0u;$/;"	m	namespace:boost::detail
boost::detail::invalid_utf32_code_point	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline void invalid_utf32_code_point(::boost::uint32_t val)$/;"	f	namespace:boost::detail	signature:(::boost::uint32_t val)
boost::detail::is_high_surrogate	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline bool is_high_surrogate(::boost::uint16_t v)$/;"	f	namespace:boost::detail	signature:(::boost::uint16_t v)
boost::detail::is_low_surrogate	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline bool is_low_surrogate(::boost::uint16_t v)$/;"	f	namespace:boost::detail	signature:(::boost::uint16_t v)
boost::detail::is_random_imp	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_imp$/;"	s	namespace:boost::detail
boost::detail::is_random_imp::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/iterator_category.hpp	/^   BOOST_STATIC_CONSTANT(bool, value = (::boost::is_convertible<cat*, std::random_access_iterator_tag*>::value));$/;"	p	struct:boost::detail::is_random_imp	access:public	signature:(bool, value = (::boost::is_convertible<cat*, std::random_access_iterator_tag*>::value))
boost::detail::is_random_imp::cat	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef typename std::iterator_traits<I>::iterator_category cat;$/;"	t	struct:boost::detail::is_random_imp	access:private
boost::detail::is_random_imp_selector	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_imp_selector$/;"	s	namespace:boost::detail
boost::detail::is_random_imp_selector	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_imp_selector<true>$/;"	s	namespace:boost::detail
boost::detail::is_random_imp_selector::rebind	/usr/include/boost/regex/v4/iterator_category.hpp	/^   struct rebind$/;"	s	struct:boost::detail::is_random_imp_selector	access:public
boost::detail::is_random_imp_selector::rebind::type	/usr/include/boost/regex/v4/iterator_category.hpp	/^      typedef is_random_imp<I> type;$/;"	t	struct:boost::detail::is_random_imp_selector::rebind	access:public
boost::detail::is_random_imp_selector::rebind::type	/usr/include/boost/regex/v4/iterator_category.hpp	/^      typedef is_random_pointer_imp<I> type;$/;"	t	struct:boost::detail::is_random_imp_selector::rebind	access:public
boost::detail::is_random_pointer_imp	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_pointer_imp$/;"	s	namespace:boost::detail
boost::detail::is_random_pointer_imp::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/iterator_category.hpp	/^   BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::detail::is_random_pointer_imp	access:public	signature:(bool, value = true)
boost::detail::is_surrogate	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline bool is_surrogate(T v)$/;"	f	namespace:boost::detail	signature:(T v)
boost::detail::low_surrogate_base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^static const ::boost::uint16_t low_surrogate_base = 0xDC00u;$/;"	m	namespace:boost::detail
boost::detail::ten_bit_mask	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^static const ::boost::uint32_t ten_bit_mask = 0x3FFu;$/;"	m	namespace:boost::detail
boost::detail::throws	/usr/include/boost/system/error_code.hpp	/^  namespace detail { inline system::error_code * throws() { return 0; } }$/;"	f	namespace:boost::detail	signature:()
boost::detail::utf8_byte_count	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline unsigned utf8_byte_count(boost::uint8_t c)$/;"	f	namespace:boost::detail	signature:(boost::uint8_t c)
boost::detail::utf8_trailing_byte_count	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline unsigned utf8_trailing_byte_count(boost::uint8_t c)$/;"	f	namespace:boost::detail	signature:(boost::uint8_t c)
boost::detail::win32	/usr/include/boost/detail/win/system.hpp	/^namespace win32 {$/;"	n	namespace:boost::detail
boost::detail::win32::SYSTEM_INFO_	/usr/include/boost/detail/win/system.hpp	/^    typedef ::SYSTEM_INFO SYSTEM_INFO_;$/;"	t	namespace:boost::detail::win32
boost::filesystem	/usr/include/boost/filesystem/convenience.hpp	/^  namespace filesystem$/;"	n	namespace:boost
boost::filesystem	/usr/include/boost/filesystem/fstream.hpp	/^namespace filesystem$/;"	n	namespace:boost
boost::filesystem	/usr/include/boost/filesystem/operations.hpp	/^  namespace filesystem$/;"	n	namespace:boost
boost::filesystem	/usr/include/boost/filesystem/path.hpp	/^namespace filesystem$/;"	n	namespace:boost
boost::filesystem	/usr/include/boost/filesystem/path_traits.hpp	/^namespace boost { namespace filesystem {$/;"	n	namespace:boost
boost::filesystem::absolute	/usr/include/boost/filesystem/operations.hpp	/^  path absolute(const path& p, const path& base=current_path());$/;"	p	namespace:boost::filesystem	signature:(const path& p, const path& base=current_path())
boost::filesystem::add_perms	/usr/include/boost/filesystem/operations.hpp	/^    add_perms = 0x1000,     \/\/ adds the given permission bits to the current bits$/;"	e	enum:boost::filesystem::perms
boost::filesystem::all_all	/usr/include/boost/filesystem/operations.hpp	/^    all_all = owner_all|group_all|others_all,  \/\/ 0777$/;"	e	enum:boost::filesystem::perms
boost::filesystem::basename	/usr/include/boost/filesystem/convenience.hpp	/^    inline std::string basename(const path & p)$/;"	f	namespace:boost::filesystem	signature:(const path & p)
boost::filesystem::basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_filebuf : public std::basic_filebuf<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_filebuf
boost::filesystem::basic_filebuf::basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^    basic_filebuf() {}$/;"	f	class:boost::filesystem::basic_filebuf	access:public	signature:()
boost::filesystem::basic_filebuf::basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^    basic_filebuf(const basic_filebuf&);$/;"	p	class:boost::filesystem::basic_filebuf	access:private	signature:(const basic_filebuf&)
boost::filesystem::basic_filebuf::open	/usr/include/boost/filesystem/fstream.hpp	/^      open(const path& p, std::ios_base::openmode mode) $/;"	f	class:boost::filesystem::basic_filebuf	access:public	signature:(const path& p, std::ios_base::openmode mode)
boost::filesystem::basic_filebuf::operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_filebuf& operator=(const basic_filebuf&);$/;"	p	class:boost::filesystem::basic_filebuf	access:private	signature:(const basic_filebuf&)
boost::filesystem::basic_filebuf::~basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_filebuf() {}$/;"	f	class:boost::filesystem::basic_filebuf	access:public	signature:()
boost::filesystem::basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_fstream : public std::basic_fstream<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_fstream
boost::filesystem::basic_fstream::basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_fstream() {}$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:()
boost::filesystem::basic_fstream::basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_fstream(const basic_fstream&);$/;"	p	class:boost::filesystem::basic_fstream	access:private	signature:(const basic_fstream&)
boost::filesystem::basic_fstream::basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_fstream(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
boost::filesystem::basic_fstream::basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    explicit basic_fstream(const path& p)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p)
boost::filesystem::basic_fstream::open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p)
boost::filesystem::basic_fstream::open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
boost::filesystem::basic_fstream::operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_fstream & operator=(const basic_fstream&);$/;"	p	class:boost::filesystem::basic_fstream	access:private	signature:(const basic_fstream&)
boost::filesystem::basic_fstream::~basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_fstream() {}$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:()
boost::filesystem::basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_ifstream : public std::basic_ifstream<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_ifstream
boost::filesystem::basic_ifstream::basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ifstream() {}$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:()
boost::filesystem::basic_ifstream::basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ifstream(const basic_ifstream&);$/;"	p	class:boost::filesystem::basic_ifstream	access:private	signature:(const basic_ifstream&)
boost::filesystem::basic_ifstream::basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ifstream(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
boost::filesystem::basic_ifstream::basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    explicit basic_ifstream(const path& p)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p)
boost::filesystem::basic_ifstream::open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p)
boost::filesystem::basic_ifstream::open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
boost::filesystem::basic_ifstream::operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_ifstream& operator=(const basic_ifstream&);$/;"	p	class:boost::filesystem::basic_ifstream	access:private	signature:(const basic_ifstream&)
boost::filesystem::basic_ifstream::~basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_ifstream() {}$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:()
boost::filesystem::basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^  class basic_ofstream : public std::basic_ofstream<charT,traits>$/;"	c	namespace:boost::filesystem	inherits:std::basic_ofstream
boost::filesystem::basic_ofstream::basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ofstream() {}$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:()
boost::filesystem::basic_ofstream::basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ofstream(const basic_ofstream&);$/;"	p	class:boost::filesystem::basic_ofstream	access:private	signature:(const basic_ofstream&)
boost::filesystem::basic_ofstream::basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    basic_ofstream(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
boost::filesystem::basic_ofstream::basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    explicit basic_ofstream(const path& p)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p)
boost::filesystem::basic_ofstream::open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p)
boost::filesystem::basic_ofstream::open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
boost::filesystem::basic_ofstream::operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_ofstream& operator=(const basic_ofstream&);$/;"	p	class:boost::filesystem::basic_ofstream	access:private	signature:(const basic_ofstream&)
boost::filesystem::basic_ofstream::~basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_ofstream() {}$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:()
boost::filesystem::block_file	/usr/include/boost/filesystem/operations.hpp	/^    block_file,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::BOOST_SCOPED_ENUM_START	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_SCOPED_ENUM_START(copy_option)$/;"	f	namespace:boost::filesystem	signature:(copy_option)
boost::filesystem::BOOST_SCOPED_ENUM_START	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_SCOPED_ENUM_START(symlink_option)$/;"	f	namespace:boost::filesystem	signature:(symlink_option)
boost::filesystem::canonical	/usr/include/boost/filesystem/operations.hpp	/^  path canonical(const path& p, const path& base, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const path& base, system::error_code& ec)
boost::filesystem::canonical	/usr/include/boost/filesystem/operations.hpp	/^  path canonical(const path& p, const path& base=current_path())$/;"	f	namespace:boost::filesystem	signature:(const path& p, const path& base=current_path())
boost::filesystem::canonical	/usr/include/boost/filesystem/operations.hpp	/^  path canonical(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::change_extension	/usr/include/boost/filesystem/convenience.hpp	/^    inline path change_extension( const path & p, const path & new_extension )$/;"	f	namespace:boost::filesystem	signature:( const path & p, const path & new_extension )
boost::filesystem::character_file	/usr/include/boost/filesystem/operations.hpp	/^    character_file,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::codecvt_error_category	/usr/include/boost/filesystem/path_traits.hpp	/^  BOOST_FILESYSTEM_DECL const system::error_category& codecvt_error_category();$/;"	p	namespace:boost::filesystem	signature:()
boost::filesystem::complete	/usr/include/boost/filesystem/operations.hpp	/^  path complete(const path& p)$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::complete	/usr/include/boost/filesystem/operations.hpp	/^  path complete(const path& p, const path& base)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const path& base)
boost::filesystem::copy	/usr/include/boost/filesystem/operations.hpp	/^  void copy(const path& from, const path& to) {detail::copy(from, to);}$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to)
boost::filesystem::copy	/usr/include/boost/filesystem/operations.hpp	/^  void copy(const path& from, const path& to, system::error_code& ec) $/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, system::error_code& ec)
boost::filesystem::copy_directory	/usr/include/boost/filesystem/operations.hpp	/^  void copy_directory(const path& from, const path& to)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to)
boost::filesystem::copy_directory	/usr/include/boost/filesystem/operations.hpp	/^  void copy_directory(const path& from, const path& to, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, system::error_code& ec)
boost::filesystem::copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to)
boost::filesystem::copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to,   \/\/ See ticket #2925$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, BOOST_SCOPED_ENUM(copy_option) option)
boost::filesystem::copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to,   \/\/ See ticket #2925$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, BOOST_SCOPED_ENUM(copy_option) option, system::error_code& ec)
boost::filesystem::copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, system::error_code& ec)
boost::filesystem::copy_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void copy_symlink(const path& existing_symlink, const path& new_symlink) {detail::copy_symlink(existing_symlink, new_symlink);}$/;"	f	namespace:boost::filesystem	signature:(const path& existing_symlink, const path& new_symlink)
boost::filesystem::copy_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void copy_symlink(const path& existing_symlink, const path& new_symlink, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& existing_symlink, const path& new_symlink, system::error_code& ec)
boost::filesystem::create_directories	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directories(const path& p) {return detail::create_directories(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::create_directories	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directories(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::create_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directory(const path& p) {return detail::create_directory(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::create_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directory(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::create_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_directory_symlink(const path& to, const path& from)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& from)
boost::filesystem::create_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_directory_symlink(const path& to, const path& from, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& from, system::error_code& ec)
boost::filesystem::create_hard_link	/usr/include/boost/filesystem/operations.hpp	/^  void create_hard_link(const path& to, const path& new_hard_link) {detail::create_hard_link(to, new_hard_link);}$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_hard_link)
boost::filesystem::create_hard_link	/usr/include/boost/filesystem/operations.hpp	/^  void create_hard_link(const path& to, const path& new_hard_link, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_hard_link, system::error_code& ec)
boost::filesystem::create_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_symlink(const path& to, const path& new_symlink) {detail::create_symlink(to, new_symlink);}$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_symlink)
boost::filesystem::create_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_symlink(const path& to, const path& new_symlink, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_symlink, system::error_code& ec)
boost::filesystem::current_path	/usr/include/boost/filesystem/operations.hpp	/^  path current_path()                  {return detail::current_path();}$/;"	f	namespace:boost::filesystem	signature:()
boost::filesystem::current_path	/usr/include/boost/filesystem/operations.hpp	/^  path current_path();  \/\/ fwd declaration$/;"	p	namespace:boost::filesystem	signature:()
boost::filesystem::current_path	/usr/include/boost/filesystem/operations.hpp	/^  path current_path(system::error_code& ec) {return detail::current_path(&ec);}$/;"	f	namespace:boost::filesystem	signature:(system::error_code& ec)
boost::filesystem::current_path	/usr/include/boost/filesystem/operations.hpp	/^  void current_path(const path& p)     {detail::current_path(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::current_path	/usr/include/boost/filesystem/operations.hpp	/^  void current_path(const path& p, system::error_code& ec) {detail::current_path(p, &ec);}$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::detail	/usr/include/boost/filesystem/operations.hpp	/^  namespace detail$/;"	n	namespace:boost::filesystem
boost::filesystem::detail	/usr/include/boost/filesystem/operations.hpp	/^namespace detail$/;"	n	namespace:boost::filesystem
boost::filesystem::detail	/usr/include/boost/filesystem/path.hpp	/^  namespace detail$/;"	n	namespace:boost::filesystem
boost::filesystem::detail::canonical	/usr/include/boost/filesystem/operations.hpp	/^    path canonical(const path& p, const path& base, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, const path& base, system::error_code* ec=0)
boost::filesystem::detail::copy	/usr/include/boost/filesystem/operations.hpp	/^    void copy(const path& from, const path& to, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& from, const path& to, system::error_code* ec=0)
boost::filesystem::detail::copy_directory	/usr/include/boost/filesystem/operations.hpp	/^    void copy_directory(const path& from, const path& to, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& from, const path& to, system::error_code* ec=0)
boost::filesystem::detail::copy_file	/usr/include/boost/filesystem/operations.hpp	/^    void copy_file(const path& from, const path& to,$/;"	p	namespace:boost::filesystem::detail	signature:(const path& from, const path& to, BOOST_SCOPED_ENUM(copy_option) option, system::error_code* ec=0)
boost::filesystem::detail::copy_symlink	/usr/include/boost/filesystem/operations.hpp	/^    void copy_symlink(const path& existing_symlink, const path& new_symlink, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& existing_symlink, const path& new_symlink, system::error_code* ec=0)
boost::filesystem::detail::create_directories	/usr/include/boost/filesystem/operations.hpp	/^    bool create_directories(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::create_directory	/usr/include/boost/filesystem/operations.hpp	/^    bool create_directory(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::create_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^    void create_directory_symlink(const path& to, const path& from,$/;"	p	namespace:boost::filesystem::detail	signature:(const path& to, const path& from, system::error_code* ec=0)
boost::filesystem::detail::create_hard_link	/usr/include/boost/filesystem/operations.hpp	/^    void create_hard_link(const path& to, const path& from, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& to, const path& from, system::error_code* ec=0)
boost::filesystem::detail::create_symlink	/usr/include/boost/filesystem/operations.hpp	/^    void create_symlink(const path& to, const path& from, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& to, const path& from, system::error_code* ec=0)
boost::filesystem::detail::current_path	/usr/include/boost/filesystem/operations.hpp	/^    path current_path(system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(system::error_code* ec=0)
boost::filesystem::detail::current_path	/usr/include/boost/filesystem/operations.hpp	/^    void current_path(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::directory_iterator_construct	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_FILESYSTEM_DECL void directory_iterator_construct(directory_iterator& it,$/;"	p	namespace:boost::filesystem::detail	signature:(directory_iterator& it, const path& p, system::error_code* ec)
boost::filesystem::detail::directory_iterator_increment	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_FILESYSTEM_DECL void directory_iterator_increment(directory_iterator& it,$/;"	p	namespace:boost::filesystem::detail	signature:(directory_iterator& it, system::error_code* ec)
boost::filesystem::detail::dir_itr_close	/usr/include/boost/filesystem/operations.hpp	/^    system::error_code dir_itr_close(\/\/ never throws()$/;"	p	namespace:boost::filesystem::detail	signature:( void *& handle , void *& buffer )
boost::filesystem::detail::dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^  struct dir_itr_imp$/;"	s	namespace:boost::filesystem::detail
boost::filesystem::detail::dir_itr_imp::buffer	/usr/include/boost/filesystem/operations.hpp	/^    void*            buffer;  \/\/ see dir_itr_increment implementation$/;"	m	struct:boost::filesystem::detail::dir_itr_imp	access:public
boost::filesystem::detail::dir_itr_imp::dir_entry	/usr/include/boost/filesystem/operations.hpp	/^    directory_entry  dir_entry;$/;"	m	struct:boost::filesystem::detail::dir_itr_imp	access:public
boost::filesystem::detail::dir_itr_imp::dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^    dir_itr_imp() : handle(0)$/;"	f	struct:boost::filesystem::detail::dir_itr_imp	access:public	signature:()
boost::filesystem::detail::dir_itr_imp::handle	/usr/include/boost/filesystem/operations.hpp	/^    void*            handle;$/;"	m	struct:boost::filesystem::detail::dir_itr_imp	access:public
boost::filesystem::detail::dir_itr_imp::~dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^    ~dir_itr_imp() \/\/ never throws$/;"	f	struct:boost::filesystem::detail::dir_itr_imp	access:public	signature:()
boost::filesystem::detail::equivalent	/usr/include/boost/filesystem/operations.hpp	/^    bool equivalent(const path& p1, const path& p2, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p1, const path& p2, system::error_code* ec=0)
boost::filesystem::detail::file_size	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t file_size(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::hard_link_count	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t hard_link_count(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::initial_path	/usr/include/boost/filesystem/operations.hpp	/^    path initial_path(system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(system::error_code* ec=0)
boost::filesystem::detail::is_empty	/usr/include/boost/filesystem/operations.hpp	/^    bool is_empty(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::last_write_time	/usr/include/boost/filesystem/operations.hpp	/^    std::time_t last_write_time(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::last_write_time	/usr/include/boost/filesystem/operations.hpp	/^    void last_write_time(const path& p, const std::time_t new_time,$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, const std::time_t new_time, system::error_code* ec=0)
boost::filesystem::detail::lex_compare	/usr/include/boost/filesystem/path.hpp	/^      int lex_compare(path::iterator first1, path::iterator last1,$/;"	p	namespace:boost::filesystem::detail	signature:(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2)
boost::filesystem::detail::permissions	/usr/include/boost/filesystem/operations.hpp	/^    void permissions(const path& p, perms prms, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, perms prms, system::error_code* ec=0)
boost::filesystem::detail::possible_large_file_size_support	/usr/include/boost/filesystem/operations.hpp	/^    BOOST_FILESYSTEM_DECL bool possible_large_file_size_support();$/;"	p	namespace:boost::filesystem::detail	signature:()
boost::filesystem::detail::read_symlink	/usr/include/boost/filesystem/operations.hpp	/^    path read_symlink(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::recur_dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^    struct recur_dir_itr_imp$/;"	s	namespace:boost::filesystem::detail
boost::filesystem::detail::recur_dir_itr_imp::element_type	/usr/include/boost/filesystem/operations.hpp	/^      typedef directory_iterator element_type;$/;"	t	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
boost::filesystem::detail::recur_dir_itr_imp::increment	/usr/include/boost/filesystem/operations.hpp	/^      void increment(system::error_code* ec);  \/\/ ec == 0 means throw on error$/;"	p	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public	signature:(system::error_code* ec)
boost::filesystem::detail::recur_dir_itr_imp::increment	/usr/include/boost/filesystem/operations.hpp	/^    void recur_dir_itr_imp::increment(system::error_code* ec)$/;"	f	class:boost::filesystem::detail::recur_dir_itr_imp	signature:(system::error_code* ec)
boost::filesystem::detail::recur_dir_itr_imp::m_level	/usr/include/boost/filesystem/operations.hpp	/^      int  m_level;$/;"	m	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
boost::filesystem::detail::recur_dir_itr_imp::m_options	/usr/include/boost/filesystem/operations.hpp	/^      BOOST_SCOPED_ENUM(symlink_option) m_options;$/;"	m	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
boost::filesystem::detail::recur_dir_itr_imp::m_stack	/usr/include/boost/filesystem/operations.hpp	/^      std::stack< element_type, std::vector< element_type > > m_stack;$/;"	m	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
boost::filesystem::detail::recur_dir_itr_imp::pop	/usr/include/boost/filesystem/operations.hpp	/^      void pop();$/;"	p	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public	signature:()
boost::filesystem::detail::recur_dir_itr_imp::pop	/usr/include/boost/filesystem/operations.hpp	/^    void recur_dir_itr_imp::pop()$/;"	f	class:boost::filesystem::detail::recur_dir_itr_imp	signature:()
boost::filesystem::detail::recur_dir_itr_imp::recur_dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^      recur_dir_itr_imp() : m_level(0), m_options(symlink_option::none) {}$/;"	f	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public	signature:()
boost::filesystem::detail::remove	/usr/include/boost/filesystem/operations.hpp	/^    bool remove(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::remove_all	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t remove_all(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::rename	/usr/include/boost/filesystem/operations.hpp	/^    void rename(const path& old_p, const path& new_p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& old_p, const path& new_p, system::error_code* ec=0)
boost::filesystem::detail::resize_file	/usr/include/boost/filesystem/operations.hpp	/^    void resize_file(const path& p, uintmax_t size, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, uintmax_t size, system::error_code* ec=0)
boost::filesystem::detail::space	/usr/include/boost/filesystem/operations.hpp	/^    space_info space(const path& p, system::error_code* ec=0); $/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::status	/usr/include/boost/filesystem/operations.hpp	/^    file_status status(const path&p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path&p, system::error_code* ec=0)
boost::filesystem::detail::symlink_status	/usr/include/boost/filesystem/operations.hpp	/^    file_status symlink_status(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::system_complete	/usr/include/boost/filesystem/operations.hpp	/^    path system_complete(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::detail::temp_directory_path	/usr/include/boost/filesystem/operations.hpp	/^    path temp_directory_path(system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(system::error_code* ec=0)
boost::filesystem::detail::unique_path	/usr/include/boost/filesystem/operations.hpp	/^    path unique_path(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
boost::filesystem::directory_entry	/usr/include/boost/filesystem/operations.hpp	/^class BOOST_FILESYSTEM_DECL directory_entry$/;"	c	namespace:boost::filesystem
boost::filesystem::directory_entry::assign	/usr/include/boost/filesystem/operations.hpp	/^  void assign(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st = file_status(), file_status symlink_st = file_status())
boost::filesystem::directory_entry::directory_entry	/usr/include/boost/filesystem/operations.hpp	/^  directory_entry() {}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:()
boost::filesystem::directory_entry::directory_entry	/usr/include/boost/filesystem/operations.hpp	/^  explicit directory_entry(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st = file_status(), file_status symlink_st=file_status())
boost::filesystem::directory_entry::m_get_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status m_get_status(system::error_code* ec=0) const;$/;"	p	class:boost::filesystem::directory_entry	access:private	signature:(system::error_code* ec=0) const
boost::filesystem::directory_entry::m_get_symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status m_get_symlink_status(system::error_code* ec=0) const;$/;"	p	class:boost::filesystem::directory_entry	access:private	signature:(system::error_code* ec=0) const
boost::filesystem::directory_entry::m_path	/usr/include/boost/filesystem/operations.hpp	/^  boost::filesystem::path   m_path;$/;"	m	class:boost::filesystem::directory_entry	access:private
boost::filesystem::directory_entry::m_status	/usr/include/boost/filesystem/operations.hpp	/^  mutable file_status       m_status;           \/\/ stat()-like$/;"	m	class:boost::filesystem::directory_entry	access:private
boost::filesystem::directory_entry::m_symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  mutable file_status       m_symlink_status;   \/\/ lstat()-like$/;"	m	class:boost::filesystem::directory_entry	access:private
boost::filesystem::directory_entry::operator !=	/usr/include/boost/filesystem/operations.hpp	/^  bool operator!=(const directory_entry& rhs) {return m_path != rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
boost::filesystem::directory_entry::operator <	/usr/include/boost/filesystem/operations.hpp	/^  bool operator< (const directory_entry& rhs) {return m_path < rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
boost::filesystem::directory_entry::operator <=	/usr/include/boost/filesystem/operations.hpp	/^  bool operator<=(const directory_entry& rhs) {return m_path <= rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
boost::filesystem::directory_entry::operator ==	/usr/include/boost/filesystem/operations.hpp	/^  bool operator==(const directory_entry& rhs) {return m_path == rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
boost::filesystem::directory_entry::operator >	/usr/include/boost/filesystem/operations.hpp	/^  bool operator> (const directory_entry& rhs) {return m_path > rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
boost::filesystem::directory_entry::operator >=	/usr/include/boost/filesystem/operations.hpp	/^  bool operator>=(const directory_entry& rhs) {return m_path >= rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
boost::filesystem::directory_entry::path	/usr/include/boost/filesystem/operations.hpp	/^  const boost::filesystem::path&  path() const               {return m_path;}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:() const
boost::filesystem::directory_entry::replace_filename	/usr/include/boost/filesystem/operations.hpp	/^  void replace_filename(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st = file_status(), file_status symlink_st = file_status())
boost::filesystem::directory_entry::replace_leaf	/usr/include/boost/filesystem/operations.hpp	/^  void replace_leaf(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st, file_status symlink_st)
boost::filesystem::directory_entry::status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   status() const                               {return m_get_status();}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:() const
boost::filesystem::directory_entry::status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   status(system::error_code& ec) const         {return m_get_status(&ec);}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(system::error_code& ec) const
boost::filesystem::directory_entry::symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   symlink_status() const                       {return m_get_symlink_status();}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:() const
boost::filesystem::directory_entry::symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   symlink_status(system::error_code& ec) const {return m_get_symlink_status(&ec);}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(system::error_code& ec) const
boost::filesystem::directory_file	/usr/include/boost/filesystem/operations.hpp	/^    directory_file,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^  class directory_iterator$/;"	c	namespace:boost::filesystem	inherits:boost::iterator_facade
boost::filesystem::directory_iterator::dereference	/usr/include/boost/filesystem/operations.hpp	/^      boost::single_pass_traversal_tag >::reference dereference() const $/;"	f	class:boost::filesystem::directory_iterator	access:private	signature:() const
boost::filesystem::directory_iterator::detail::directory_iterator_construct	/usr/include/boost/filesystem/operations.hpp	/^    friend BOOST_FILESYSTEM_DECL void detail::directory_iterator_construct(directory_iterator& it,$/;"	p	class:boost::filesystem::directory_iterator::detail	access:friend	signature:(directory_iterator& it, const path& p, system::error_code* ec)
boost::filesystem::directory_iterator::detail::directory_iterator_increment	/usr/include/boost/filesystem/operations.hpp	/^    friend BOOST_FILESYSTEM_DECL void detail::directory_iterator_increment(directory_iterator& it,$/;"	p	class:boost::filesystem::directory_iterator::detail	access:friend	signature:(directory_iterator& it, system::error_code* ec)
boost::filesystem::directory_iterator::directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    directory_iterator(){}  \/\/ creates the "end" iterator$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:()
boost::filesystem::directory_iterator::directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    directory_iterator(const path& p, system::error_code& ec)$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:(const path& p, system::error_code& ec)
boost::filesystem::directory_iterator::directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    explicit directory_iterator(const path& p)$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:(const path& p)
boost::filesystem::directory_iterator::equal	/usr/include/boost/filesystem/operations.hpp	/^    bool equal(const directory_iterator& rhs) const$/;"	f	class:boost::filesystem::directory_iterator	access:private	signature:(const directory_iterator& rhs) const
boost::filesystem::directory_iterator::increment	/usr/include/boost/filesystem/operations.hpp	/^    directory_iterator& increment(system::error_code& ec)$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:(system::error_code& ec)
boost::filesystem::directory_iterator::increment	/usr/include/boost/filesystem/operations.hpp	/^    void increment() { detail::directory_iterator_increment(*this, 0); }$/;"	f	class:boost::filesystem::directory_iterator	access:private	signature:()
boost::filesystem::directory_iterator::m_imp	/usr/include/boost/filesystem/operations.hpp	/^    boost::shared_ptr< detail::dir_itr_imp >  m_imp;$/;"	m	class:boost::filesystem::directory_iterator	access:private
boost::filesystem::directory_iterator::~directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^   ~directory_iterator() {} \/\/ never throws$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:()
boost::filesystem::equivalent	/usr/include/boost/filesystem/operations.hpp	/^  bool equivalent(const path& p1, const path& p2) {return detail::equivalent(p1, p2);}$/;"	f	namespace:boost::filesystem	signature:(const path& p1, const path& p2)
boost::filesystem::equivalent	/usr/include/boost/filesystem/operations.hpp	/^  bool equivalent(const path& p1, const path& p2, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p1, const path& p2, system::error_code& ec)
boost::filesystem::exists	/usr/include/boost/filesystem/operations.hpp	/^  bool exists(const path& p)           {return exists(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::exists	/usr/include/boost/filesystem/operations.hpp	/^  bool exists(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::exists	/usr/include/boost/filesystem/operations.hpp	/^  inline bool exists(file_status f)       { return f.type() != status_error$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::extension	/usr/include/boost/filesystem/convenience.hpp	/^    inline std::string extension(const path & p)$/;"	f	namespace:boost::filesystem	signature:(const path & p)
boost::filesystem::fifo_file	/usr/include/boost/filesystem/operations.hpp	/^    fifo_file,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::filebuf	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_filebuf<char> filebuf;$/;"	t	namespace:boost::filesystem
boost::filesystem::filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^  class BOOST_SYMBOL_VISIBLE filesystem_error : public system::system_error$/;"	c	namespace:boost::filesystem	inherits:system::system_error
boost::filesystem::filesystem_error::filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    filesystem_error($/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:( const std::string & what_arg, const path& path1_arg, const path& path2_arg, system::error_code ec)
boost::filesystem::filesystem_error::filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    filesystem_error($/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:( const std::string & what_arg, const path& path1_arg, system::error_code ec)
boost::filesystem::filesystem_error::filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    filesystem_error($/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:( const std::string & what_arg, system::error_code ec)
boost::filesystem::filesystem_error::m_imp	/usr/include/boost/filesystem/operations.hpp	/^    struct m_imp$/;"	s	class:boost::filesystem::filesystem_error	access:private
boost::filesystem::filesystem_error::m_imp::m_path1	/usr/include/boost/filesystem/operations.hpp	/^      path         m_path1; \/\/ may be empty()$/;"	m	struct:boost::filesystem::filesystem_error::m_imp	access:public
boost::filesystem::filesystem_error::m_imp::m_path2	/usr/include/boost/filesystem/operations.hpp	/^      path         m_path2; \/\/ may be empty()$/;"	m	struct:boost::filesystem::filesystem_error::m_imp	access:public
boost::filesystem::filesystem_error::m_imp::m_what	/usr/include/boost/filesystem/operations.hpp	/^      std::string  m_what;  \/\/ not built until needed$/;"	m	struct:boost::filesystem::filesystem_error::m_imp	access:public
boost::filesystem::filesystem_error::m_imp_ptr	/usr/include/boost/filesystem/operations.hpp	/^    boost::shared_ptr<m_imp> m_imp_ptr;$/;"	m	class:boost::filesystem::filesystem_error	access:private
boost::filesystem::filesystem_error::path1	/usr/include/boost/filesystem/operations.hpp	/^    const path& path1() const$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:() const
boost::filesystem::filesystem_error::path2	/usr/include/boost/filesystem/operations.hpp	/^    const path& path2() const$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:() const
boost::filesystem::filesystem_error::what	/usr/include/boost/filesystem/operations.hpp	/^    const char* what() const throw()$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:() const
boost::filesystem::filesystem_error::~filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    ~filesystem_error() throw() {}$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:()
boost::filesystem::file_not_found	/usr/include/boost/filesystem/operations.hpp	/^    file_not_found,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::file_size	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t file_size(const path& p) {return detail::file_size(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::file_size	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t file_size(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::file_status	/usr/include/boost/filesystem/operations.hpp	/^  class BOOST_FILESYSTEM_DECL file_status$/;"	c	namespace:boost::filesystem
boost::filesystem::file_status::file_status	/usr/include/boost/filesystem/operations.hpp	/^             file_status()            : m_value(status_error), m_perms(perms_not_known) {}$/;"	f	class:boost::filesystem::file_status	access:public	signature:()
boost::filesystem::file_status::file_status	/usr/include/boost/filesystem/operations.hpp	/^    explicit file_status(file_type v, perms prms = perms_not_known)$/;"	f	class:boost::filesystem::file_status	access:public	signature:(file_type v, perms prms = perms_not_known)
boost::filesystem::file_status::m_perms	/usr/include/boost/filesystem/operations.hpp	/^    enum perms  m_perms;$/;"	m	class:boost::filesystem::file_status	typeref:enum:boost::filesystem::file_status::perms	access:private
boost::filesystem::file_status::m_value	/usr/include/boost/filesystem/operations.hpp	/^    file_type   m_value;$/;"	m	class:boost::filesystem::file_status	access:private
boost::filesystem::file_status::operator !=	/usr/include/boost/filesystem/operations.hpp	/^    bool operator!=(const file_status& rhs) const { return !(*this == rhs); }$/;"	f	class:boost::filesystem::file_status	access:public	signature:(const file_status& rhs) const
boost::filesystem::file_status::operator ==	/usr/include/boost/filesystem/operations.hpp	/^    bool operator==(const file_status& rhs) const { return type() == rhs.type() && $/;"	f	class:boost::filesystem::file_status	access:public	signature:(const file_status& rhs) const
boost::filesystem::file_status::permissions	/usr/include/boost/filesystem/operations.hpp	/^    perms      permissions() const                { return m_perms; } $/;"	f	class:boost::filesystem::file_status	access:public	signature:() const
boost::filesystem::file_status::permissions	/usr/include/boost/filesystem/operations.hpp	/^    void       permissions(perms prms)            { m_perms = prms; }$/;"	f	class:boost::filesystem::file_status	access:public	signature:(perms prms)
boost::filesystem::file_status::type	/usr/include/boost/filesystem/operations.hpp	/^    file_type  type() const                       { return m_value; }$/;"	f	class:boost::filesystem::file_status	access:public	signature:() const
boost::filesystem::file_status::type	/usr/include/boost/filesystem/operations.hpp	/^    void       type(file_type v)                  { m_value = v; }$/;"	f	class:boost::filesystem::file_status	access:public	signature:(file_type v)
boost::filesystem::file_type	/usr/include/boost/filesystem/operations.hpp	/^  enum file_type$/;"	g	namespace:boost::filesystem
boost::filesystem::fstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_fstream<char> fstream;$/;"	t	namespace:boost::filesystem
boost::filesystem::group_all	/usr/include/boost/filesystem/operations.hpp	/^    group_all = 070,    \/\/ S_IRWXG, Read, write, execute\/search by group$/;"	e	enum:boost::filesystem::perms
boost::filesystem::group_exe	/usr/include/boost/filesystem/operations.hpp	/^    group_exe = 010,    \/\/ S_IXGRP, Execute\/search permission, group$/;"	e	enum:boost::filesystem::perms
boost::filesystem::group_read	/usr/include/boost/filesystem/operations.hpp	/^    group_read = 040,   \/\/ S_IRGRP, Read permission, group$/;"	e	enum:boost::filesystem::perms
boost::filesystem::group_write	/usr/include/boost/filesystem/operations.hpp	/^    group_write = 020,  \/\/ S_IWGRP, Write permission, group$/;"	e	enum:boost::filesystem::perms
boost::filesystem::hard_link_count	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t hard_link_count(const path& p) {return detail::hard_link_count(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::hard_link_count	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t hard_link_count(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::hash_value	/usr/include/boost/filesystem/path.hpp	/^  inline std::size_t hash_value(const path& x)$/;"	f	namespace:boost::filesystem	signature:(const path& x)
boost::filesystem::ifstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ifstream<char> ifstream;$/;"	t	namespace:boost::filesystem
boost::filesystem::initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path()                  {return detail::initial_path();}$/;"	f	namespace:boost::filesystem	signature:()
boost::filesystem::initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path() {return initial_path();}$/;"	f	namespace:boost::filesystem	signature:()
boost::filesystem::initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path();$/;"	p	namespace:boost::filesystem	signature:()
boost::filesystem::initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path(system::error_code& ec) {return detail::initial_path(&ec);}$/;"	f	namespace:boost::filesystem	signature:(system::error_code& ec)
boost::filesystem::is_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool is_directory(const path& p)     {return is_directory(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::is_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool is_directory(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::is_directory	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_directory(file_status f) { return f.type() == directory_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::is_empty	/usr/include/boost/filesystem/operations.hpp	/^  bool is_empty(const path& p)         {return detail::is_empty(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::is_empty	/usr/include/boost/filesystem/operations.hpp	/^  bool is_empty(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::is_other	/usr/include/boost/filesystem/operations.hpp	/^  bool is_other(const path& p)         {return is_other(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::is_other	/usr/include/boost/filesystem/operations.hpp	/^  bool is_other(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::is_other	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_other(file_status f)     { return exists(f) && !is_regular_file(f)$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::is_regular	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular(const path& p)       {return is_regular(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::is_regular	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::is_regular	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_regular(file_status f)   { return f.type() == regular_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::is_regular_file	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular_file(const path& p)  {return is_regular_file(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::is_regular_file	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular_file(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::is_regular_file	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_regular_file(file_status f){ return f.type() == regular_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::is_symlink	/usr/include/boost/filesystem/operations.hpp	/^  bool is_symlink(const path& p)       {return is_symlink(detail::symlink_status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::is_symlink	/usr/include/boost/filesystem/operations.hpp	/^  bool is_symlink(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::is_symlink	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_symlink(file_status f)   { return f.type() == symlink_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  std::time_t last_write_time(const path& p) {return detail::last_write_time(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  std::time_t last_write_time(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  void last_write_time(const path& p, const std::time_t new_time)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const std::time_t new_time)
boost::filesystem::last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  void last_write_time(const path& p, const std::time_t new_time, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const std::time_t new_time, system::error_code& ec)
boost::filesystem::lexicographical_compare	/usr/include/boost/filesystem/path.hpp	/^  inline bool lexicographical_compare(path::iterator first1, path::iterator last1,$/;"	f	namespace:boost::filesystem	signature:(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2)
boost::filesystem::native	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool native(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
boost::filesystem::no_perms	/usr/include/boost/filesystem/operations.hpp	/^    no_perms = 0,       \/\/ file_not_found is no_perms rather than perms_not_known$/;"	e	enum:boost::filesystem::perms
boost::filesystem::ofstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ofstream<char> ofstream;$/;"	t	namespace:boost::filesystem
boost::filesystem::operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path& lhs, const path& rhs)              {return lhs.compare(rhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
boost::filesystem::operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path& lhs, const path::string_type& rhs) {return lhs.compare(rhs) != 0;} $/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::string_type& rhs)
boost::filesystem::operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path& lhs, const path::value_type* rhs)  {return lhs.compare(rhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::value_type* rhs)
boost::filesystem::operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path::string_type& lhs, const path& rhs) {return rhs.compare(lhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::string_type& lhs, const path& rhs)
boost::filesystem::operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path::value_type* lhs, const path& rhs)  {return rhs.compare(lhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::value_type* lhs, const path& rhs)
boost::filesystem::operator /	/usr/include/boost/filesystem/path.hpp	/^  inline path operator\/(const path& lhs, const path& rhs)  { return path(lhs) \/= rhs; }$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
boost::filesystem::operator <	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator<(const path& lhs, const path& rhs)  {return lhs.compare(rhs) < 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
boost::filesystem::operator <<	/usr/include/boost/filesystem/path.hpp	/^  operator<<(std::basic_ostream<Char, Traits>& os, const path& p)$/;"	f	namespace:boost::filesystem	signature:(std::basic_ostream<Char, Traits>& os, const path& p)
boost::filesystem::operator <=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator<=(const path& lhs, const path& rhs) {return !(rhs < lhs);}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
boost::filesystem::operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path& lhs, const path& rhs)              {return lhs.compare(rhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
boost::filesystem::operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path& lhs, const path::string_type& rhs) {return lhs.compare(rhs) == 0;} $/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::string_type& rhs)
boost::filesystem::operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path& lhs, const path::value_type* rhs)  {return lhs.compare(rhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::value_type* rhs)
boost::filesystem::operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path::string_type& lhs, const path& rhs) {return rhs.compare(lhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::string_type& lhs, const path& rhs)
boost::filesystem::operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path::value_type* lhs, const path& rhs)  {return rhs.compare(lhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::value_type* lhs, const path& rhs)
boost::filesystem::operator >	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator> (const path& lhs, const path& rhs) {return rhs < lhs;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
boost::filesystem::operator >=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator>=(const path& lhs, const path& rhs) {return !(lhs < rhs);}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
boost::filesystem::operator >>	/usr/include/boost/filesystem/path.hpp	/^  operator>>(std::basic_istream<Char, Traits>& is, path& p)$/;"	f	namespace:boost::filesystem	signature:(std::basic_istream<Char, Traits>& is, path& p)
boost::filesystem::others_all	/usr/include/boost/filesystem/operations.hpp	/^    others_all = 07,    \/\/ S_IRWXO, Read, write, execute\/search by others$/;"	e	enum:boost::filesystem::perms
boost::filesystem::others_exe	/usr/include/boost/filesystem/operations.hpp	/^    others_exe = 01,    \/\/ S_IXOTH, Execute\/search permission, others$/;"	e	enum:boost::filesystem::perms
boost::filesystem::others_read	/usr/include/boost/filesystem/operations.hpp	/^    others_read = 04,   \/\/ S_IROTH, Read permission, others$/;"	e	enum:boost::filesystem::perms
boost::filesystem::others_write	/usr/include/boost/filesystem/operations.hpp	/^    others_write = 02,  \/\/ S_IWOTH, Write permission, others$/;"	e	enum:boost::filesystem::perms
boost::filesystem::owner_all	/usr/include/boost/filesystem/operations.hpp	/^    owner_all = 0700,   \/\/ S_IRWXU, Read, write, execute\/search by owner$/;"	e	enum:boost::filesystem::perms
boost::filesystem::owner_exe	/usr/include/boost/filesystem/operations.hpp	/^    owner_exe = 0100,   \/\/ S_IXUSR, Execute\/search permission, owner$/;"	e	enum:boost::filesystem::perms
boost::filesystem::owner_read	/usr/include/boost/filesystem/operations.hpp	/^    owner_read = 0400,  \/\/ S_IRUSR, Read permission, owner$/;"	e	enum:boost::filesystem::perms
boost::filesystem::owner_write	/usr/include/boost/filesystem/operations.hpp	/^    owner_write = 0200, \/\/ S_IWUSR, Write permission, owner$/;"	e	enum:boost::filesystem::perms
boost::filesystem::path	/usr/include/boost/filesystem/path.hpp	/^  class BOOST_FILESYSTEM_DECL path$/;"	c	namespace:boost::filesystem
boost::filesystem::path::append	/usr/include/boost/filesystem/path.hpp	/^    path& append(const value_type* ptr, const codecvt_type&)  \/\/ required in case ptr overlaps *this$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr, const codecvt_type&)
boost::filesystem::path::append	/usr/include/boost/filesystem/path.hpp	/^    path& append(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
boost::filesystem::path::append	/usr/include/boost/filesystem/path.hpp	/^    path& append(InputIterator begin, InputIterator end, const codecvt_type& cvt);$/;"	p	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
boost::filesystem::path::append	/usr/include/boost/filesystem/path.hpp	/^    path& append(Source const& source, const codecvt_type& cvt);$/;"	p	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
boost::filesystem::path::append	/usr/include/boost/filesystem/path.hpp	/^  path& path::append(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
boost::filesystem::path::append	/usr/include/boost/filesystem/path.hpp	/^  path& path::append(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	signature:(Source const& source, const codecvt_type& cvt)
boost::filesystem::path::assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(const value_type* ptr, const codecvt_type&)  \/\/ required in case ptr overlaps *this$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr, const codecvt_type&)
boost::filesystem::path::assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
boost::filesystem::path::assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
boost::filesystem::path::assign	/usr/include/boost/filesystem/path.hpp	/^    path& assign(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
boost::filesystem::path::begin	/usr/include/boost/filesystem/path.hpp	/^    iterator begin() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::BOOST_NOEXCEPT	/usr/include/boost/filesystem/path.hpp	/^    int compare(const path& p) const BOOST_NOEXCEPT;  \/\/ generic, lexicographical$/;"	m	class:boost::filesystem::path	access:public
boost::filesystem::path::branch_path	/usr/include/boost/filesystem/path.hpp	/^    path   branch_path() const      { return parent_path(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::clear	/usr/include/boost/filesystem/path.hpp	/^    void   clear()             { m_pathname.clear(); }$/;"	f	class:boost::filesystem::path	access:public	signature:()
boost::filesystem::path::codecvt	/usr/include/boost/filesystem/path.hpp	/^    static const        codecvt_type& codecvt();$/;"	p	class:boost::filesystem::path	access:public	signature:()
boost::filesystem::path::codecvt_type	/usr/include/boost/filesystem/path.hpp	/^                         std::mbstate_t>   codecvt_type;$/;"	t	class:boost::filesystem::path	access:public
boost::filesystem::path::compare	/usr/include/boost/filesystem/path.hpp	/^    int compare(const std::string& s) const { return compare(path(s)); }$/;"	f	class:boost::filesystem::path	access:public	signature:(const std::string& s) const
boost::filesystem::path::compare	/usr/include/boost/filesystem/path.hpp	/^    int compare(const value_type* s) const  { return compare(path(s)); }$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* s) const
boost::filesystem::path::concat	/usr/include/boost/filesystem/path.hpp	/^    path& concat(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
boost::filesystem::path::concat	/usr/include/boost/filesystem/path.hpp	/^    path& concat(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
boost::filesystem::path::concat	/usr/include/boost/filesystem/path.hpp	/^    path& concat(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
boost::filesystem::path::const_iterator	/usr/include/boost/filesystem/path.hpp	/^    typedef iterator const_iterator;$/;"	t	class:boost::filesystem::path	access:public
boost::filesystem::path::c_str	/usr/include/boost/filesystem/path.hpp	/^    const value_type*   c_str() const  { return m_pathname.c_str(); }  \/\/ Throws: nothing$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::directory_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string directory_string() const          { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::empty	/usr/include/boost/filesystem/path.hpp	/^    bool empty() const               { return m_pathname.empty(); } \/\/ name consistent with std containers$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::end	/usr/include/boost/filesystem/path.hpp	/^    iterator end() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::extension	/usr/include/boost/filesystem/path.hpp	/^    path  extension() const;         \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::external_directory_string	/usr/include/boost/filesystem/path.hpp	/^    const string_type external_directory_string() const { return native(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::external_file_string	/usr/include/boost/filesystem/path.hpp	/^    const string_type external_file_string() const      { return native(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::filename	/usr/include/boost/filesystem/path.hpp	/^    path  filename() const;          \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::file_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string file_string() const               { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string   generic_string() const { return generic_string(codecvt()); } $/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string   generic_string(const codecvt_type& cvt) const; $/;"	p	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  generic_string() const  { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  generic_string(const codecvt_type&) const  { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^    String generic_string() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^    String generic_string(const codecvt_type& cvt) const;$/;"	p	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::generic_string<std::string>() const$/;"	f	class:boost::filesystem::path	signature:() const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::generic_string<std::string>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::generic_string<std::wstring>() const$/;"	f	class:boost::filesystem::path	signature:() const
boost::filesystem::path::generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::generic_string<std::wstring>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
boost::filesystem::path::generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring() const { return wstring(codecvt()); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring(const codecvt_type& cvt) const { return wstring(cvt); }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
boost::filesystem::path::generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring(const codecvt_type&) const { return generic_wstring(); };$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
boost::filesystem::path::has_branch_path	/usr/include/boost/filesystem/path.hpp	/^    bool   has_branch_path() const  { return !parent_path().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_extension	/usr/include/boost/filesystem/path.hpp	/^    bool has_extension() const       { return !extension().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_filename	/usr/include/boost/filesystem/path.hpp	/^    bool has_filename() const        { return !m_pathname.empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_leaf	/usr/include/boost/filesystem/path.hpp	/^    bool   has_leaf() const         { return !m_pathname.empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_parent_path	/usr/include/boost/filesystem/path.hpp	/^    bool has_parent_path() const     { return !parent_path().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_relative_path	/usr/include/boost/filesystem/path.hpp	/^    bool has_relative_path() const   { return !relative_path().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_root_directory	/usr/include/boost/filesystem/path.hpp	/^    bool has_root_directory() const  { return !root_directory().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_root_name	/usr/include/boost/filesystem/path.hpp	/^    bool has_root_name() const       { return !root_name().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_root_path	/usr/include/boost/filesystem/path.hpp	/^    bool has_root_path() const       { return has_root_directory() || has_root_name(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::has_stem	/usr/include/boost/filesystem/path.hpp	/^    bool has_stem() const            { return !stem().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::imbue	/usr/include/boost/filesystem/path.hpp	/^    static std::locale  imbue(const std::locale& loc);$/;"	p	class:boost::filesystem::path	access:public	signature:(const std::locale& loc)
boost::filesystem::path::is_absolute	/usr/include/boost/filesystem/path.hpp	/^    bool is_absolute() const$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::is_complete	/usr/include/boost/filesystem/path.hpp	/^    bool   is_complete() const      { return is_absolute(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::is_relative	/usr/include/boost/filesystem/path.hpp	/^    bool is_relative() const         { return !is_absolute(); } $/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::iterator	/usr/include/boost/filesystem/path.hpp	/^  class path::iterator$/;"	c	class:boost::filesystem::path	inherits:boost::iterator_facade
boost::filesystem::path::iterator::decrement	/usr/include/boost/filesystem/path.hpp	/^    void decrement() { m_path_iterator_decrement(*this); }$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:()
boost::filesystem::path::iterator::dereference	/usr/include/boost/filesystem/path.hpp	/^    const path& dereference() const { return m_element; }$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:() const
boost::filesystem::path::iterator::equal	/usr/include/boost/filesystem/path.hpp	/^    bool equal(const iterator & rhs) const$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:(const iterator & rhs) const
boost::filesystem::path::iterator::increment	/usr/include/boost/filesystem/path.hpp	/^    void increment() { m_path_iterator_increment(*this); }$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:()
boost::filesystem::path::iterator::m_element	/usr/include/boost/filesystem/path.hpp	/^    path                    m_element;   \/\/ current element$/;"	m	class:boost::filesystem::path::iterator	access:private
boost::filesystem::path::iterator::m_path_iterator_decrement	/usr/include/boost/filesystem/path.hpp	/^    friend void m_path_iterator_decrement(path::iterator & it);$/;"	p	class:boost::filesystem::path::iterator	access:friend	signature:(path::iterator & it)
boost::filesystem::path::iterator::m_path_iterator_increment	/usr/include/boost/filesystem/path.hpp	/^    friend void m_path_iterator_increment(path::iterator & it);$/;"	p	class:boost::filesystem::path::iterator	access:friend	signature:(path::iterator & it)
boost::filesystem::path::iterator::m_path_ptr	/usr/include/boost/filesystem/path.hpp	/^    const path*             m_path_ptr;  \/\/ path being iterated over$/;"	m	class:boost::filesystem::path::iterator	access:private
boost::filesystem::path::iterator::m_pos	/usr/include/boost/filesystem/path.hpp	/^    string_type::size_type  m_pos;       \/\/ position of m_element in$/;"	m	class:boost::filesystem::path::iterator	access:private
boost::filesystem::path::leaf	/usr/include/boost/filesystem/path.hpp	/^    path   leaf() const             { return filename(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::make_preferred	/usr/include/boost/filesystem/path.hpp	/^    path&  make_preferred()$/;"	f	class:boost::filesystem::path	access:public	signature:()
boost::filesystem::path::m_append_separator_if_needed	/usr/include/boost/filesystem/path.hpp	/^    string_type::size_type m_append_separator_if_needed();$/;"	p	class:boost::filesystem::path	access:private	signature:()
boost::filesystem::path::m_erase_redundant_separator	/usr/include/boost/filesystem/path.hpp	/^    void m_erase_redundant_separator(string_type::size_type sep_pos);$/;"	p	class:boost::filesystem::path	access:private	signature:(string_type::size_type sep_pos)
boost::filesystem::path::m_normalize	/usr/include/boost/filesystem/path.hpp	/^    path& m_normalize();$/;"	p	class:boost::filesystem::path	access:private	signature:()
boost::filesystem::path::m_parent_path_end	/usr/include/boost/filesystem/path.hpp	/^    string_type::size_type m_parent_path_end() const;$/;"	p	class:boost::filesystem::path	access:private	signature:() const
boost::filesystem::path::m_pathname	/usr/include/boost/filesystem/path.hpp	/^    string_type  m_pathname;  \/\/ Windows: as input; backslashes NOT converted to slashes,$/;"	m	class:boost::filesystem::path	access:private
boost::filesystem::path::m_path_iterator_decrement	/usr/include/boost/filesystem/path.hpp	/^    static void m_path_iterator_decrement(path::iterator & it);$/;"	p	class:boost::filesystem::path	access:private	signature:(path::iterator & it)
boost::filesystem::path::m_path_iterator_increment	/usr/include/boost/filesystem/path.hpp	/^    static void m_path_iterator_increment(path::iterator & it);$/;"	p	class:boost::filesystem::path	access:private	signature:(path::iterator & it)
boost::filesystem::path::native	/usr/include/boost/filesystem/path.hpp	/^    const string_type&  native() const { return m_pathname; }          \/\/ Throws: nothing$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::native_directory_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string native_directory_string() const   { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::native_file_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string native_file_string() const        { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::normalize	/usr/include/boost/filesystem/path.hpp	/^    path&  normalize()              { return m_normalize(); }$/;"	f	class:boost::filesystem::path	access:public	signature:()
boost::filesystem::path::operator +=	/usr/include/boost/filesystem/path.hpp	/^    operator+=(CharT c)$/;"	f	class:boost::filesystem::path	access:public	signature:(CharT c)
boost::filesystem::path::operator +=	/usr/include/boost/filesystem/path.hpp	/^    operator+=(Source const& source)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source)
boost::filesystem::path::operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(const path& p)         {m_pathname += p.m_pathname; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(const path& p)
boost::filesystem::path::operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(const string_type& s)  {m_pathname += s; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(const string_type& s)
boost::filesystem::path::operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(const value_type* ptr) {m_pathname += ptr; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr)
boost::filesystem::path::operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(value_type c)          {m_pathname += c; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(value_type c)
boost::filesystem::path::operator /=	/usr/include/boost/filesystem/path.hpp	/^    operator\/=(Source const& source)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source)
boost::filesystem::path::operator /=	/usr/include/boost/filesystem/path.hpp	/^    path& operator\/=(const path& p);$/;"	p	class:boost::filesystem::path	access:public	signature:(const path& p)
boost::filesystem::path::operator /=	/usr/include/boost/filesystem/path.hpp	/^    path& operator\/=(const value_type* ptr);$/;"	p	class:boost::filesystem::path	access:public	signature:(const value_type* ptr)
boost::filesystem::path::operator <	/usr/include/boost/filesystem/path.hpp	/^    friend bool operator<(const path& lhs, const path& rhs);$/;"	p	class:boost::filesystem::path	access:friend	signature:(const path& lhs, const path& rhs)
boost::filesystem::path::operator =	/usr/include/boost/filesystem/path.hpp	/^    operator=(Source const& source)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source)
boost::filesystem::path::operator =	/usr/include/boost/filesystem/path.hpp	/^    path& operator=(const path& p)$/;"	f	class:boost::filesystem::path	access:public	signature:(const path& p)
boost::filesystem::path::operator =	/usr/include/boost/filesystem/path.hpp	/^    path& operator=(const value_type* ptr)  \/\/ required in case ptr overlaps *this$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr)
boost::filesystem::path::parent_path	/usr/include/boost/filesystem/path.hpp	/^    path  parent_path() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(){}                                          $/;"	f	class:boost::filesystem::path	access:public	signature:()
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(const path& p) : m_pathname(p.m_pathname) {}$/;"	f	class:boost::filesystem::path	access:public	signature:(const path& p)
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(const std::basic_string<value_type>& s) : m_pathname(s) {}$/;"	f	class:boost::filesystem::path	access:public	signature:(const std::basic_string<value_type>& s)
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(const value_type* s) : m_pathname(s) {}$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* s)
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
boost::filesystem::path::path	/usr/include/boost/filesystem/path.hpp	/^    path(Source const& source,$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, typename boost::enable_if<path_traits::is_pathable< typename boost::decay<Source>::type> >::type* =0)
boost::filesystem::path::preferred_separator	/usr/include/boost/filesystem/path.hpp	/^    BOOST_STATIC_CONSTEXPR value_type      preferred_separator = L'\\\\';$/;"	m	class:boost::filesystem::path	access:public
boost::filesystem::path::relative_path	/usr/include/boost/filesystem/path.hpp	/^    path  relative_path() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::remove_filename	/usr/include/boost/filesystem/path.hpp	/^    path&  remove_filename();$/;"	p	class:boost::filesystem::path	access:public	signature:()
boost::filesystem::path::remove_leaf	/usr/include/boost/filesystem/path.hpp	/^    path&  remove_leaf()            { return remove_filename(); }$/;"	f	class:boost::filesystem::path	access:public	signature:()
boost::filesystem::path::replace_extension	/usr/include/boost/filesystem/path.hpp	/^    path&  replace_extension(const path& new_extension = path());$/;"	p	class:boost::filesystem::path	access:public	signature:(const path& new_extension = path())
boost::filesystem::path::root_directory	/usr/include/boost/filesystem/path.hpp	/^    path  root_directory() const;    \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::root_name	/usr/include/boost/filesystem/path.hpp	/^    path  root_name() const;         \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::root_path	/usr/include/boost/filesystem/path.hpp	/^    path  root_path() const; $/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::stem	/usr/include/boost/filesystem/path.hpp	/^    path  stem() const;              \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^    const std::string string() const { return string(codecvt()); } $/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^    const std::string string(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  string() const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  string(const codecvt_type&) const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^    String string() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^    String string(const codecvt_type& cvt) const;$/;"	p	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::string<std::string>() const$/;"	f	class:boost::filesystem::path	signature:() const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::string<std::string>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::string<std::wstring>() const$/;"	f	class:boost::filesystem::path	signature:() const
boost::filesystem::path::string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::string<std::wstring>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
boost::filesystem::path::string_type	/usr/include/boost/filesystem/path.hpp	/^    typedef std::basic_string<value_type>  string_type;  $/;"	t	class:boost::filesystem::path	access:public
boost::filesystem::path::swap	/usr/include/boost/filesystem/path.hpp	/^    void   swap(path& rhs)     { m_pathname.swap(rhs.m_pathname); }$/;"	f	class:boost::filesystem::path	access:public	signature:(path& rhs)
boost::filesystem::path::value_type	/usr/include/boost/filesystem/path.hpp	/^    typedef wchar_t                        value_type;$/;"	t	class:boost::filesystem::path	access:public
boost::filesystem::path::wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  wstring() const { return wstring(codecvt()); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  wstring(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
boost::filesystem::path::wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring&  wstring() const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
boost::filesystem::path::wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring&  wstring(const codecvt_type&) const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
boost::filesystem::path_traits	/usr/include/boost/filesystem/path_traits.hpp	/^namespace path_traits {$/;"	n	namespace:boost::filesystem
boost::filesystem::path_traits::codecvt_type	/usr/include/boost/filesystem/path_traits.hpp	/^  typedef std::codecvt<wchar_t, char, std::mbstate_t> codecvt_type;$/;"	t	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from, const char* from_end, std::string & to,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const char* from, const char* from_end, std::string & to, const codecvt_type&)
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const char* from, std::string & to, const codecvt_type&)
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const char* from, std::wstring & to, const codecvt_type& cvt)
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from,$/;"	p	namespace:boost::filesystem::path_traits	signature:(const char* from, const char* from_end, std::wstring & to, const codecvt_type& cvt)
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from, const wchar_t* from_end, std::wstring & to,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, const wchar_t* from_end, std::wstring & to, const codecvt_type&)
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, std::string & to, const codecvt_type& cvt)
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, std::wstring & to, const codecvt_type&)
boost::filesystem::path_traits::convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from,$/;"	p	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, const wchar_t* from_end, std::string & to, const codecvt_type& cvt)
boost::filesystem::path_traits::dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^      dispatch(const Container & c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const Container & c, U& to, const codecvt_type& cvt)
boost::filesystem::path_traits::dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::string& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::string& c, U& to, const codecvt_type& cvt)
boost::filesystem::path_traits::dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::vector<char>& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::vector<char>& c, U& to, const codecvt_type& cvt)
boost::filesystem::path_traits::dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::vector<wchar_t>& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::vector<wchar_t>& c, U& to, const codecvt_type& cvt)
boost::filesystem::path_traits::dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::wstring& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::wstring& c, U& to, const codecvt_type& cvt)
boost::filesystem::path_traits::dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^  void dispatch(const directory_entry & de,$/;"	p	namespace:boost::filesystem::path_traits	signature:(const directory_entry & de, std::wstring & to, const codecvt_type&)
boost::filesystem::path_traits::dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^  void dispatch(T * const & c_str, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(T * const & c_str, U& to, const codecvt_type& cvt)
boost::filesystem::path_traits::empty	/usr/include/boost/filesystem/path_traits.hpp	/^      empty(const Container & c)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const Container & c)
boost::filesystem::path_traits::empty	/usr/include/boost/filesystem/path_traits.hpp	/^    bool empty(T * const & c_str)$/;"	f	namespace:boost::filesystem::path_traits	signature:(T * const & c_str)
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  struct is_pathable { static const bool value = false; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<char*>                  { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const char*>            { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const wchar_t*>         { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<directory_entry>        { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<char> >       { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<wchar_t> >    { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::string>            { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<char> >     { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<wchar_t> >  { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::wstring>           { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<wchar_t*>               { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  struct is_pathable { static const bool value = false; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<char*>                  { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const char*>            { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const wchar_t*>         { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<directory_entry>        { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<char> >       { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<wchar_t> >    { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::string>            { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<char> >     { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<wchar_t> >  { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::wstring>           { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::path_traits::is_pathable::value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<wchar_t*>               { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
boost::filesystem::permissions	/usr/include/boost/filesystem/operations.hpp	/^  void permissions(const path& p, perms prms)$/;"	f	namespace:boost::filesystem	signature:(const path& p, perms prms)
boost::filesystem::permissions	/usr/include/boost/filesystem/operations.hpp	/^  void permissions(const path& p, perms prms, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, perms prms, system::error_code& ec)
boost::filesystem::permissions_present	/usr/include/boost/filesystem/operations.hpp	/^  inline bool permissions_present(file_status f)$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::perms	/usr/include/boost/filesystem/operations.hpp	/^  enum perms$/;"	g	namespace:boost::filesystem
boost::filesystem::perms_mask	/usr/include/boost/filesystem/operations.hpp	/^    perms_mask = all_all|set_uid_on_exe|set_gid_on_exe|sticky_bit,  \/\/ 07777$/;"	e	enum:boost::filesystem::perms
boost::filesystem::perms_not_known	/usr/include/boost/filesystem/operations.hpp	/^    perms_not_known = 0xFFFF, \/\/ present when directory_entry cache not loaded$/;"	e	enum:boost::filesystem::perms
boost::filesystem::portable_directory_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_directory_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
boost::filesystem::portable_file_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_file_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
boost::filesystem::portable_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
boost::filesystem::portable_posix_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_posix_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
boost::filesystem::read_symlink	/usr/include/boost/filesystem/operations.hpp	/^  path read_symlink(const path& p)     {return detail::read_symlink(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::read_symlink	/usr/include/boost/filesystem/operations.hpp	/^  path read_symlink(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^  class recursive_directory_iterator$/;"	c	namespace:boost::filesystem	inherits:boost::iterator_facade
boost::filesystem::recursive_directory_iterator::dereference	/usr/include/boost/filesystem/operations.hpp	/^    dereference() const $/;"	f	class:boost::filesystem::recursive_directory_iterator	access:private	signature:() const
boost::filesystem::recursive_directory_iterator::equal	/usr/include/boost/filesystem/operations.hpp	/^    bool equal(const recursive_directory_iterator& rhs) const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:private	signature:(const recursive_directory_iterator& rhs) const
boost::filesystem::recursive_directory_iterator::increment	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator& increment(system::error_code& ec)$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(system::error_code& ec)
boost::filesystem::recursive_directory_iterator::increment	/usr/include/boost/filesystem/operations.hpp	/^    void increment()$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:private	signature:()
boost::filesystem::recursive_directory_iterator::level	/usr/include/boost/filesystem/operations.hpp	/^    int level() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
boost::filesystem::recursive_directory_iterator::m_imp	/usr/include/boost/filesystem/operations.hpp	/^    boost::shared_ptr< detail::recur_dir_itr_imp >  m_imp;$/;"	m	class:boost::filesystem::recursive_directory_iterator	access:private
boost::filesystem::recursive_directory_iterator::no_push	/usr/include/boost/filesystem/operations.hpp	/^    void no_push(bool value=true)$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(bool value=true)
boost::filesystem::recursive_directory_iterator::no_push_pending	/usr/include/boost/filesystem/operations.hpp	/^    bool no_push_pending() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
boost::filesystem::recursive_directory_iterator::no_push_request	/usr/include/boost/filesystem/operations.hpp	/^    bool no_push_request() const { return no_push_pending(); }$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
boost::filesystem::recursive_directory_iterator::pop	/usr/include/boost/filesystem/operations.hpp	/^    void pop()$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:()
boost::filesystem::recursive_directory_iterator::recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    explicit recursive_directory_iterator(const path& dir_path,$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(const path& dir_path, BOOST_SCOPED_ENUM(symlink_option) opt = symlink_option::none)
boost::filesystem::recursive_directory_iterator::recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator(){}  \/\/ creates the "end" iterator$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:()
boost::filesystem::recursive_directory_iterator::recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator(const path& dir_path,$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(const path& dir_path, BOOST_SCOPED_ENUM(symlink_option) opt, system::error_code & ec)
boost::filesystem::recursive_directory_iterator::recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator(const path& dir_path,$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(const path& dir_path, system::error_code & ec)
boost::filesystem::recursive_directory_iterator::status	/usr/include/boost/filesystem/operations.hpp	/^    file_status status() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
boost::filesystem::recursive_directory_iterator::symlink_status	/usr/include/boost/filesystem/operations.hpp	/^    file_status symlink_status() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
boost::filesystem::regular_file	/usr/include/boost/filesystem/operations.hpp	/^    regular_file,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::remove	/usr/include/boost/filesystem/operations.hpp	/^  bool remove(const path& p)           {return detail::remove(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::remove	/usr/include/boost/filesystem/operations.hpp	/^  bool remove(const path& p, system::error_code& ec) {return detail::remove(p, &ec);}$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::remove_all	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t remove_all(const path& p) {return detail::remove_all(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::remove_all	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t remove_all(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::remove_perms	/usr/include/boost/filesystem/operations.hpp	/^    remove_perms = 0x2000,  \/\/ removes the given permission bits from the current bits;$/;"	e	enum:boost::filesystem::perms
boost::filesystem::rename	/usr/include/boost/filesystem/operations.hpp	/^  void rename(const path& old_p, const path& new_p) {detail::rename(old_p, new_p);}$/;"	f	namespace:boost::filesystem	signature:(const path& old_p, const path& new_p)
boost::filesystem::rename	/usr/include/boost/filesystem/operations.hpp	/^  void rename(const path& old_p, const path& new_p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& old_p, const path& new_p, system::error_code& ec)
boost::filesystem::reparse_file	/usr/include/boost/filesystem/operations.hpp	/^    reparse_file,  \/\/ Windows: FILE_ATTRIBUTE_REPARSE_POINT that is not a symlink$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::resize_file	/usr/include/boost/filesystem/operations.hpp	/^  void resize_file(const path& p, uintmax_t size) {detail::resize_file(p, size);}$/;"	f	namespace:boost::filesystem	signature:(const path& p, uintmax_t size)
boost::filesystem::resize_file	/usr/include/boost/filesystem/operations.hpp	/^  void resize_file(const path& p, uintmax_t size, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, uintmax_t size, system::error_code& ec)
boost::filesystem::set_gid_on_exe	/usr/include/boost/filesystem/operations.hpp	/^    set_gid_on_exe = 02000, \/\/ S_ISGID, Set-group-ID on execution$/;"	e	enum:boost::filesystem::perms
boost::filesystem::set_uid_on_exe	/usr/include/boost/filesystem/operations.hpp	/^    set_uid_on_exe = 04000, \/\/ S_ISUID, Set-user-ID on execution$/;"	e	enum:boost::filesystem::perms
boost::filesystem::socket_file	/usr/include/boost/filesystem/operations.hpp	/^    socket_file,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::space	/usr/include/boost/filesystem/operations.hpp	/^  space_info space(const path& p)      {return detail::space(p);} $/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::space	/usr/include/boost/filesystem/operations.hpp	/^  space_info space(const path& p, system::error_code& ec) {return detail::space(p, &ec);} $/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::space_info	/usr/include/boost/filesystem/operations.hpp	/^  struct space_info$/;"	s	namespace:boost::filesystem
boost::filesystem::space_info::available	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t available; \/\/ <= free$/;"	m	struct:boost::filesystem::space_info	access:public
boost::filesystem::space_info::capacity	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t capacity;$/;"	m	struct:boost::filesystem::space_info	access:public
boost::filesystem::space_info::free	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t free;      \/\/ <= capacity$/;"	m	struct:boost::filesystem::space_info	access:public
boost::filesystem::status	/usr/include/boost/filesystem/operations.hpp	/^  file_status status(const path& p)    {return detail::status(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::status	/usr/include/boost/filesystem/operations.hpp	/^  file_status status(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::status_error	/usr/include/boost/filesystem/operations.hpp	/^    status_error,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::status_known	/usr/include/boost/filesystem/operations.hpp	/^  inline bool status_known(file_status f) { return type_present(f) && permissions_present(f); }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::status_unknown	/usr/include/boost/filesystem/operations.hpp	/^    status_unknown = status_error,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::sticky_bit	/usr/include/boost/filesystem/operations.hpp	/^    sticky_bit     = 01000, \/\/ S_ISVTX,$/;"	e	enum:boost::filesystem::perms
boost::filesystem::swap	/usr/include/boost/filesystem/path.hpp	/^  inline void swap(path& lhs, path& rhs)                   { lhs.swap(rhs); }$/;"	f	namespace:boost::filesystem	signature:(path& lhs, path& rhs)
boost::filesystem::symbolic_link_exists	/usr/include/boost/filesystem/operations.hpp	/^  inline bool symbolic_link_exists(const path& p)$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::symlink_file	/usr/include/boost/filesystem/operations.hpp	/^    symlink_file,$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::symlink_perms	/usr/include/boost/filesystem/operations.hpp	/^    symlink_perms = 0x4000  \/\/ on POSIX, don't resolve symlinks; implied on Windows$/;"	e	enum:boost::filesystem::perms
boost::filesystem::symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status symlink_status(const path& p) {return detail::symlink_status(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status symlink_status(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::system_complete	/usr/include/boost/filesystem/operations.hpp	/^  path system_complete(const path& p)  {return detail::system_complete(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
boost::filesystem::system_complete	/usr/include/boost/filesystem/operations.hpp	/^  path system_complete(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::temp_directory_path	/usr/include/boost/filesystem/operations.hpp	/^  path temp_directory_path()           {return detail::temp_directory_path();}$/;"	f	namespace:boost::filesystem	signature:()
boost::filesystem::temp_directory_path	/usr/include/boost/filesystem/operations.hpp	/^  path temp_directory_path(system::error_code& ec) $/;"	f	namespace:boost::filesystem	signature:(system::error_code& ec)
boost::filesystem::type_present	/usr/include/boost/filesystem/operations.hpp	/^  inline bool type_present(file_status f) { return f.type() != status_error; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
boost::filesystem::type_unknown	/usr/include/boost/filesystem/operations.hpp	/^    type_unknown,  \/\/ file does exist, but isn't one of the above types or$/;"	e	enum:boost::filesystem::file_type
boost::filesystem::unique_path	/usr/include/boost/filesystem/operations.hpp	/^  path unique_path(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
boost::filesystem::unique_path	/usr/include/boost/filesystem/operations.hpp	/^  path unique_path(const path& p="%%%%-%%%%-%%%%-%%%%")$/;"	f	namespace:boost::filesystem	signature:(const path& p=)
boost::filesystem::wfilebuf	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_filebuf<wchar_t> wfilebuf;$/;"	t	namespace:boost::filesystem
boost::filesystem::wfstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_fstream<wchar_t> wfstream;$/;"	t	namespace:boost::filesystem
boost::filesystem::wifstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ifstream<wchar_t> wifstream;$/;"	t	namespace:boost::filesystem
boost::filesystem::windows_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool windows_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
boost::filesystem::wofstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ofstream<wchar_t> wofstream;$/;"	t	namespace:boost::filesystem
boost::filesystem::wpath	/usr/include/boost/filesystem/path.hpp	/^  typedef path wpath;$/;"	t	namespace:boost::filesystem
boost::filesystem::wrecursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^  typedef recursive_directory_iterator wrecursive_directory_iterator;$/;"	t	namespace:boost::filesystem
boost::filesystem::_detail_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^    _detail_directory_symlink  \/\/ internal use only; never exposed to users$/;"	e	enum:boost::filesystem::file_type
boost::FindFilesCallback	/usr/include/boost/regex/v4/cregex.hpp	/^typedef bool (__cdecl *FindFilesCallback)(const char* file);$/;"	t	namespace:boost
boost::functor1	/usr/include/boost/regex/concepts.hpp	/^struct functor1$/;"	s	namespace:boost
boost::functor1::char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename M::char_type char_type;$/;"	t	struct:boost::functor1	access:public
boost::functor1::operator ()	/usr/include/boost/regex/concepts.hpp	/^   const char_type* operator()(const M&)const$/;"	f	struct:boost::functor1	access:public	signature:(const M&) const
boost::functor1b	/usr/include/boost/regex/concepts.hpp	/^struct functor1b$/;"	s	namespace:boost
boost::functor1b::char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename M::char_type char_type;$/;"	t	struct:boost::functor1b	access:public
boost::functor1b::operator ()	/usr/include/boost/regex/concepts.hpp	/^   std::vector<char_type> operator()(const M&)const$/;"	f	struct:boost::functor1b	access:public	signature:(const M&) const
boost::functor2	/usr/include/boost/regex/concepts.hpp	/^struct functor2$/;"	s	namespace:boost
boost::functor2::operator ()	/usr/include/boost/regex/concepts.hpp	/^   O operator()(const M& \/*m*\/, O i)const$/;"	f	struct:boost::functor2	access:public	signature:(const M& , O i) const
boost::functor3	/usr/include/boost/regex/concepts.hpp	/^struct functor3$/;"	s	namespace:boost
boost::functor3::operator ()	/usr/include/boost/regex/concepts.hpp	/^   O operator()(const M& \/*m*\/, O i, regex_constants::match_flag_type)const$/;"	f	struct:boost::functor3	access:public	signature:(const M& , O i, regex_constants::match_flag_type) const
boost::geometry	/usr/include/boost/geometry/core/coordinate_system.hpp	/^namespace boost { namespace geometry$/;"	n	namespace:boost
boost::geometry::coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^struct coordinate_system$/;"	s	namespace:boost::geometry
boost::geometry::coordinate_system::ncg	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    typedef typename boost::remove_const<Geometry>::type ncg;$/;"	t	struct:boost::geometry::coordinate_system	access:public
boost::geometry::coordinate_system::type	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        >::type type;$/;"	t	struct:boost::geometry::coordinate_system	access:public
boost::geometry::core_dispatch	/usr/include/boost/geometry/core/coordinate_system.hpp	/^namespace core_dispatch$/;"	n	namespace:boost::geometry
boost::geometry::core_dispatch::coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    struct coordinate_system$/;"	s	namespace:boost::geometry::core_dispatch
boost::geometry::core_dispatch::coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    struct coordinate_system<point_tag, P>$/;"	s	namespace:boost::geometry::core_dispatch
boost::geometry::core_dispatch::coordinate_system::P	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        typedef typename point_type<GeometryTag, G>::type P;$/;"	t	struct:boost::geometry::core_dispatch::coordinate_system	access:public
boost::geometry::core_dispatch::coordinate_system::type	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        typedef typename coordinate_system<point_tag, P>::type type;$/;"	t	struct:boost::geometry::core_dispatch::coordinate_system	access:public
boost::geometry::core_dispatch::coordinate_system::type	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        typedef typename traits::coordinate_system<P>::type type;$/;"	t	struct:boost::geometry::core_dispatch::coordinate_system	access:public
boost::geometry::traits	/usr/include/boost/geometry/core/coordinate_system.hpp	/^namespace traits$/;"	n	namespace:boost::geometry
boost::geometry::traits::coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^struct coordinate_system$/;"	s	namespace:boost::geometry::traits
boost::geometry::traits::coordinate_system::BOOST_MPL_ASSERT_MSG	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    BOOST_MPL_ASSERT_MSG$/;"	p	struct:boost::geometry::traits::coordinate_system	access:public	signature:( false, NOT_IMPLEMENTED_FOR_THIS_POINT_TYPE, (types<Point>) )
boost::GrepCallback	/usr/include/boost/regex/v4/cregex.hpp	/^typedef bool (__cdecl *GrepCallback)(const RegEx& expression);$/;"	t	namespace:boost
boost::GrepFileCallback	/usr/include/boost/regex/v4/cregex.hpp	/^typedef bool (__cdecl *GrepFileCallback)(const char* file, const RegEx& expression);$/;"	t	namespace:boost
boost::hash_value	/usr/include/boost/regex/concepts.hpp	/^inline long hash_value(char_architype val)$/;"	f	namespace:boost	signature:(char_architype val)
boost::icu_regex_traits	/usr/include/boost/regex/icu.hpp	/^class BOOST_REGEX_DECL icu_regex_traits$/;"	c	namespace:boost
boost::icu_regex_traits::boost_extensions_tag	/usr/include/boost/regex/icu.hpp	/^   struct boost_extensions_tag{};$/;"	s	class:boost::icu_regex_traits	access:public
boost::icu_regex_traits::char_class_type	/usr/include/boost/regex/icu.hpp	/^   typedef boost::uint64_t              char_class_type;$/;"	t	class:boost::icu_regex_traits	access:public
boost::icu_regex_traits::char_class_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::bitset<64>              char_class_type;$/;"	t	class:boost::icu_regex_traits	access:public
boost::icu_regex_traits::char_type	/usr/include/boost/regex/icu.hpp	/^   typedef UChar32                      char_type;$/;"	t	class:boost::icu_regex_traits	access:public
boost::icu_regex_traits::error_string	/usr/include/boost/regex/icu.hpp	/^   std::string error_string(::boost::regex_constants::error_type n) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(::boost::regex_constants::error_type n) const
boost::icu_regex_traits::escape_syntax_type	/usr/include/boost/regex/icu.hpp	/^   ::boost::regex_constants::escape_syntax_type escape_syntax_type(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
boost::icu_regex_traits::getloc	/usr/include/boost/regex/icu.hpp	/^   locale_type getloc()const$/;"	f	class:boost::icu_regex_traits	access:public	signature:() const
boost::icu_regex_traits::icu_regex_traits	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits()$/;"	f	class:boost::icu_regex_traits	access:public	signature:()
boost::icu_regex_traits::icu_regex_traits	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits(const icu_regex_traits&);$/;"	p	class:boost::icu_regex_traits	access:private	signature:(const icu_regex_traits&)
boost::icu_regex_traits::imbue	/usr/include/boost/regex/icu.hpp	/^   locale_type imbue(locale_type l)$/;"	f	class:boost::icu_regex_traits	access:public	signature:(locale_type l)
boost::icu_regex_traits::isctype	/usr/include/boost/regex/icu.hpp	/^   bool isctype(char_type c, char_class_type f) const;$/;"	p	class:boost::icu_regex_traits	access:public	signature:(char_type c, char_class_type f) const
boost::icu_regex_traits::length	/usr/include/boost/regex/icu.hpp	/^   static size_type length(const char_type* p);$/;"	p	class:boost::icu_regex_traits	access:public	signature:(const char_type* p)
boost::icu_regex_traits::locale_type	/usr/include/boost/regex/icu.hpp	/^   typedef U_NAMESPACE_QUALIFIER Locale locale_type;$/;"	t	class:boost::icu_regex_traits	access:public
boost::icu_regex_traits::lookup_classname	/usr/include/boost/regex/icu.hpp	/^   char_class_type lookup_classname(const char_type* p1, const char_type* p2) const;$/;"	p	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
boost::icu_regex_traits::lookup_collatename	/usr/include/boost/regex/icu.hpp	/^   string_type lookup_collatename(const char_type* p1, const char_type* p2) const;$/;"	p	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
boost::icu_regex_traits::lookup_icu_mask	/usr/include/boost/regex/icu.hpp	/^   static char_class_type lookup_icu_mask(const ::UChar32* p1, const ::UChar32* p2);$/;"	p	class:boost::icu_regex_traits	access:private	signature:(const ::UChar32* p1, const ::UChar32* p2)
boost::icu_regex_traits::mask_any	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_any;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_ascii	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_ascii;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_blank	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_blank;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_horizontal	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_horizontal;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_space	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_space;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_underscore	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_underscore;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_unicode	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_unicode;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_vertical	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_vertical;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::mask_xdigit	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_xdigit;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::m_pimpl	/usr/include/boost/regex/icu.hpp	/^   boost::shared_ptr< ::boost::re_detail::icu_regex_traits_implementation> m_pimpl;$/;"	m	class:boost::icu_regex_traits	access:private
boost::icu_regex_traits::offset_any	/usr/include/boost/regex/icu.hpp	/^      offset_any = U_CHAR_CATEGORY_COUNT+5,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_ascii	/usr/include/boost/regex/icu.hpp	/^      offset_ascii = U_CHAR_CATEGORY_COUNT+6,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_blank	/usr/include/boost/regex/icu.hpp	/^      offset_blank = U_CHAR_CATEGORY_COUNT,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_horizontal	/usr/include/boost/regex/icu.hpp	/^      offset_horizontal = U_CHAR_CATEGORY_COUNT+7,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_space	/usr/include/boost/regex/icu.hpp	/^      offset_space = U_CHAR_CATEGORY_COUNT+1,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_underscore	/usr/include/boost/regex/icu.hpp	/^      offset_underscore = U_CHAR_CATEGORY_COUNT+3,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_unicode	/usr/include/boost/regex/icu.hpp	/^      offset_unicode = U_CHAR_CATEGORY_COUNT+4,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_vertical	/usr/include/boost/regex/icu.hpp	/^      offset_vertical = U_CHAR_CATEGORY_COUNT+8$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::offset_xdigit	/usr/include/boost/regex/icu.hpp	/^      offset_xdigit = U_CHAR_CATEGORY_COUNT+2,$/;"	e	enum:boost::icu_regex_traits::__anon1
boost::icu_regex_traits::operator =	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits& operator=(const icu_regex_traits&);$/;"	p	class:boost::icu_regex_traits	access:private	signature:(const icu_regex_traits&)
boost::icu_regex_traits::size_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::size_t                  size_type;$/;"	t	class:boost::icu_regex_traits	access:public
boost::icu_regex_traits::string_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::vector<char_type>       string_type;$/;"	t	class:boost::icu_regex_traits	access:public
boost::icu_regex_traits::syntax_type	/usr/include/boost/regex/icu.hpp	/^   ::boost::regex_constants::syntax_type syntax_type(char_type c)const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
boost::icu_regex_traits::toi	/usr/include/boost/regex/icu.hpp	/^   int toi(const char_type*& p1, const char_type* p2, int radix)const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(const char_type*& p1, const char_type* p2, int radix) const
boost::icu_regex_traits::tolower	/usr/include/boost/regex/icu.hpp	/^   char_type tolower(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
boost::icu_regex_traits::toupper	/usr/include/boost/regex/icu.hpp	/^   char_type toupper(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
boost::icu_regex_traits::transform	/usr/include/boost/regex/icu.hpp	/^   string_type transform(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
boost::icu_regex_traits::transform_primary	/usr/include/boost/regex/icu.hpp	/^   string_type transform_primary(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
boost::icu_regex_traits::translate	/usr/include/boost/regex/icu.hpp	/^   char_type translate(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
boost::icu_regex_traits::translate	/usr/include/boost/regex/icu.hpp	/^   char_type translate(char_type c, bool icase) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c, bool icase) const
boost::icu_regex_traits::translate_nocase	/usr/include/boost/regex/icu.hpp	/^   char_type translate_nocase(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
boost::icu_regex_traits::value	/usr/include/boost/regex/icu.hpp	/^   int value(char_type c, int radix)const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c, int radix) const
boost::iostreams	/usr/include/boost/iostreams/detail/system_failure.hpp	/^namespace boost { namespace iostreams { namespace detail {$/;"	n	namespace:boost
boost::iostreams	/usr/include/boost/iostreams/filter/regex.hpp	/^namespace boost { namespace iostreams {$/;"	n	namespace:boost
boost::iostreams::basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^class basic_regex_filter : public aggregate_filter<Ch, Alloc> {$/;"	c	namespace:boost::iostreams	inherits:aggregate_filter
boost::iostreams::basic_regex_filter::base_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef aggregate_filter<Ch, Alloc>                 base_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:private
boost::iostreams::basic_regex_filter::basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    basic_regex_filter( const regex_type& re,$/;"	f	class:boost::iostreams::basic_regex_filter	access:public	signature:( const regex_type& re, const char_type* fmt, flag_type flags = regex_constants::match_default, flag_type fmt_flags = regex_constants::format_default )
boost::iostreams::basic_regex_filter::basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    basic_regex_filter( const regex_type& re,$/;"	f	class:boost::iostreams::basic_regex_filter	access:public	signature:( const regex_type& re, const formatter& replace, flag_type flags = regex_constants::match_default )
boost::iostreams::basic_regex_filter::basic_regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    basic_regex_filter( const regex_type& re,$/;"	f	class:boost::iostreams::basic_regex_filter	access:public	signature:( const regex_type& re, const string_type& fmt, flag_type flags = regex_constants::match_default, flag_type fmt_flags = regex_constants::format_default )
boost::iostreams::basic_regex_filter::category	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef typename base_type::category               category;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
boost::iostreams::basic_regex_filter::char_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef typename base_type::char_type              char_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
boost::iostreams::basic_regex_filter::do_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    void do_filter(const vector_type& src, vector_type& dest)$/;"	f	class:boost::iostreams::basic_regex_filter	access:private	signature:(const vector_type& src, vector_type& dest)
boost::iostreams::basic_regex_filter::flags_	/usr/include/boost/iostreams/filter/regex.hpp	/^    flag_type   flags_;$/;"	m	class:boost::iostreams::basic_regex_filter	access:private
boost::iostreams::basic_regex_filter::flag_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef regex_constants::match_flag_type           flag_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
boost::iostreams::basic_regex_filter::formatter	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef function1<string_type, const match_type&>  formatter;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
boost::iostreams::basic_regex_filter::match_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef match_results<const Ch*>                   match_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
boost::iostreams::basic_regex_filter::regex_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef basic_regex<Ch, Tr>                        regex_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
boost::iostreams::basic_regex_filter::replace_	/usr/include/boost/iostreams/filter/regex.hpp	/^    formatter   replace_;$/;"	m	class:boost::iostreams::basic_regex_filter	access:private
boost::iostreams::basic_regex_filter::re_	/usr/include/boost/iostreams/filter/regex.hpp	/^    regex_type  re_;$/;"	m	class:boost::iostreams::basic_regex_filter	access:private
boost::iostreams::basic_regex_filter::simple_formatter	/usr/include/boost/iostreams/filter/regex.hpp	/^    struct simple_formatter {$/;"	s	class:boost::iostreams::basic_regex_filter	access:private
boost::iostreams::basic_regex_filter::simple_formatter::fmt_	/usr/include/boost/iostreams/filter/regex.hpp	/^        string_type  fmt_;$/;"	m	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public
boost::iostreams::basic_regex_filter::simple_formatter::fmt_flags_	/usr/include/boost/iostreams/filter/regex.hpp	/^        flag_type    fmt_flags_;$/;"	m	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public
boost::iostreams::basic_regex_filter::simple_formatter::operator ()	/usr/include/boost/iostreams/filter/regex.hpp	/^        string_type operator() (const match_type& match) const$/;"	f	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public	signature:(const match_type& match) const
boost::iostreams::basic_regex_filter::simple_formatter::simple_formatter	/usr/include/boost/iostreams/filter/regex.hpp	/^        simple_formatter(const string_type& fmt, flag_type fmt_flags) $/;"	f	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public	signature:(const string_type& fmt, flag_type fmt_flags)
boost::iostreams::basic_regex_filter::string_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef std::basic_string<Ch>                      string_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
boost::iostreams::basic_regex_filter::vector_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef typename base_type::vector_type       vector_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:private
boost::iostreams::detail	/usr/include/boost/iostreams/detail/system_failure.hpp	/^namespace boost { namespace iostreams { namespace detail {$/;"	n	namespace:boost::iostreams
boost::iostreams::detail::system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline BOOST_IOSTREAMS_FAILURE system_failure(const char* msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const char* msg)
boost::iostreams::detail::system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline BOOST_IOSTREAMS_FAILURE system_failure(const std::string& msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const std::string& msg)
boost::iostreams::detail::throw_system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline void throw_system_failure(const char* msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const char* msg)
boost::iostreams::detail::throw_system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline void throw_system_failure(const std::string& msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const std::string& msg)
boost::iostreams::regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^typedef basic_regex_filter<char>     regex_filter;$/;"	t	namespace:boost::iostreams
boost::iostreams::wregex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^typedef basic_regex_filter<wchar_t>  wregex_filter;$/;"	t	namespace:boost::iostreams
boost::is_random_access_iterator	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_access_iterator$/;"	s	namespace:boost
boost::is_random_access_iterator::answer	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef typename bound_type::type answer;$/;"	t	struct:boost::is_random_access_iterator	access:private
boost::is_random_access_iterator::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/iterator_category.hpp	/^   BOOST_STATIC_CONSTANT(bool, value = answer::value);$/;"	p	struct:boost::is_random_access_iterator	access:public	signature:(bool, value = answer::value)
boost::is_random_access_iterator::bound_type	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef typename selector::template rebind<I> bound_type;$/;"	t	struct:boost::is_random_access_iterator	access:private
boost::is_random_access_iterator::selector	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef detail::is_random_imp_selector< ::boost::is_pointer<I>::value> selector;$/;"	t	struct:boost::is_random_access_iterator	access:private
boost::is_random_access_iterator::value	/usr/include/boost/regex/v4/iterator_category.hpp	/^const bool is_random_access_iterator<I>::value;$/;"	m	class:boost::is_random_access_iterator
boost::make_regex	/usr/include/boost/regex/mfc.hpp	/^make_regex(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, ::boost::regex_constants::syntax_option_type f = boost::regex_constants::normal)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, ::boost::regex_constants::syntax_option_type f = boost::regex_constants::normal)
boost::make_regex_iterator	/usr/include/boost/regex/mfc.hpp	/^make_regex_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::make_regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^inline regex_iterator<const charT*, charT, traits> make_regex_iterator(const charT* p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^inline regex_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^   make_regex_token_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, int sub = 0, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, int sub = 0, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^make_regex_token_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const int (& subs)[N], ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const int (& subs)[N], ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^make_regex_token_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const std::vector<int>& subs, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const std::vector<int>& subs, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
boost::make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const std::basic_string<C, T, A>& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const std::basic_string<C, T, A>& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
boost::make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const UChar* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const UChar* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
boost::make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const unsigned char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const unsigned char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
boost::make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const U_NAMESPACE_QUALIFIER UnicodeString& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
boost::make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const wchar_t* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const wchar_t* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
boost::make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(InputIterator i, $/;"	f	namespace:boost	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt)
boost::make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const char*> make_u32regex_iterator(const char* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const UChar*> make_u32regex_iterator(const UChar* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const UChar*> make_u32regex_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const wchar_t*> make_u32regex_iterator(const wchar_t* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
boost::make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
boost::match_results	/usr/include/boost/regex/v4/instances.hpp	/^template class BOOST_REGEX_DECL match_results< const BOOST_REGEX_CHAR_T* >;$/;"	m	namespace:boost	typeref:class:boost::BOOST_REGEX_DECL
boost::match_results	/usr/include/boost/regex/v4/match_results.hpp	/^class match_results$/;"	c	namespace:boost
boost::match_results::allocator_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          Allocator                                               allocator_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::base	/usr/include/boost/regex/v4/match_results.hpp	/^   BidiIterator base()const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::begin	/usr/include/boost/regex/v4/match_results.hpp	/^   const_iterator begin() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::captures	/usr/include/boost/regex/v4/match_results.hpp	/^   const capture_sequence_type& captures(int i)const$/;"	f	class:boost::match_results	access:public	signature:(int i) const
boost::match_results::capture_sequence_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename sub_match<BidiIterator>::capture_sequence_type capture_sequence_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::char_type	/usr/include/boost/regex/v4/match_results.hpp	/^                                    BidiIterator>::value_type               char_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::const_iterator	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename vector_type::const_iterator                             const_iterator;$/;"	t	class:boost::match_results	access:public
boost::match_results::const_reference	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          const value_type&                                       const_reference;$/;"	t	class:boost::match_results	access:public
boost::match_results::const_reference	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename Allocator::const_reference                              const_reference;$/;"	t	class:boost::match_results	access:public
boost::match_results::difference_type	/usr/include/boost/regex/v4/match_results.hpp	/^                                    BidiIterator>::difference_type          difference_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::empty	/usr/include/boost/regex/v4/match_results.hpp	/^   bool empty() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::end	/usr/include/boost/regex/v4/match_results.hpp	/^   const_iterator end() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::format	/usr/include/boost/regex/v4/match_results.hpp	/^   OutputIterator format(OutputIterator out,$/;"	f	class:boost::match_results	access:public	signature:(OutputIterator out, Functor fmt, match_flag_type flags = format_default) const
boost::match_results::format	/usr/include/boost/regex/v4/match_results.hpp	/^   OutputIterator format(OutputIterator out,$/;"	f	class:boost::match_results	access:public	signature:(OutputIterator out, Functor fmt, match_flag_type flags, const RegexT& re) const
boost::match_results::format	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type format(Functor fmt, match_flag_type flags = format_default) const$/;"	f	class:boost::match_results	access:public	signature:(Functor fmt, match_flag_type flags = format_default) const
boost::match_results::format	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type format(Functor fmt,$/;"	f	class:boost::match_results	access:public	signature:(Functor fmt, match_flag_type flags, const RegexT& re) const
boost::match_results::get_allocator	/usr/include/boost/regex/v4/match_results.hpp	/^   allocator_type get_allocator() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::get_last_closed_paren	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference get_last_closed_paren()const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::iterator	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          const_iterator                                          iterator;$/;"	t	class:boost::match_results	access:public
boost::match_results::length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(const charT* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* sub) const
boost::match_results::length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(const char_type* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* sub) const
boost::match_results::length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(const std::basic_string<charT, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& sub) const
boost::match_results::length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(int sub = 0) const$/;"	f	class:boost::match_results	access:public	signature:(int sub = 0) const
boost::match_results::match_results	/usr/include/boost/regex/v4/match_results.hpp	/^   explicit match_results(const Allocator& a = Allocator())$/;"	f	class:boost::match_results	access:public	signature:(const Allocator& a = Allocator())
boost::match_results::match_results	/usr/include/boost/regex/v4/match_results.hpp	/^   match_results(const match_results& m)$/;"	f	class:boost::match_results	access:public	signature:(const match_results& m)
boost::match_results::max_size	/usr/include/boost/regex/v4/match_results.hpp	/^   size_type max_size() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::maybe_assign	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL maybe_assign(const match_results<BidiIterator, Allocator>& m);$/;"	p	class:boost::match_results	access:public	signature:(const match_results<BidiIterator, Allocator>& m)
boost::match_results::maybe_assign	/usr/include/boost/regex/v4/match_results.hpp	/^void BOOST_REGEX_CALL match_results<BidiIterator, Allocator>::maybe_assign(const match_results<BidiIterator, Allocator>& m)$/;"	f	class:boost::match_results	signature:(const match_results<BidiIterator, Allocator>& m)
boost::match_results::m_base	/usr/include/boost/regex/v4/match_results.hpp	/^   BidiIterator   m_base;                              \/\/ where the search started from$/;"	m	class:boost::match_results	access:private
boost::match_results::m_is_singular	/usr/include/boost/regex/v4/match_results.hpp	/^   bool m_is_singular;                                 \/\/ True if our stored iterators are singular$/;"	m	class:boost::match_results	access:private
boost::match_results::m_last_closed_paren	/usr/include/boost/regex/v4/match_results.hpp	/^   int m_last_closed_paren;                            \/\/ Last ) to be seen - used for formatting$/;"	m	class:boost::match_results	access:private
boost::match_results::m_named_subs	/usr/include/boost/regex/v4/match_results.hpp	/^   boost::shared_ptr<named_sub_type> m_named_subs;     \/\/ Shared copy of named subs in the regex object$/;"	m	class:boost::match_results	access:private
boost::match_results::m_null	/usr/include/boost/regex/v4/match_results.hpp	/^   sub_match<BidiIterator> m_null;                     \/\/ a null match$/;"	m	class:boost::match_results	access:private
boost::match_results::m_subs	/usr/include/boost/regex/v4/match_results.hpp	/^   vector_type            m_subs;                      \/\/ subexpressions$/;"	m	class:boost::match_results	access:private
boost::match_results::named_subexpression	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference named_subexpression(const charT* i, const charT* j) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* i, const charT* j) const
boost::match_results::named_subexpression	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference named_subexpression(const char_type* i, const char_type* j) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* i, const char_type* j) const
boost::match_results::named_subexpression_index	/usr/include/boost/regex/v4/match_results.hpp	/^   int named_subexpression_index(const charT* i, const charT* j) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* i, const charT* j) const
boost::match_results::named_subexpression_index	/usr/include/boost/regex/v4/match_results.hpp	/^   int named_subexpression_index(const char_type* i, const char_type* j) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* i, const char_type* j) const
boost::match_results::named_sub_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          re_detail::named_subexpressions                         named_sub_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::operator !=	/usr/include/boost/regex/v4/match_results.hpp	/^   bool operator!=(const match_results& that)const$/;"	f	class:boost::match_results	access:public	signature:(const match_results& that) const
boost::match_results::operator =	/usr/include/boost/regex/v4/match_results.hpp	/^   match_results& operator=(const match_results& m)$/;"	f	class:boost::match_results	access:public	signature:(const match_results& m)
boost::match_results::operator ==	/usr/include/boost/regex/v4/match_results.hpp	/^   bool operator==(const match_results& that)const$/;"	f	class:boost::match_results	access:public	signature:(const match_results& that) const
boost::match_results::operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const charT* p) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* p) const
boost::match_results::operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const char_type* p) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* p) const
boost::match_results::operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const std::basic_string<charT, Traits, A>& ns) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& ns) const
boost::match_results::operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const std::basic_string<char_type, Traits, A>& s) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<char_type, Traits, A>& s) const
boost::match_results::operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](int sub) const$/;"	f	class:boost::match_results	access:public	signature:(int sub) const
boost::match_results::position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(const charT* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* sub) const
boost::match_results::position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(const char_type* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* sub) const
boost::match_results::position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(const std::basic_string<charT, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& sub) const
boost::match_results::position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(size_type sub = 0) const$/;"	f	class:boost::match_results	access:public	signature:(size_type sub = 0) const
boost::match_results::prefix	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference prefix() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::raise_logic_error	/usr/include/boost/regex/v4/match_results.hpp	/^   static void raise_logic_error()$/;"	f	class:boost::match_results	access:private	signature:()
boost::match_results::reference	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          const_reference                                         reference;$/;"	t	class:boost::match_results	access:public
boost::match_results::set_base	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_base(BidiIterator pos)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator pos)
boost::match_results::set_first	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_first(BidiIterator i)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i)
boost::match_results::set_first	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_first(BidiIterator i, size_type pos, bool escape_k = false)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i, size_type pos, bool escape_k = false)
boost::match_results::set_named_subs	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_named_subs(boost::shared_ptr<named_sub_type> subs)$/;"	f	class:boost::match_results	access:public	signature:(boost::shared_ptr<named_sub_type> subs)
boost::match_results::set_second	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_second(BidiIterator i)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i)
boost::match_results::set_second	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_second(BidiIterator i, size_type pos, bool m = true, bool escape_k = false)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i, size_type pos, bool m = true, bool escape_k = false)
boost::match_results::set_size	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_size(size_type n, BidiIterator i, BidiIterator j)$/;"	f	class:boost::match_results	access:public	signature:(size_type n, BidiIterator i, BidiIterator j)
boost::match_results::size	/usr/include/boost/regex/v4/match_results.hpp	/^   size_type size() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::size_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename Allocator::size_type                                    size_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const charT* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* sub) const
boost::match_results::str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const char_type* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* sub) const
boost::match_results::str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const std::basic_string<charT, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& sub) const
boost::match_results::str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const std::basic_string<char_type, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<char_type, Traits, A>& sub) const
boost::match_results::str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(int sub = 0) const$/;"	f	class:boost::match_results	access:public	signature:(int sub = 0) const
boost::match_results::string_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          std::basic_string<char_type>                            string_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::suffix	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference suffix() const$/;"	f	class:boost::match_results	access:public	signature:() const
boost::match_results::swap	/usr/include/boost/regex/v4/match_results.hpp	/^   void swap(match_results& that)$/;"	f	class:boost::match_results	access:public	signature:(match_results& that)
boost::match_results::value_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          sub_match<BidiIterator>                         value_type;$/;"	t	class:boost::match_results	access:public
boost::match_results::vector_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          std::vector<sub_match<BidiIterator>, Allocator> vector_type;$/;"	t	class:boost::match_results	access:private
boost::match_results::~match_results	/usr/include/boost/regex/v4/match_results.hpp	/^   ~match_results(){}$/;"	f	class:boost::match_results	access:public	signature:()
boost::mpl	/usr/include/boost/units/heterogeneous_system.hpp	/^namespace mpl {$/;"	n	namespace:boost
boost::mpl::divides_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct divides_impl<boost::units::heterogeneous_system_dim_tag, boost::units::detail::static_rational_tag>$/;"	s	namespace:boost::mpl
boost::mpl::divides_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::divides_impl	access:public
boost::mpl::divides_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        > type;$/;"	t	struct:boost::mpl::divides_impl::apply	access:public
boost::mpl::less_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct less_impl<boost::units::heterogeneous_system_dim_tag, boost::units::heterogeneous_system_dim_tag>$/;"	s	namespace:boost::mpl
boost::mpl::less_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply : mpl::less<typename T0::tag_type, typename T1::tag_type> {};$/;"	s	struct:boost::mpl::less_impl	inherits:mpl::less	access:public
boost::mpl::negate_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct negate_impl<boost::units::heterogeneous_system_dim_tag>$/;"	s	namespace:boost::mpl
boost::mpl::negate_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::negate_impl	access:public
boost::mpl::negate_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef boost::units::heterogeneous_system_dim<typename T::tag_type, typename mpl::negate<typename T::value_type>::type> type;$/;"	t	struct:boost::mpl::negate_impl::apply	access:public
boost::mpl::plus_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct plus_impl<boost::units::heterogeneous_system_dim_tag, boost::units::heterogeneous_system_dim_tag>$/;"	s	namespace:boost::mpl
boost::mpl::plus_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::plus_impl	access:public
boost::mpl::plus_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        > type;$/;"	t	struct:boost::mpl::plus_impl::apply	access:public
boost::mpl::times_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct times_impl<boost::units::heterogeneous_system_dim_tag, boost::units::detail::static_rational_tag>$/;"	s	namespace:boost::mpl
boost::mpl::times_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::mpl::times_impl	access:public
boost::mpl::times_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        > type;$/;"	t	struct:boost::mpl::times_impl::apply	access:public
boost::object_cache	/usr/include/boost/regex/pending/object_cache.hpp	/^class object_cache$/;"	c	namespace:boost
boost::object_cache::data	/usr/include/boost/regex/pending/object_cache.hpp	/^   struct data$/;"	s	class:boost::object_cache	access:private
boost::object_cache::data::cont	/usr/include/boost/regex/pending/object_cache.hpp	/^      list_type   cont;$/;"	m	struct:boost::object_cache::data	access:public
boost::object_cache::data::index	/usr/include/boost/regex/pending/object_cache.hpp	/^      map_type    index;$/;"	m	struct:boost::object_cache::data	access:public
boost::object_cache::do_get	/usr/include/boost/regex/pending/object_cache.hpp	/^   static boost::shared_ptr<Object const> do_get(const Key& k, size_type l_max_cache_size);$/;"	p	class:boost::object_cache	access:private	signature:(const Key& k, size_type l_max_cache_size)
boost::object_cache::do_get	/usr/include/boost/regex/pending/object_cache.hpp	/^boost::shared_ptr<Object const> object_cache<Key, Object>::do_get(const Key& k, size_type l_max_cache_size)$/;"	f	class:boost::object_cache	signature:(const Key& k, size_type l_max_cache_size)
boost::object_cache::get	/usr/include/boost/regex/pending/object_cache.hpp	/^   static boost::shared_ptr<Object const> get(const Key& k, size_type l_max_cache_size);$/;"	p	class:boost::object_cache	access:public	signature:(const Key& k, size_type l_max_cache_size)
boost::object_cache::get	/usr/include/boost/regex/pending/object_cache.hpp	/^boost::shared_ptr<Object const> object_cache<Key, Object>::get(const Key& k, size_type l_max_cache_size)$/;"	f	class:boost::object_cache	signature:(const Key& k, size_type l_max_cache_size)
boost::object_cache::list_iterator	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef typename list_type::iterator list_iterator;$/;"	t	class:boost::object_cache	access:public
boost::object_cache::list_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef std::list<value_type> list_type;$/;"	t	class:boost::object_cache	access:public
boost::object_cache::map_iterator	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef typename map_type::iterator map_iterator;$/;"	t	class:boost::object_cache	access:public
boost::object_cache::map_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef std::map<Key, list_iterator> map_type;$/;"	t	class:boost::object_cache	access:public
boost::object_cache::size_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef typename list_type::size_type size_type;$/;"	t	class:boost::object_cache	access:public
boost::object_cache::value_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef std::pair< ::boost::shared_ptr<Object const>, Key const*> value_type;$/;"	t	class:boost::object_cache	access:public
boost::operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
boost::operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
boost::operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
boost::operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
boost::operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
boost::operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
boost::operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
boost::operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
boost::operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const * s)
boost::operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
boost::operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m1,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m1, const sub_match<RandomAccessIterator>& m2)
boost::operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
boost::operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
boost::operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
boost::operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
boost::operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
boost::operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
boost::operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
boost::operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
boost::operator <<	/usr/include/boost/regex/v4/basic_regex.hpp	/^   operator << (std::basic_ostream<charT, traits>& os, $/;"	f	namespace:boost	signature:(std::basic_ostream<charT, traits>& os, const basic_regex<charT, traits2>& e)
boost::operator <<	/usr/include/boost/regex/v4/basic_regex.hpp	/^std::ostream& operator << (std::ostream& os, const basic_regex<char, traits>& e)$/;"	f	namespace:boost	signature:(std::ostream& os, const basic_regex<char, traits>& e)
boost::operator <<	/usr/include/boost/regex/v4/match_results.hpp	/^   operator << (std::basic_ostream<charT, traits>& os,$/;"	f	namespace:boost	signature:(std::basic_ostream<charT, traits>& os, const match_results<BidiIterator, Allocator>& s)
boost::operator <<	/usr/include/boost/regex/v4/match_results.hpp	/^std::ostream& operator << (std::ostream& os,$/;"	f	namespace:boost	signature:(std::ostream& os, const match_results<BidiIterator, Allocator>& s)
boost::operator <<	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator << (std::basic_ostream<charT, traits>& os,$/;"	f	namespace:boost	signature:(std::basic_ostream<charT, traits>& os, const sub_match<RandomAccessIterator>& s)
boost::operator <<	/usr/include/boost/regex/v4/sub_match.hpp	/^std::ostream& operator << (std::ostream& os,$/;"	f	namespace:boost	signature:(std::ostream& os, const sub_match<RandomAccessIterator>& s)
boost::operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
boost::operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
boost::operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
boost::operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
boost::operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
boost::operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
boost::operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
boost::operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
boost::operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
boost::operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
boost::operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
boost::operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
boost::operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
boost::operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
boost::operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
boost::operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
boost::operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
boost::operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
boost::operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
boost::operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
boost::operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
boost::operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
boost::operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
boost::operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
boost::posix_time	/usr/include/boost/date_time/posix_time/posix_time_system.hpp	/^namespace posix_time { $/;"	n	namespace:boost
boost::posix_time::posix_time_system	/usr/include/boost/date_time/posix_time/posix_time_system.hpp	/^  typedef date_time::split_timedate_system<posix_time_system_config, 1000000000> posix_time_system;$/;"	t	namespace:boost::posix_time
boost::regbase	/usr/include/boost/regex/v4/regbase.hpp	/^class BOOST_REGEX_DECL regbase$/;"	c	namespace:boost
boost::regbase::awk	/usr/include/boost/regex/v4/regbase.hpp	/^      awk = no_bk_refs | collate | no_perl_ex,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::basic	/usr/include/boost/regex/v4/regbase.hpp	/^      basic = basic_syntax_group | collate | no_escape_in_lists,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::basic_syntax_group	/usr/include/boost/regex/v4/regbase.hpp	/^      basic_syntax_group = 1,                     \/\/ POSIX basic$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::bk_plus_qm	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_plus_qm = 1 << 10,                       \/\/ uses \\+ and \\?$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::bk_vbar	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_vbar = 1 << 11,                          \/\/ use \\| for alternatives$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::collate	/usr/include/boost/regex/v4/regbase.hpp	/^      collate = 1 << 21,                                \/\/ use locale specific collation$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::ECMAScript	/usr/include/boost/regex/v4/regbase.hpp	/^      ECMAScript = normal,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::egrep	/usr/include/boost/regex/v4/regbase.hpp	/^      egrep = extended | newline_alt,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::emacs	/usr/include/boost/regex/v4/regbase.hpp	/^      emacs = basic_syntax_group | collate | emacs_ex | bk_vbar,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::emacs_ex	/usr/include/boost/regex/v4/regbase.hpp	/^      emacs_ex = 1 << 12,                         \/\/ enables emacs extensions$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::extended	/usr/include/boost/regex/v4/regbase.hpp	/^      extended = no_bk_refs | collate | no_perl_ex | no_escape_in_lists,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::failbit	/usr/include/boost/regex/v4/regbase.hpp	/^      failbit = 1 << 19,                                \/\/ error flag$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::flag_type	/usr/include/boost/regex/v4/regbase.hpp	/^   typedef unsigned int flag_type;$/;"	t	class:boost::regbase	access:public
boost::regbase::flag_type_	/usr/include/boost/regex/v4/regbase.hpp	/^   enum flag_type_$/;"	g	class:boost::regbase	access:public
boost::regbase::grep	/usr/include/boost/regex/v4/regbase.hpp	/^      grep = basic | newline_alt,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::icase	/usr/include/boost/regex/v4/regbase.hpp	/^      icase = 1 << 20,                                  \/\/ characters are matched regardless of case$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::JavaScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JavaScript = normal,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::JScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JScript = normal$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::literal	/usr/include/boost/regex/v4/regbase.hpp	/^      literal = 2,                                \/\/ all characters are literals$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::main_option_type	/usr/include/boost/regex/v4/regbase.hpp	/^      main_option_type = literal | basic_syntax_group | perl_syntax_group, \/\/ everything!$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_s = 1 << 12,                            \/\/ force s modifier on (overrides match_not_dot_newline)$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::mod_x	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_x = 1 << 11,                            \/\/ Perl x modifier$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::newline_alt	/usr/include/boost/regex/v4/regbase.hpp	/^      newline_alt = 1 << 17,                            \/\/ \\n is the same as |$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::nocollate	/usr/include/boost/regex/v4/regbase.hpp	/^      nocollate = 0,                                    \/\/ don't use locale specific collation (deprecated)$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::normal	/usr/include/boost/regex/v4/regbase.hpp	/^      normal = 0,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::nosubs	/usr/include/boost/regex/v4/regbase.hpp	/^      nosubs = 1 << 22,                                 \/\/ don't mark sub-expressions$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_bk_refs	/usr/include/boost/regex/v4/regbase.hpp	/^      no_bk_refs = 1 << 8,                        \/\/ \\d not allowed$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_char_classes	/usr/include/boost/regex/v4/regbase.hpp	/^      no_char_classes = 1 << 8,                   \/\/ [[:CLASS:]] not allowed$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_empty_expressions	/usr/include/boost/regex/v4/regbase.hpp	/^      no_empty_expressions = 1 << 24,                   \/\/ no empty expressions allowed$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_escape_in_lists	/usr/include/boost/regex/v4/regbase.hpp	/^      no_escape_in_lists = 1 << 16,                     \/\/ '\\' not special inside [...]$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_except	/usr/include/boost/regex/v4/regbase.hpp	/^      no_except = 1 << 18,                              \/\/ no exception on error$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_intervals	/usr/include/boost/regex/v4/regbase.hpp	/^      no_intervals = 1 << 9,                      \/\/ {x,y} not allowed$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_mod_m	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_m = 1 << 10,                         \/\/ disable Perl m modifier$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_s = 1 << 13,                         \/\/ force s modifier off (overrides match_not_dot_newline)$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::no_perl_ex	/usr/include/boost/regex/v4/regbase.hpp	/^      no_perl_ex = 1 << 9,                        \/\/ disable perl extensions$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::optimize	/usr/include/boost/regex/v4/regbase.hpp	/^      optimize = 0,                                     \/\/ not really supported$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::perl	/usr/include/boost/regex/v4/regbase.hpp	/^      perl = normal,$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::perl_syntax_group	/usr/include/boost/regex/v4/regbase.hpp	/^      perl_syntax_group = 0,                      \/\/ default$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::restart_any	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_any = 0,$/;"	e	enum:boost::regbase::restart_info
boost::regbase::restart_buf	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_buf = 3,$/;"	e	enum:boost::regbase::restart_info
boost::regbase::restart_continue	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_continue = 4,$/;"	e	enum:boost::regbase::restart_info
boost::regbase::restart_count	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_count = 7$/;"	e	enum:boost::regbase::restart_info
boost::regbase::restart_fixed_lit	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_fixed_lit = 6, $/;"	e	enum:boost::regbase::restart_info
boost::regbase::restart_info	/usr/include/boost/regex/v4/regbase.hpp	/^   enum restart_info$/;"	g	class:boost::regbase	access:public
boost::regbase::restart_line	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_line = 2,$/;"	e	enum:boost::regbase::restart_info
boost::regbase::restart_lit	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_lit = 5,$/;"	e	enum:boost::regbase::restart_info
boost::regbase::restart_word	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_word = 1,$/;"	e	enum:boost::regbase::restart_info
boost::regbase::save_subexpression_location	/usr/include/boost/regex/v4/regbase.hpp	/^      save_subexpression_location = 1 << 23,            \/\/ save subexpression locations$/;"	e	enum:boost::regbase::flag_type_
boost::regbase::sed	/usr/include/boost/regex/v4/regbase.hpp	/^      sed = basic,$/;"	e	enum:boost::regbase::flag_type_
boost::regcompA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regcompA(regex_tA*, const char*, int);$/;"	p	signature:(regex_tA*, const char*, int)
boost::regcompW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regcompW(regex_tW*, const wchar_t*, int);$/;"	p	signature:(regex_tW*, const wchar_t*, int)
boost::regerrorA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL regsize_t BOOST_REGEX_CCALL regerrorA(int, const regex_tA*, char*, regsize_t);$/;"	p	signature:(int, const regex_tA*, char*, regsize_t)
boost::regerrorW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL regsize_t BOOST_REGEX_CCALL regerrorW(int, const regex_tW*, wchar_t*, regsize_t);$/;"	p	signature:(int, const regex_tW*, wchar_t*, regsize_t)
boost::RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^class BOOST_REGEX_DECL RegEx$/;"	c	namespace:boost
boost::regex	/usr/include/boost/regex/v4/regex.hpp	/^typedef basic_regex<char, regex_traits<char> > regex;$/;"	t	namespace:boost
boost::regex	/usr/include/boost/regex/v4/regex_fwd.hpp	/^typedef basic_regex<char, regex_traits<char> > regex;$/;"	t	namespace:boost
boost::RegEx::error_code	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int error_code()const;$/;"	p	class:boost::RegEx	access:public	signature:() const
boost::RegEx::Expression	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string Expression()const;$/;"	p	class:boost::RegEx	access:public	signature:() const
boost::RegEx::FindFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int FindFiles(FindFilesCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(FindFilesCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default)
boost::RegEx::FindFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int FindFiles(FindFilesCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default) { return FindFiles(cb, files.c_str(), recurse, flags); }$/;"	f	class:boost::RegEx	access:public	signature:(FindFilesCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default)
boost::RegEx::Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(GrepCallback cb, const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(GrepCallback cb, const char* p, match_flag_type flags = match_default)
boost::RegEx::Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(GrepCallback cb, const std::string& s, match_flag_type flags = match_default) { return Grep(cb, s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(GrepCallback cb, const std::string& s, match_flag_type flags = match_default)
boost::RegEx::Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::size_t>& v, const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(std::vector<std::size_t>& v, const char* p, match_flag_type flags = match_default)
boost::RegEx::Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::size_t>& v, const std::string& s, match_flag_type flags = match_default) { return Grep(v, s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(std::vector<std::size_t>& v, const std::string& s, match_flag_type flags = match_default)
boost::RegEx::Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::string>& v, const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(std::vector<std::string>& v, const char* p, match_flag_type flags = match_default)
boost::RegEx::Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::string>& v, const std::string& s, match_flag_type flags = match_default) { return Grep(v, s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(std::vector<std::string>& v, const std::string& s, match_flag_type flags = match_default)
boost::RegEx::GrepFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int GrepFiles(GrepFileCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(GrepFileCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default)
boost::RegEx::GrepFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int GrepFiles(GrepFileCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default) { return GrepFiles(cb, files.c_str(), recurse, flags); }$/;"	f	class:boost::RegEx	access:public	signature:(GrepFileCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default)
boost::RegEx::Length	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Length(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
boost::RegEx::Marks	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Marks()const;$/;"	p	class:boost::RegEx	access:public	signature:() const
boost::RegEx::Match	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Match(const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p, match_flag_type flags = match_default)
boost::RegEx::Match	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Match(const std::string& s, match_flag_type flags = match_default) { return Match(s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s, match_flag_type flags = match_default)
boost::RegEx::Matched	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Matched(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
boost::RegEx::Merge	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string Merge(const char* in, const char* fmt,$/;"	p	class:boost::RegEx	access:public	signature:(const char* in, const char* fmt, bool copy = true, match_flag_type flags = match_default)
boost::RegEx::Merge	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string Merge(const std::string& in, const std::string& fmt,$/;"	p	class:boost::RegEx	access:public	signature:(const std::string& in, const std::string& fmt, bool copy = true, match_flag_type flags = match_default)
boost::RegEx::npos	/usr/include/boost/regex/v4/cregex.hpp	/^   static const std::size_t npos;$/;"	m	class:boost::RegEx	access:public
boost::RegEx::operator =	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx& operator=(const char* p);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p)
boost::RegEx::operator =	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx& operator=(const RegEx& o);$/;"	p	class:boost::RegEx	access:public	signature:(const RegEx& o)
boost::RegEx::operator =	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx& operator=(const std::string& s){ return this->operator=(s.c_str()); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s)
boost::RegEx::operator []	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string operator[](int i)const { return What(i); }$/;"	f	class:boost::RegEx	access:public	signature:(int i) const
boost::RegEx::pdata	/usr/include/boost/regex/v4/cregex.hpp	/^   re_detail::RegExData* pdata;$/;"	m	class:boost::RegEx	access:private
boost::RegEx::Position	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Position(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
boost::RegEx::RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   explicit RegEx(const char* c, bool icase = false);$/;"	p	class:boost::RegEx	access:public	signature:(const char* c, bool icase = false)
boost::RegEx::RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   explicit RegEx(const std::string& s, bool icase = false);$/;"	p	class:boost::RegEx	access:public	signature:(const std::string& s, bool icase = false)
boost::RegEx::RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx();$/;"	p	class:boost::RegEx	access:public	signature:()
boost::RegEx::RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx(const RegEx& o);$/;"	p	class:boost::RegEx	access:public	signature:(const RegEx& o)
boost::RegEx::Search	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Search(const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p, match_flag_type flags = match_default)
boost::RegEx::Search	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Search(const std::string& s, match_flag_type flags = match_default) { return Search(s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s, match_flag_type flags = match_default)
boost::RegEx::SetExpression	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int SetExpression(const char* p, bool icase = false);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p, bool icase = false)
boost::RegEx::SetExpression	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int SetExpression(const std::string& s, bool icase = false){ return SetExpression(s.c_str(), icase); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s, bool icase = false)
boost::RegEx::Split	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Split(std::vector<std::string>& v, std::string& s, match_flag_type flags = match_default, unsigned max_count = ~0);$/;"	p	class:boost::RegEx	access:public	signature:(std::vector<std::string>& v, std::string& s, match_flag_type flags = match_default, unsigned max_count = ~0)
boost::RegEx::What	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string What(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
boost::RegEx::~RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   ~RegEx();$/;"	p	class:boost::RegEx	access:public	signature:()
boost::RegexConcept	/usr/include/boost/regex/concepts.hpp	/^struct RegexConcept$/;"	s	namespace:boost
boost::RegexConcept::BidiIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef boost::bidirectional_iterator_archetype<value_type> BidiIterator;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::RegexConcept	access:public	signature:()
boost::RegexConcept::flag_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::flag_type flag_type;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::locale_type locale_type;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::match_results_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_char	/usr/include/boost/regex/concepts.hpp	/^   value_type m_char;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_cresults	/usr/include/boost/regex/concepts.hpp	/^   const match_results_type m_cresults;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_flags	/usr/include/boost/regex/concepts.hpp	/^   flag_type m_flags;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_in	/usr/include/boost/regex/concepts.hpp	/^   BidiIterator m_in;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_mft	/usr/include/boost/regex/concepts.hpp	/^   global_regex_namespace::regex_constants::match_flag_type m_mft;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_out	/usr/include/boost/regex/concepts.hpp	/^   OutIterator m_out;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_pointer	/usr/include/boost/regex/concepts.hpp	/^   pointer_type m_pointer;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_results	/usr/include/boost/regex/concepts.hpp	/^   match_results_type m_results;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_smatch	/usr/include/boost/regex/concepts.hpp	/^   global_regex_namespace::match_results<typename string_type::const_iterator, allocator_architype<global_regex_namespace::sub_match<typename string_type::const_iterator> > > m_smatch;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_string	/usr/include/boost/regex/concepts.hpp	/^   string_type m_string;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::m_sub	/usr/include/boost/regex/concepts.hpp	/^   const sub_match_type m_sub;$/;"	m	struct:boost::RegexConcept	access:public
boost::RegexConcept::operator =	/usr/include/boost/regex/concepts.hpp	/^   RegexConcept& operator=(const RegexConcept&);$/;"	p	struct:boost::RegexConcept	access:public	signature:(const RegexConcept&)
boost::RegexConcept::OutIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef output_iterator_archetype<value_type> OutIterator;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::pointer_type	/usr/include/boost/regex/concepts.hpp	/^   typedef const value_type* pointer_type;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::RegexConcept	/usr/include/boost/regex/concepts.hpp	/^   RegexConcept();$/;"	p	struct:boost::RegexConcept	access:public	signature:()
boost::RegexConcept::RegexConcept	/usr/include/boost/regex/concepts.hpp	/^   RegexConcept(const RegexConcept&);$/;"	p	struct:boost::RegexConcept	access:public	signature:(const RegexConcept&)
boost::RegexConcept::string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef std::basic_string<value_type> string_type;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::sub_match_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;$/;"	t	struct:boost::RegexConcept	access:public
boost::RegexConcept::value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::value_type value_type;$/;"	t	struct:boost::RegexConcept	access:public
boost::regexecA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regexecA(const regex_tA*, const char*, regsize_t, regmatch_t*, int);$/;"	p	signature:(const regex_tA*, const char*, regsize_t, regmatch_t*, int)
boost::regexecW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regexecW(const regex_tW*, const wchar_t*, regsize_t, regmatch_t*, int);$/;"	p	signature:(const regex_tW*, const wchar_t*, regsize_t, regmatch_t*, int)
boost::RegexTraitsConcept	/usr/include/boost/regex/concepts.hpp	/^struct RegexTraitsConcept$/;"	s	namespace:boost
boost::RegexTraitsConcept::char_class_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::char_class_type char_class_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
boost::RegexTraitsConcept::char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::char_type char_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
boost::RegexTraitsConcept::constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::RegexTraitsConcept	access:public	signature:()
boost::RegexTraitsConcept::locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::locale_type locale_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
boost::RegexTraitsConcept::m_char	/usr/include/boost/regex/concepts.hpp	/^   char_type m_char;$/;"	m	struct:boost::RegexTraitsConcept	access:public
boost::RegexTraitsConcept::m_ctraits	/usr/include/boost/regex/concepts.hpp	/^   const traits m_ctraits;$/;"	m	struct:boost::RegexTraitsConcept	access:public
boost::RegexTraitsConcept::m_pointer	/usr/include/boost/regex/concepts.hpp	/^   const char_type* m_pointer;$/;"	m	struct:boost::RegexTraitsConcept	access:public
boost::RegexTraitsConcept::m_traits	/usr/include/boost/regex/concepts.hpp	/^   traits m_traits;$/;"	m	struct:boost::RegexTraitsConcept	access:public
boost::RegexTraitsConcept::operator =	/usr/include/boost/regex/concepts.hpp	/^   RegexTraitsConcept& operator=(RegexTraitsConcept&);$/;"	p	struct:boost::RegexTraitsConcept	access:private	signature:(RegexTraitsConcept&)
boost::RegexTraitsConcept::RegexTraitsConcept	/usr/include/boost/regex/concepts.hpp	/^   RegexTraitsConcept();$/;"	p	struct:boost::RegexTraitsConcept	access:public	signature:()
boost::RegexTraitsConcept::string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::string_type string_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
boost::regex_constants	/usr/include/boost/regex/v4/error_type.hpp	/^namespace regex_constants{$/;"	n	namespace:boost
boost::regex_constants	/usr/include/boost/regex/v4/match_flags.hpp	/^   namespace regex_constants{$/;"	n	namespace:boost
boost::regex_constants	/usr/include/boost/regex/v4/regbase.hpp	/^namespace regex_constants{$/;"	n	namespace:boost
boost::regex_constants	/usr/include/boost/regex/v4/syntax_type.hpp	/^namespace regex_constants{$/;"	n	namespace:boost
boost::regex_constants::awk	/usr/include/boost/regex/v4/regbase.hpp	/^      awk = ::boost::regbase::awk,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::basic	/usr/include/boost/regex/v4/regbase.hpp	/^      basic = ::boost::regbase::basic,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::bk_plus_qm	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_plus_qm = ::boost::regbase::bk_plus_qm,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::bk_vbar	/usr/include/boost/regex/v4/regbase.hpp	/^      bk_vbar = ::boost::regbase::bk_vbar,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::collate	/usr/include/boost/regex/v4/regbase.hpp	/^      collate = ::boost::regbase::collate,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::ECMAScript	/usr/include/boost/regex/v4/regbase.hpp	/^      ECMAScript = normal,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::egrep	/usr/include/boost/regex/v4/regbase.hpp	/^      egrep = ::boost::regbase::egrep,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::emacs	/usr/include/boost/regex/v4/regbase.hpp	/^      emacs = ::boost::regbase::emacs,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::error_backref	/usr/include/boost/regex/v4/error_type.hpp	/^   error_backref = 6,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_badbrace	/usr/include/boost/regex/v4/error_type.hpp	/^   error_badbrace = 10,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_badrepeat	/usr/include/boost/regex/v4/error_type.hpp	/^   error_badrepeat = 13,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_bad_pattern	/usr/include/boost/regex/v4/error_type.hpp	/^   error_bad_pattern = 2,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_brace	/usr/include/boost/regex/v4/error_type.hpp	/^   error_brace = 9,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_brack	/usr/include/boost/regex/v4/error_type.hpp	/^   error_brack = 7,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_collate	/usr/include/boost/regex/v4/error_type.hpp	/^   error_collate = 3,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_complexity	/usr/include/boost/regex/v4/error_type.hpp	/^   error_complexity = 18,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_ctype	/usr/include/boost/regex/v4/error_type.hpp	/^   error_ctype = 4,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_empty	/usr/include/boost/regex/v4/error_type.hpp	/^   error_empty = 17,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_end	/usr/include/boost/regex/v4/error_type.hpp	/^   error_end = 14,    \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_escape	/usr/include/boost/regex/v4/error_type.hpp	/^   error_escape = 5,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_no_match	/usr/include/boost/regex/v4/error_type.hpp	/^   error_no_match = 1,   \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_ok	/usr/include/boost/regex/v4/error_type.hpp	/^   error_ok = 0,         \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_paren	/usr/include/boost/regex/v4/error_type.hpp	/^   error_paren = 8,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_perl_extension	/usr/include/boost/regex/v4/error_type.hpp	/^   error_perl_extension = 20,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_range	/usr/include/boost/regex/v4/error_type.hpp	/^   error_range = 11,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_right_paren	/usr/include/boost/regex/v4/error_type.hpp	/^   error_right_paren = 16,  \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_size	/usr/include/boost/regex/v4/error_type.hpp	/^   error_size = 15,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_space	/usr/include/boost/regex/v4/error_type.hpp	/^   error_space = 12,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_stack	/usr/include/boost/regex/v4/error_type.hpp	/^   error_stack = 19,$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::error_type	/usr/include/boost/regex/v4/error_type.hpp	/^enum error_type{$/;"	g	namespace:boost::regex_constants
boost::regex_constants::error_unknown	/usr/include/boost/regex/v4/error_type.hpp	/^   error_unknown = 21$/;"	e	enum:boost::regex_constants::error_type
boost::regex_constants::escape_syntax_type	/usr/include/boost/regex/v4/syntax_type.hpp	/^typedef syntax_type escape_syntax_type;$/;"	t	namespace:boost::regex_constants
boost::regex_constants::escape_type_ascii_control	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_ascii_control = 35;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_backref	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_backref = syntax_digit;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_C	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_C = 50;                            \/\/ for \\C$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_class	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_class = 22; $/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_control_a	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_a = 28;                    \/\/ for \\a$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_control_f	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_f = 29;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_control_n	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_n = 30;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_control_r	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_r = 31;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_control_t	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_t = 32;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_control_v	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_v = 33;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_decimal	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_decimal = syntax_digit; \/\/ not used$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_e	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_e = 38;                            \/\/ for \\e$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_E	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_E = 47;                            \/\/ for \\Q\\E$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_end_buffer	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_end_buffer = 25;                   \/\/ for \\'$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_extended_backref	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_extended_backref = 57;             \/\/ for \\g$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_G	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_G = 52;                            \/\/ for \\G$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_hex	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_hex = 34;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_identity	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_identity = 0; \/\/ not used$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_left_word	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_left_word = 20;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_line_ending	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_line_ending = 59;                  \/\/ for \\R$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_named_char	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_named_char = 56;                   \/\/ for \\N$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_not_class	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_not_class = 23; $/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_not_property	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_not_property = 55;                 \/\/ for \\P$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_not_word_assert	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_not_word_assert = 19;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_property	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_property = 54;                     \/\/ for \\p$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_Q	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_Q = 48;                            \/\/ for \\Q\\E$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_reset_start_mark	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_reset_start_mark = 58;             \/\/ for \\K$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_right_word	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_right_word = 21;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_start_buffer	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_start_buffer = 24;                 \/\/ for \\`$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_unicode	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_unicode = 0; \/\/ not used$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_word_assert	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_word_assert = 18;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_X	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_X = 49;                            \/\/ for \\X$/;"	m	namespace:boost::regex_constants
boost::regex_constants::escape_type_Z	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_Z = 51;                            \/\/ for \\Z$/;"	m	namespace:boost::regex_constants
boost::regex_constants::extended	/usr/include/boost/regex/v4/regbase.hpp	/^      extended = ::boost::regbase::extended,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::failbit	/usr/include/boost/regex/v4/regbase.hpp	/^      failbit = ::boost::regbase::failbit,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::flag_type_	/usr/include/boost/regex/v4/regbase.hpp	/^   enum flag_type_$/;"	g	namespace:boost::regex_constants
boost::regex_constants::format_all	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_all = format_sed << 1,                     \/* enable all extentions to sytax. *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::format_default	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_default = 0,                               \/* ditto. *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::format_first_only	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_first_only = format_no_copy << 1,          \/* Only replace first occurance. *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::format_is_if	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_is_if = format_first_only << 1,            \/* internal use only. *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::format_literal	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_literal = format_is_if << 1                \/* treat string as a literal *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::format_no_copy	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_no_copy = format_all << 1,                 \/* don't copy non-matching segments. *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::format_perl	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_perl = 0,                                  \/* perl style replacement *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::format_sed	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_sed = match_max << 1,                      \/* sed style replacement. *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::grep	/usr/include/boost/regex/v4/regbase.hpp	/^      grep = ::boost::regbase::grep,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::icase	/usr/include/boost/regex/v4/regbase.hpp	/^      icase = ::boost::regbase::icase,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::JavaScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JavaScript = normal,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::JScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JScript = normal$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::literal	/usr/include/boost/regex/v4/regbase.hpp	/^      literal = ::boost::regbase::literal,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::match_all	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_all = match_stop << 1,                      \/* must find the whole of input even if match_any is set *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_any	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_any = match_init << 1,                      \/* don't care what we match *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_continuous	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_continuous = match_not_null << 1,           \/* each grep match must continue from *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_default	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_default = 0,$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_extra	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_extra = match_nosubs << 1,                  \/* include full capture information for repeated captures *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_flags	/usr/include/boost/regex/v4/match_flags.hpp	/^} match_flags;$/;"	t	namespace:boost::regex_constants	typeref:enum:boost::regex_constants::_match_flags
boost::regex_constants::match_flag_type	/usr/include/boost/regex/v4/match_flags.hpp	/^typedef match_flags match_flag_type;$/;"	t	namespace:boost::regex_constants
boost::regex_constants::match_flag_type	/usr/include/boost/regex/v4/match_flags.hpp	/^typedef unsigned long match_flag_type;$/;"	t	namespace:boost::regex_constants
boost::regex_constants::match_init	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_init = match_prev_avail << 1,               \/* internal use *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_max	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_max = match_unused3,$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_nosubs	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_nosubs = match_posix << 1,                  \/* don't trap marked subs *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_bob	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_bob = match_not_eol << 1,               \/* first is not start of buffer *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_bol	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_bol = 1,                                \/* first is not start of line *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_bow	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_bow = match_not_eob << 1,               \/* first is not start of word *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_dot_newline	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_dot_newline = match_not_eow << 1,       \/* \\n is not matched by '.' *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_dot_null	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_dot_null = match_not_dot_newline << 1,  \/* '\\0' is not matched by '.' *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_eob	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_eob = match_not_bob << 1,               \/* last is not end of buffer *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_eol	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_eol = match_not_bol << 1,               \/* last is not end of line *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_eow	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_eow = match_not_bow << 1,               \/* last is not end of word *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_initial_null	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_initial_null = match_stop,              \/* don't match initial null, V4 only *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_not_null	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_null = match_any << 1,                  \/* string can't be null *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_partial	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_partial = match_continuous << 1,            \/* find partial matches *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_perl	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_perl = match_all << 1,                      \/* Use perl matching rules *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_posix	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_posix = match_perl << 1,                    \/* Use POSIX matching rules *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_prev_avail	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_prev_avail = match_not_dot_null << 1,       \/* *--first is a valid expression *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_single_line	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_single_line = match_extra << 1,             \/* treat text as single line and ignor any \\n's when matching ^ and $. *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_stop	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_stop = match_partial << 1,                  \/* stop after first match (grep) V3 only *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_unused1	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_unused1 = match_single_line << 1,           \/* unused *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_unused2	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_unused2 = match_unused1 << 1,               \/* unused *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::match_unused3	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_unused3 = match_unused2 << 1,               \/* unused *\/$/;"	e	enum:boost::regex_constants::_match_flags
boost::regex_constants::mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_s = ::boost::regbase::mod_s,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::mod_x	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_x = ::boost::regbase::mod_x,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::nocollate	/usr/include/boost/regex/v4/regbase.hpp	/^      nocollate = ::boost::regbase::nocollate,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::normal	/usr/include/boost/regex/v4/regbase.hpp	/^      normal = ::boost::regbase::normal,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::nosubs	/usr/include/boost/regex/v4/regbase.hpp	/^      nosubs = ::boost::regbase::nosubs,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::no_char_classes	/usr/include/boost/regex/v4/regbase.hpp	/^      no_char_classes = ::boost::regbase::no_char_classes,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::no_empty_expressions	/usr/include/boost/regex/v4/regbase.hpp	/^      no_empty_expressions = ::boost::regbase::no_empty_expressions,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::no_escape_in_lists	/usr/include/boost/regex/v4/regbase.hpp	/^      no_escape_in_lists = ::boost::regbase::no_escape_in_lists,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::no_except	/usr/include/boost/regex/v4/regbase.hpp	/^      no_except = ::boost::regbase::no_except,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::no_intervals	/usr/include/boost/regex/v4/regbase.hpp	/^      no_intervals = ::boost::regbase::no_intervals,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::no_mod_m	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_m = ::boost::regbase::no_mod_m,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::no_mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_s = ::boost::regbase::no_mod_s,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::operator &	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator&(match_flags m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1, match_flags m2)
boost::regex_constants::operator &=	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags& operator&=(match_flags& m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags& m1, match_flags m2)
boost::regex_constants::operator ^	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator^(match_flags m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1, match_flags m2)
boost::regex_constants::operator ^=	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags& operator^=(match_flags& m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags& m1, match_flags m2)
boost::regex_constants::operator |	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator|(match_flags m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1, match_flags m2)
boost::regex_constants::operator |=	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags& operator|=(match_flags& m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags& m1, match_flags m2)
boost::regex_constants::operator ~	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator~(match_flags m1)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1)
boost::regex_constants::optimize	/usr/include/boost/regex/v4/regbase.hpp	/^      optimize = ::boost::regbase::optimize,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::perl	/usr/include/boost/regex/v4/regbase.hpp	/^      perl = normal,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::save_subexpression_location	/usr/include/boost/regex/v4/regbase.hpp	/^      save_subexpression_location = ::boost::regbase::save_subexpression_location,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::sed	/usr/include/boost/regex/v4/regbase.hpp	/^      sed = basic,$/;"	e	enum:boost::regex_constants::flag_type_
boost::regex_constants::syntax_caret	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_caret = 4;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_char	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_char = 0;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_close_brace	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_close_brace = 16;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_close_mark	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_close_mark = 2;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_close_set	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_close_set = 10;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_colon	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_colon = 36;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_comma	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_comma = 27;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_dash	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_dash = 14;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_digit	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_digit = 17;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_dollar	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_dollar = 3;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_dot	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_dot = 5;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_equal	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_equal = 37;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_escape	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_escape = 12;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_hash	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_hash = 13;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_max	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type syntax_max = 60;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_newline	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_newline = 26;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_not	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_not = 53;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_open_brace	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_open_brace = 15;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_open_mark	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_open_mark = 1;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_open_set	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_open_set = 9;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_option_type	/usr/include/boost/regex/v4/regbase.hpp	/^   typedef ::boost::regbase::flag_type syntax_option_type;$/;"	t	namespace:boost::regex_constants
boost::regex_constants::syntax_or	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_or = 11;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_plus	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_plus = 7;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_question	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_question = 8;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_star	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_star = 6;$/;"	m	namespace:boost::regex_constants
boost::regex_constants::syntax_type	/usr/include/boost/regex/v4/syntax_type.hpp	/^typedef unsigned char syntax_type;$/;"	t	namespace:boost::regex_constants
boost::regex_constants::_match_flags	/usr/include/boost/regex/v4/match_flags.hpp	/^typedef enum _match_flags$/;"	g	namespace:boost::regex_constants
boost::regex_error	/usr/include/boost/regex/pattern_except.hpp	/^class BOOST_REGEX_DECL regex_error : public std::runtime_error$/;"	c	namespace:boost	inherits:std::runtime_error
boost::regex_error::code	/usr/include/boost/regex/pattern_except.hpp	/^   regex_constants::error_type code()const$/;"	f	class:boost::regex_error	access:public	signature:() const
boost::regex_error::m_error_code	/usr/include/boost/regex/pattern_except.hpp	/^   regex_constants::error_type m_error_code;$/;"	m	class:boost::regex_error	access:private
boost::regex_error::m_position	/usr/include/boost/regex/pattern_except.hpp	/^   std::ptrdiff_t m_position;$/;"	m	class:boost::regex_error	access:private
boost::regex_error::position	/usr/include/boost/regex/pattern_except.hpp	/^   std::ptrdiff_t position()const$/;"	f	class:boost::regex_error	access:public	signature:() const
boost::regex_error::raise	/usr/include/boost/regex/pattern_except.hpp	/^   void raise()const;$/;"	p	class:boost::regex_error	access:public	signature:() const
boost::regex_error::regex_error	/usr/include/boost/regex/pattern_except.hpp	/^   explicit regex_error(const std::string& s, regex_constants::error_type err = regex_constants::error_unknown, std::ptrdiff_t pos = 0);$/;"	p	class:boost::regex_error	access:public	signature:(const std::string& s, regex_constants::error_type err = regex_constants::error_unknown, std::ptrdiff_t pos = 0)
boost::regex_error::regex_error	/usr/include/boost/regex/pattern_except.hpp	/^   explicit regex_error(regex_constants::error_type err);$/;"	p	class:boost::regex_error	access:public	signature:(regex_constants::error_type err)
boost::regex_error::~regex_error	/usr/include/boost/regex/pattern_except.hpp	/^   ~regex_error() throw();$/;"	p	class:boost::regex_error	access:public	signature:()
boost::regex_format	/usr/include/boost/regex/v4/regex_format.hpp	/^inline OutputIterator regex_format(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, const match_results<Iterator, Allocator>& m, Functor fmt, match_flag_type flags = format_all )
boost::regex_format	/usr/include/boost/regex/v4/regex_format.hpp	/^inline std::basic_string<typename match_results<Iterator, Allocator>::char_type> regex_format(const match_results<Iterator, Allocator>& m, $/;"	f	namespace:boost	signature:(const match_results<Iterator, Allocator>& m, Functor fmt, match_flag_type flags = format_all)
boost::regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const cmatch&), const char* str, $/;"	f	namespace:boost	signature:(bool (foo)const cmatch&), const char* str, const regex& e, match_flag_type flags = match_default)
boost::regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const match_results<std::basic_string<wchar_t>::const_iterator>&), $/;"	f	namespace:boost	signature:(bool (foo)const match_results<std::basic_string<wchar_t>::const_iterator>&), const std::basic_string<wchar_t>& s, const wregex& e, match_flag_type flags = match_default)
boost::regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const match_results<std::string::const_iterator>&), const std::string& s,$/;"	f	namespace:boost	signature:(bool (foo)const match_results<std::string::const_iterator>&), const std::string& s, const regex& e, match_flag_type flags = match_default)
boost::regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const wcmatch&), const wchar_t* str, $/;"	f	namespace:boost	signature:(bool (foo)const wcmatch&), const wchar_t* str, const wregex& e, match_flag_type flags = match_default)
boost::regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(Predicate foo, $/;"	f	namespace:boost	signature:(Predicate foo, BidiIterator first, BidiIterator last, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(Predicate foo, const charT* str, $/;"	f	namespace:boost	signature:(Predicate foo, const charT* str, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(Predicate foo, const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(Predicate foo, const std::basic_string<charT, ST, SA>& s, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^class regex_iterator $/;"	c	namespace:boost	inherits:std::iterator
boost::regex_iterator::cow	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   void cow()$/;"	f	class:boost::regex_iterator	access:private	signature:()
boost::regex_iterator::difference_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::regex_iterator	access:public
boost::regex_iterator::impl	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef regex_iterator_implementation<BidirectionalIterator, charT, traits> impl;$/;"	t	class:boost::regex_iterator	access:private
boost::regex_iterator::iterator_category	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::regex_iterator	access:public
boost::regex_iterator::operator !=	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool operator!=(const regex_iterator& that)const$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that) const
boost::regex_iterator::operator *	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::regex_iterator	access:public	signature:() const
boost::regex_iterator::operator ++	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator operator++(int)$/;"	f	class:boost::regex_iterator	access:public	signature:(int)
boost::regex_iterator::operator ++	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator& operator++()$/;"	f	class:boost::regex_iterator	access:public	signature:()
boost::regex_iterator::operator ->	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::regex_iterator	access:public	signature:() const
boost::regex_iterator::operator =	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator& operator=(const regex_iterator& that)$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that)
boost::regex_iterator::operator ==	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool operator==(const regex_iterator& that)const$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that) const
boost::regex_iterator::pdata	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::regex_iterator	access:private
boost::regex_iterator::pimpl	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::regex_iterator	access:private
boost::regex_iterator::pointer	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::regex_iterator	access:public
boost::regex_iterator::reference	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::regex_iterator	access:public
boost::regex_iterator::regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator(){}$/;"	f	class:boost::regex_iterator	access:public	signature:()
boost::regex_iterator::regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator(BidirectionalIterator a, BidirectionalIterator b, $/;"	f	class:boost::regex_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, match_flag_type m = match_default)
boost::regex_iterator::regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator(const regex_iterator& that)$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that)
boost::regex_iterator::regex_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          basic_regex<charT, traits>                   regex_type;$/;"	t	class:boost::regex_iterator	access:public
boost::regex_iterator::value_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          match_results<BidirectionalIterator>                    value_type;$/;"	t	class:boost::regex_iterator	access:public
boost::regex_iterator_implementation	/usr/include/boost/regex/v4/regex_iterator.hpp	/^class regex_iterator_implementation $/;"	c	namespace:boost
boost::regex_iterator_implementation::base	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   BidirectionalIterator                base;  \/\/ start of sequence$/;"	m	class:boost::regex_iterator_implementation	access:private
boost::regex_iterator_implementation::compare	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool compare(const regex_iterator_implementation& that)$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:(const regex_iterator_implementation& that)
boost::regex_iterator_implementation::end	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   BidirectionalIterator                end;   \/\/ end of sequence$/;"	m	class:boost::regex_iterator_implementation	access:private
boost::regex_iterator_implementation::flags	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   match_flag_type                      flags; \/\/ flags for matching$/;"	m	class:boost::regex_iterator_implementation	access:private
boost::regex_iterator_implementation::get	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const match_results<BidirectionalIterator>& get()$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:()
boost::regex_iterator_implementation::init	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:(BidirectionalIterator first)
boost::regex_iterator_implementation::next	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool next()$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:()
boost::regex_iterator_implementation::operator =	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator_implementation& operator=(const regex_iterator_implementation&);$/;"	p	class:boost::regex_iterator_implementation	access:private	signature:(const regex_iterator_implementation&)
boost::regex_iterator_implementation::re	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const regex_type                     re;   \/\/ the expression$/;"	m	class:boost::regex_iterator_implementation	access:private
boost::regex_iterator_implementation::regex_iterator_implementation	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator_implementation(const regex_type* p, BidirectionalIterator last, match_flag_type f)$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, match_flag_type f)
boost::regex_iterator_implementation::regex_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef basic_regex<charT, traits> regex_type;$/;"	t	class:boost::regex_iterator_implementation	access:private
boost::regex_iterator_implementation::what	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   match_results<BidirectionalIterator> what;  \/\/ current match$/;"	m	class:boost::regex_iterator_implementation	access:private
boost::regex_match	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_match(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::regex_match	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_match(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, match_results<const B*, A>& what, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^bool regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^bool regex_match(iterator first, iterator last, $/;"	f	namespace:boost	signature:(iterator first, iterator last, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const regex& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const regex& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, match_results<const charT*, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const wregex& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const wregex& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const regex& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const regex& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const wregex& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
boost::regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const wregex& e, match_flag_type flags = match_default)
boost::regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline OutputIterator regex_merge(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const basic_regex<charT, traits>& e, const charT* fmt, match_flag_type flags = match_default)
boost::regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline OutputIterator regex_merge(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const basic_regex<charT, traits>& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
boost::regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline std::basic_string<charT> regex_merge(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const basic_regex<charT, traits>& e, const charT* fmt, match_flag_type flags = match_default)
boost::regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline std::basic_string<charT> regex_merge(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const basic_regex<charT, traits>& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
boost::regex_replace	/usr/include/boost/regex/mfc.hpp	/^ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST> regex_replace(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B, traits>& e, const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& fmt, match_flag_type flags = match_default)
boost::regex_replace	/usr/include/boost/regex/mfc.hpp	/^OutputIterator regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last, const basic_regex<B, traits>& e, const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& fmt, match_flag_type flags = match_default)
boost::regex_replace	/usr/include/boost/regex/v4/regex_replace.hpp	/^OutputIterator regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last, const basic_regex<charT, traits>& e, Formatter fmt, match_flag_type flags = match_default)
boost::regex_replace	/usr/include/boost/regex/v4/regex_replace.hpp	/^std::basic_string<charT> regex_replace(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const basic_regex<charT, traits>& e, Formatter fmt, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_search(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::regex_search	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_search(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, match_results<const B*, A>& what, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^bool regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^bool regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^bool regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags, BidiIterator base)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const char* first, const char* last, $/;"	f	namespace:boost	signature:(const char* first, const char* last, const regex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const regex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const regex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, match_results<const charT*, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const wregex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, wsmatch& m, const wregex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const regex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const regex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const wchar_t* first, const wchar_t* last, $/;"	f	namespace:boost	signature:(const wchar_t* first, const wchar_t* last, const wregex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const wregex& e, match_flag_type flags = match_default)
boost::regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const wregex& e, match_flag_type flags = match_default)
boost::regex_split	/usr/include/boost/regex/v4/regex_split.hpp	/^inline std::size_t regex_split(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, std::basic_string<charT, Traits1, Alloc1>& s)
boost::regex_split	/usr/include/boost/regex/v4/regex_split.hpp	/^inline std::size_t regex_split(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, std::basic_string<charT, Traits1, Alloc1>& s, const basic_regex<charT, Traits2>& e, match_flag_type flags = match_default)
boost::regex_split	/usr/include/boost/regex/v4/regex_split.hpp	/^std::size_t regex_split(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, std::basic_string<charT, Traits1, Alloc1>& s, const basic_regex<charT, Traits2>& e, match_flag_type flags, std::size_t max_split)
boost::regex_tA	/usr/include/boost/regex/v4/cregex.hpp	/^} regex_tA;$/;"	t	typeref:struct:boost::__anon3
boost::regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^class regex_token_iterator $/;"	c	namespace:boost	inherits:std::iterator
boost::regex_token_iterator::cow	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   void cow()$/;"	f	class:boost::regex_token_iterator	access:private	signature:()
boost::regex_token_iterator::difference_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::regex_token_iterator	access:public
boost::regex_token_iterator::impl	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef regex_token_iterator_implementation<BidirectionalIterator, charT, traits> impl;$/;"	t	class:boost::regex_token_iterator	access:private
boost::regex_token_iterator::iterator_category	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::regex_token_iterator	access:public
boost::regex_token_iterator::operator !=	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool operator!=(const regex_token_iterator& that)const$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that) const
boost::regex_token_iterator::operator *	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::regex_token_iterator	access:public	signature:() const
boost::regex_token_iterator::operator ++	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator operator++(int)$/;"	f	class:boost::regex_token_iterator	access:public	signature:(int)
boost::regex_token_iterator::operator ++	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator& operator++()$/;"	f	class:boost::regex_token_iterator	access:public	signature:()
boost::regex_token_iterator::operator ->	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::regex_token_iterator	access:public	signature:() const
boost::regex_token_iterator::operator =	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator& operator=(const regex_token_iterator& that)$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that)
boost::regex_token_iterator::operator ==	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool operator==(const regex_token_iterator& that)const$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that) const
boost::regex_token_iterator::pdata	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::regex_token_iterator	access:private
boost::regex_token_iterator::pimpl	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::regex_token_iterator	access:private
boost::regex_token_iterator::pointer	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::regex_token_iterator	access:public
boost::regex_token_iterator::reference	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::regex_token_iterator	access:public
boost::regex_token_iterator::regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(){}$/;"	f	class:boost::regex_token_iterator	access:public	signature:()
boost::regex_token_iterator::regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const std::vector<int>& submatches, match_flag_type m = match_default)
boost::regex_token_iterator::regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, int submatch = 0, match_flag_type m = match_default)
boost::regex_token_iterator::regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const int (&submatches)[N], match_flag_type m = match_default)
boost::regex_token_iterator::regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const T& submatches, match_flag_type m = match_default)
boost::regex_token_iterator::regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(const regex_token_iterator& that)$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that)
boost::regex_token_iterator::regex_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          basic_regex<charT, traits>                   regex_type;$/;"	t	class:boost::regex_token_iterator	access:public
boost::regex_token_iterator::value_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          sub_match<BidirectionalIterator>                        value_type;$/;"	t	class:boost::regex_token_iterator	access:public
boost::regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^class regex_token_iterator_implementation $/;"	c	namespace:boost
boost::regex_token_iterator_implementation::base	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   BidirectionalIterator                base;    \/\/ start of search area$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::compare	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool compare(const regex_token_iterator_implementation& that)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_token_iterator_implementation& that)
boost::regex_token_iterator_implementation::end	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   BidirectionalIterator                end;    \/\/ end of search area$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::flags	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   match_flag_type                      flags;  \/\/ match flags$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::get	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const value_type& get()$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:()
boost::regex_token_iterator_implementation::init	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(BidirectionalIterator first)
boost::regex_token_iterator_implementation::N	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   int                                  N;      \/\/ the current sub-expression being enumerated$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::next	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool next()$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:()
boost::regex_token_iterator_implementation::operator =	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation& operator=(const regex_token_iterator_implementation&);$/;"	p	class:boost::regex_token_iterator_implementation	access:private	signature:(const regex_token_iterator_implementation&)
boost::regex_token_iterator_implementation::re	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const regex_type                     re;    \/\/ the expression$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)
boost::regex_token_iterator_implementation::regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)
boost::regex_token_iterator_implementation::regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)
boost::regex_token_iterator_implementation::regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
boost::regex_token_iterator_implementation::regex_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef basic_regex<charT, traits> regex_type;$/;"	t	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::result	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   value_type                           result; \/\/ the current string result$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::subs	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   std::vector<int>                     subs;   \/\/ the sub-expressions to enumerate$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::value_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef sub_match<BidirectionalIterator>      value_type;$/;"	t	class:boost::regex_token_iterator_implementation	access:private
boost::regex_token_iterator_implementation::what	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   match_results<BidirectionalIterator> what;   \/\/ current match$/;"	m	class:boost::regex_token_iterator_implementation	access:private
boost::regex_traits	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct regex_traits : public implementationT$/;"	s	namespace:boost	inherits:implementationT
boost::regex_traits::regex_traits	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits() : implementationT() {}$/;"	f	struct:boost::regex_traits	access:public	signature:()
boost::regex_traits_architype	/usr/include/boost/regex/concepts.hpp	/^struct regex_traits_architype$/;"	s	namespace:boost
boost::regex_traits_architype::char_class_type	/usr/include/boost/regex/concepts.hpp	/^   typedef bitmask_archetype char_class_type;$/;"	t	struct:boost::regex_traits_architype	access:public
boost::regex_traits_architype::char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef charT char_type;$/;"	t	struct:boost::regex_traits_architype	access:public
boost::regex_traits_architype::getloc	/usr/include/boost/regex/concepts.hpp	/^   locale_type getloc()const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:() const
boost::regex_traits_architype::imbue	/usr/include/boost/regex/concepts.hpp	/^   locale_type imbue(locale_type l)$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(locale_type l)
boost::regex_traits_architype::isctype	/usr/include/boost/regex/concepts.hpp	/^   bool isctype(charT, char_class_type) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT, char_class_type) const
boost::regex_traits_architype::length	/usr/include/boost/regex/concepts.hpp	/^   static std::size_t length(const char_type* ) { return 0; }$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(const char_type* )
boost::regex_traits_architype::locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef copy_constructible_archetype<assignable_archetype<> > locale_type;$/;"	t	struct:boost::regex_traits_architype	access:public
boost::regex_traits_architype::lookup_classname	/usr/include/boost/regex/concepts.hpp	/^   char_class_type lookup_classname(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
boost::regex_traits_architype::lookup_collatename	/usr/include/boost/regex/concepts.hpp	/^   string_type lookup_collatename(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
boost::regex_traits_architype::operator =	/usr/include/boost/regex/concepts.hpp	/^   regex_traits_architype& operator=(const regex_traits_architype&);$/;"	p	struct:boost::regex_traits_architype	access:private	signature:(const regex_traits_architype&)
boost::regex_traits_architype::regex_traits_architype	/usr/include/boost/regex/concepts.hpp	/^   regex_traits_architype();$/;"	p	struct:boost::regex_traits_architype	access:public	signature:()
boost::regex_traits_architype::regex_traits_architype	/usr/include/boost/regex/concepts.hpp	/^   regex_traits_architype(const regex_traits_architype&);$/;"	p	struct:boost::regex_traits_architype	access:private	signature:(const regex_traits_architype&)
boost::regex_traits_architype::string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef std::vector<char_type> string_type;$/;"	t	struct:boost::regex_traits_architype	access:public
boost::regex_traits_architype::transform	/usr/include/boost/regex/concepts.hpp	/^   string_type transform(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
boost::regex_traits_architype::transform_primary	/usr/include/boost/regex/concepts.hpp	/^   string_type transform_primary(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
boost::regex_traits_architype::translate	/usr/include/boost/regex/concepts.hpp	/^   charT translate(charT ) const { return charT(); }$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT ) const
boost::regex_traits_architype::translate_nocase	/usr/include/boost/regex/concepts.hpp	/^   charT translate_nocase(charT ) const { return static_object<charT>::get(); }$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT ) const
boost::regex_traits_architype::value	/usr/include/boost/regex/concepts.hpp	/^   int value(charT, int) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT, int) const
boost::regex_traits_computer	/usr/include/boost/regex/concepts.hpp	/^struct regex_traits_computer< global_regex_namespace::basic_regex<charT, traits> >$/;"	s	namespace:boost
boost::regex_traits_computer::type	/usr/include/boost/regex/concepts.hpp	/^   typedef traits type;$/;"	t	struct:boost::regex_traits_computer	access:public
boost::regex_traits_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct regex_traits_wrapper $/;"	s	namespace:boost	inherits:::boost::re_detail::compute_wrapper_base::type
boost::regex_traits_wrapper::operator =	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits_wrapper& operator=(const regex_traits_wrapper&);$/;"	p	struct:boost::regex_traits_wrapper	access:private	signature:(const regex_traits_wrapper&)
boost::regex_traits_wrapper::regex_traits_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits_wrapper(){}$/;"	f	struct:boost::regex_traits_wrapper	access:public	signature:()
boost::regex_traits_wrapper::regex_traits_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits_wrapper(const regex_traits_wrapper&);$/;"	p	struct:boost::regex_traits_wrapper	access:private	signature:(const regex_traits_wrapper&)
boost::regex_tW	/usr/include/boost/regex/v4/cregex.hpp	/^} regex_tW;$/;"	t	typeref:struct:boost::__anon4
boost::regfreeA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CCALL regfreeA(regex_tA*);$/;"	p	signature:(regex_tA*)
boost::regfreeW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CCALL regfreeW(regex_tW*);$/;"	p	signature:(regex_tW*)
boost::regmatch_t	/usr/include/boost/regex/v4/cregex.hpp	/^} regmatch_t;$/;"	t	typeref:struct:boost::__anon5
boost::regoff_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef std::ptrdiff_t regoff_t;$/;"	t
boost::regsize_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef std::size_t regsize_t;$/;"	t
boost::REG_ASSERT	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ASSERT = 15,$/;"	e	enum:boost::__anon6
boost::REG_ATOI	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ATOI = 255,   \/* convert name to number (!) *\/$/;"	e	enum:boost::__anon6
boost::REG_AWK	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_AWK = REG_EXTENDED | REG_ESCAPE_IN_LISTS,$/;"	e	enum:boost::__anon6
boost::REG_BADBR	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_BADBR = 10;    \/* Invalid contents of \\{\\}.  *\/$/;"	v
boost::REG_BADPAT	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_BADPAT = 2;    \/* Invalid pattern.  *\/$/;"	v
boost::REG_BADRPT	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_BADRPT = 13;   \/* No preceding re for repetition op.  *\/$/;"	v
boost::REG_BASIC	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_BASIC = 0000,$/;"	e	enum:boost::__anon6
boost::reg_comp_flags	/usr/include/boost/regex/v4/cregex.hpp	/^} reg_comp_flags;$/;"	t	typeref:enum:boost::__anon6
boost::REG_DUMP	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_DUMP = 0200,$/;"	e	enum:boost::__anon6
boost::REG_EBRACE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EBRACE = 9;    \/* Unmatched \\{.  *\/$/;"	v
boost::REG_EBRACK	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EBRACK = 7;    \/* Unmatched left bracket.  *\/$/;"	v
boost::REG_ECOLLATE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ECOLLATE = 3;  \/* Undefined collating element.  *\/$/;"	v
boost::REG_ECOMPLEXITY	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ECOMPLEXITY = 18; \/* complexity too high *\/$/;"	v
boost::REG_ECTYPE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ECTYPE = 4;    \/* Invalid character class name.  *\/$/;"	v
boost::REG_EEND	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EEND = 14;     \/* unexpected end of expression *\/$/;"	v
boost::REG_EESCAPE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EESCAPE = 5;   \/* Trailing backslash.  *\/$/;"	v
boost::REG_EGREP	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_EGREP = REG_EXTENDED | REG_NEWLINE_ALT,$/;"	e	enum:boost::__anon6
boost::REG_EMPTY	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EMPTY = 17;    \/* empty expression *\/$/;"	v
boost::REG_ENOSYS	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ENOSYS = 21;   \/* = REG_E_UNKNOWN : Reserved. *\/$/;"	v
boost::REG_EPAREN	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EPAREN = 8;    \/* Parenthesis imbalance.  *\/$/;"	v
boost::REG_ERANGE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ERANGE = 11;   \/* Invalid range end.  *\/$/;"	v
boost::REG_ERPAREN	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ERPAREN = 8;   \/* = REG_EPAREN : unmatched right parenthesis *\/$/;"	v
boost::reg_errcode_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef reg_error_t reg_errcode_t;  \/* backwards compatibility *\/$/;"	t
boost::reg_error_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef unsigned reg_error_t;$/;"	t
boost::REG_ESCAPE_IN_LISTS	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ESCAPE_IN_LISTS = 01000,$/;"	e	enum:boost::__anon6
boost::REG_ESIZE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESIZE = 15;    \/* expression too big *\/$/;"	v
boost::REG_ESPACE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESPACE = 12;   \/* Ran out of memory.  *\/$/;"	v
boost::REG_ESTACK	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESTACK = 19;   \/* out of stack space *\/$/;"	v
boost::REG_ESUBREG	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESUBREG = 6;   \/* Invalid back reference.  *\/$/;"	v
boost::reg_exec_flags	/usr/include/boost/regex/v4/cregex.hpp	/^} reg_exec_flags;$/;"	t	typeref:enum:boost::__anon7
boost::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^class reg_expression : public basic_regex<charT, traits>$/;"	c	namespace:boost	inherits:basic_regex
boost::reg_expression::flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename basic_regex<charT, traits>::flag_type flag_type;$/;"	t	class:boost::reg_expression	access:public
boost::reg_expression::operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression& BOOST_REGEX_CALL operator=(const reg_expression& that)$/;"	f	class:boost::reg_expression	access:public	signature:(const reg_expression& that)
boost::reg_expression::operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression& BOOST_REGEX_CALL operator=(const std::basic_string<charT, ST, SA>& p)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT, ST, SA>& p)
boost::reg_expression::operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression& BOOST_REGEX_CALL operator=(const std::basic_string<charT>& p)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT>& p)
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(){}$/;"	f	class:boost::reg_expression	access:public	signature:()
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(const charT* p, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(const charT* p, size_type len, flag_type f)$/;"	f	class:boost::reg_expression	access:public	signature:(const charT* p, size_type len, flag_type f)
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(const reg_expression& that)$/;"	f	class:boost::reg_expression	access:public	signature:(const reg_expression& that)
boost::reg_expression::reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
boost::reg_expression::size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename basic_regex<charT, traits>::size_type size_type;$/;"	t	class:boost::reg_expression	access:public
boost::reg_expression::~reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   ~reg_expression(){}$/;"	f	class:boost::reg_expression	access:public	signature:()
boost::REG_EXTENDED	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_EXTENDED = 0001,$/;"	e	enum:boost::__anon6
boost::REG_E_MEMORY	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_E_MEMORY = 15; \/* = REG_ESIZE : out of memory *\/$/;"	v
boost::REG_E_PERL	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_E_PERL = 20;   \/* Perl (?...) error *\/$/;"	v
boost::REG_E_UNKNOWN	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_E_UNKNOWN = 21; \/* unknown error *\/$/;"	v
boost::REG_GREP	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_GREP = REG_BASIC | REG_NEWLINE_ALT,$/;"	e	enum:boost::__anon6
boost::REG_ICASE	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ICASE = 0002,$/;"	e	enum:boost::__anon6
boost::REG_INVARG	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_INVARG = 16,$/;"	e	enum:boost::__anon6
boost::REG_ITOA	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ITOA = 0400   \/* convert number to name (!) *\/$/;"	e	enum:boost::__anon6
boost::REG_NEWLINE	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NEWLINE = 0010,$/;"	e	enum:boost::__anon6
boost::REG_NEWLINE_ALT	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NEWLINE_ALT = 02000,$/;"	e	enum:boost::__anon6
boost::REG_NOCOLLATE	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOCOLLATE = 0400,$/;"	e	enum:boost::__anon6
boost::REG_NOERROR	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_NOERROR = 0;   \/* Success.  *\/$/;"	v
boost::REG_NOMATCH	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_NOMATCH = 1;   \/* Didn't find a match (for regexec).  *\/$/;"	v
boost::REG_NOSPEC	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOSPEC = 0020,$/;"	e	enum:boost::__anon6
boost::REG_NOSUB	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOSUB = 0004,$/;"	e	enum:boost::__anon6
boost::REG_NOTBOL	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOTBOL =    00001,$/;"	e	enum:boost::__anon7
boost::REG_NOTEOL	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOTEOL =    00002,$/;"	e	enum:boost::__anon7
boost::REG_PEND	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_PEND = 0040,$/;"	e	enum:boost::__anon6
boost::REG_PERL	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_PERL = REG_EXTENDED | REG_NOCOLLATE | REG_ESCAPE_IN_LISTS | REG_PERLEX,$/;"	e	enum:boost::__anon6
boost::REG_PERLEX	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_PERLEX = 04000,$/;"	e	enum:boost::__anon6
boost::REG_STARTEND	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_STARTEND =  00004$/;"	e	enum:boost::__anon7
boost::re_detail	/usr/include/boost/regex/config.hpp	/^namespace boost{ namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/config.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/icu.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/mfc.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/pattern_except.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/basic_regex.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/cregex.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/fileiter.hpp	/^   namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/iterator_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/match_results.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/perl_matcher.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/primary_transform.hpp	/^   namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/protected_call.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/regex_format.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/regex_split.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/regex_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^namespace boost{ namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/regex_workaround.hpp	/^namespace boost{ namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/states.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/sub_match.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
boost::re_detail::abstract_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^class BOOST_REGEX_DECL abstract_protected_call$/;"	c	namespace:boost::re_detail
boost::re_detail::abstract_protected_call::call	/usr/include/boost/regex/v4/protected_call.hpp	/^   virtual bool call()const = 0;$/;"	p	class:boost::re_detail::abstract_protected_call	access:private	signature:() const
boost::re_detail::abstract_protected_call::execute	/usr/include/boost/regex/v4/protected_call.hpp	/^   bool BOOST_REGEX_CALL execute()const;$/;"	p	class:boost::re_detail::abstract_protected_call	access:public	signature:() const
boost::re_detail::abstract_protected_call::~abstract_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^   virtual ~abstract_protected_call(){}$/;"	f	class:boost::re_detail::abstract_protected_call	access:public	signature:()
boost::re_detail::any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^struct any_type $/;"	s	namespace:boost::re_detail
boost::re_detail::any_type::any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   any_type(const T&); $/;"	p	struct:boost::re_detail::any_type	access:public	signature:(const T&)
boost::re_detail::any_type::any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   any_type(const T&, const U&); $/;"	p	struct:boost::re_detail::any_type	access:public	signature:(const T&, const U&)
boost::re_detail::any_type::any_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   any_type(const T&, const U&, const V&); $/;"	p	struct:boost::re_detail::any_type	access:public	signature:(const T&, const U&, const V&)
boost::re_detail::backup_subex	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^class backup_subex$/;"	c	namespace:boost::re_detail
boost::re_detail::backup_subex::backup_subex	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   backup_subex(const match_results<BidiIterator, A>& w, int i)$/;"	f	class:boost::re_detail::backup_subex	access:public	signature:(const match_results<BidiIterator, A>& w, int i)
boost::re_detail::backup_subex::get	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   const sub_match<BidiIterator>& get() { return sub; }$/;"	f	class:boost::re_detail::backup_subex	access:public	signature:()
boost::re_detail::backup_subex::index	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   int index;$/;"	m	class:boost::re_detail::backup_subex	access:private
boost::re_detail::backup_subex::restore	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   void restore(match_results<BidiIterator, A>& w)$/;"	f	class:boost::re_detail::backup_subex	access:public	signature:(match_results<BidiIterator, A>& w)
boost::re_detail::backup_subex::sub	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   sub_match<BidiIterator> sub;$/;"	m	class:boost::re_detail::backup_subex	access:private
boost::re_detail::basic_char_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^class basic_char_set$/;"	c	namespace:boost::re_detail
boost::re_detail::basic_char_set::add_class	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_class(m_type m)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(m_type m)
boost::re_detail::basic_char_set::add_equivalent	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_equivalent(const digraph_type& s)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(const digraph_type& s)
boost::re_detail::basic_char_set::add_negated_class	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_negated_class(m_type m)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(m_type m)
boost::re_detail::basic_char_set::add_range	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_range(const digraph_type& first, const digraph_type& end)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(const digraph_type& first, const digraph_type& end)
boost::re_detail::basic_char_set::add_single	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void add_single(const digraph_type& s)$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:(const digraph_type& s)
boost::re_detail::basic_char_set::basic_char_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_char_set()$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:()
boost::re_detail::basic_char_set::classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type classes()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::digraph_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef digraph<charT>                   digraph_type;$/;"	t	class:boost::re_detail::basic_char_set	access:public
boost::re_detail::basic_char_set::empty	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool empty()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::equivalents_begin	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator equivalents_begin()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::equivalents_end	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator equivalents_end()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::has_digraphs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool has_digraphs()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::is_negated	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool is_negated()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::list_iterator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef typename std::vector<digraph_type>::const_iterator  list_iterator;$/;"	t	class:boost::re_detail::basic_char_set	access:public
boost::re_detail::basic_char_set::m_classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type                    m_classes;         \/\/ character classes to match$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_empty	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                      m_empty;           \/\/ whether we've added anything yet$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_equivalents	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<digraph_type> m_equivalents;     \/\/ a list of equivalence classes$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_has_digraphs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                      m_has_digraphs;    \/\/ true if we have digraphs present$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_negate	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                      m_negate;          \/\/ true if the set is to be negated$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_negated_classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type                    m_negated_classes; \/\/ negated character classes to match$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_ranges	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<digraph_type> m_ranges;          \/\/ a list of end points of our ranges$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_singles	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<digraph_type> m_singles;         \/\/ a list of single characters to match$/;"	m	class:boost::re_detail::basic_char_set	access:private
boost::re_detail::basic_char_set::m_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef typename traits::char_class_type m_type;$/;"	t	class:boost::re_detail::basic_char_set	access:public
boost::re_detail::basic_char_set::negate	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void negate()$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:()
boost::re_detail::basic_char_set::negated_classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type negated_classes()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::ranges_begin	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator ranges_begin()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::ranges_end	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator ranges_end()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::singles_begin	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator singles_begin()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::singles_end	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator singles_end()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
boost::re_detail::basic_char_set::string_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef typename traits::string_type     string_type;$/;"	t	class:boost::re_detail::basic_char_set	access:public
boost::re_detail::basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^class basic_regex_creator$/;"	c	namespace:boost::re_detail
boost::re_detail::basic_regex_creator::append_literal	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_literal* append_literal(charT c);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(charT c)
boost::re_detail::basic_regex_creator::append_literal	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_literal* basic_regex_creator<charT, traits>::append_literal(charT c)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(charT c)
boost::re_detail::basic_regex_creator::append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_creator::append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, mpl::false_*);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const basic_char_set<charT, traits>& char_set, mpl::false_*)
boost::re_detail::basic_regex_creator::append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, mpl::true_*);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const basic_char_set<charT, traits>& char_set, mpl::true_*)
boost::re_detail::basic_regex_creator::append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline re_syntax_base* basic_regex_creator<charT, traits>::append_set($/;"	f	class:boost::re_detail::basic_regex_creator	signature:( const basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_creator::append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::append_set($/;"	f	class:boost::re_detail::basic_regex_creator	signature:( const basic_char_set<charT, traits>& char_set, mpl::false_*)
boost::re_detail::basic_regex_creator::append_set	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::append_set($/;"	f	class:boost::re_detail::basic_regex_creator	signature:( const basic_char_set<charT, traits>& char_set, mpl::true_*)
boost::re_detail::basic_regex_creator::append_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* append_state(syntax_element_type t, std::size_t s = sizeof(re_syntax_base));$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(syntax_element_type t, std::size_t s = sizeof(re_syntax_base))
boost::re_detail::basic_regex_creator::append_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::append_state(syntax_element_type t, std::size_t s)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(syntax_element_type t, std::size_t s)
boost::re_detail::basic_regex_creator::basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_regex_creator(const basic_regex_creator&);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(const basic_regex_creator&)
boost::re_detail::basic_regex_creator::basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_regex_creator(regex_data<charT, traits>* data);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(regex_data<charT, traits>* data)
boost::re_detail::basic_regex_creator::basic_regex_creator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^basic_regex_creator<charT, traits>::basic_regex_creator(regex_data<charT, traits>* data)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(regex_data<charT, traits>* data)
boost::re_detail::basic_regex_creator::calculate_backstep	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   int calculate_backstep(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::calculate_backstep	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^int basic_regex_creator<charT, traits>::calculate_backstep(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::create_startmap	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
boost::re_detail::basic_regex_creator::create_startmap	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
boost::re_detail::basic_regex_creator::create_startmaps	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void create_startmaps(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::create_startmaps	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::create_startmaps(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::finalize	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void finalize(const charT* p1, const charT* p2);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const charT* p1, const charT* p2)
boost::re_detail::basic_regex_creator::finalize	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::finalize(const charT* p1, const charT* p2)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(const charT* p1, const charT* p2)
boost::re_detail::basic_regex_creator::fixup_pointers	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void fixup_pointers(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::fixup_pointers	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::fixup_pointers(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::fixup_recursions	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void fixup_recursions(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::fixup_recursions	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::fixup_recursions(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::flags	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   regbase::flag_type flags()$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:()
boost::re_detail::basic_regex_creator::flags	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void flags(regbase::flag_type f)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(regbase::flag_type f)
boost::re_detail::basic_regex_creator::getaddress	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* getaddress(std::ptrdiff_t off)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(std::ptrdiff_t off)
boost::re_detail::basic_regex_creator::getaddress	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* getaddress(std::ptrdiff_t off, void* base)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(std::ptrdiff_t off, void* base)
boost::re_detail::basic_regex_creator::getoffset	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::ptrdiff_t getoffset(const void* addr, const void* base)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(const void* addr, const void* base)
boost::re_detail::basic_regex_creator::getoffset	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::ptrdiff_t getoffset(void* addr)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(void* addr)
boost::re_detail::basic_regex_creator::get_repeat_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   syntax_element_type get_repeat_type(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::get_repeat_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^syntax_element_type basic_regex_creator<charT, traits>::get_repeat_type(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::get_restart_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   unsigned get_restart_type(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::get_restart_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^unsigned basic_regex_creator<charT, traits>::get_restart_type(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::init	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void init(unsigned l_flags)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(unsigned l_flags)
boost::re_detail::basic_regex_creator::insert_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base));$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base))
boost::re_detail::basic_regex_creator::insert_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)
boost::re_detail::basic_regex_creator::is_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool is_bad_repeat(re_syntax_base* pt);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* pt)
boost::re_detail::basic_regex_creator::is_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^bool basic_regex_creator<charT, traits>::is_bad_repeat(re_syntax_base* pt)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* pt)
boost::re_detail::basic_regex_creator::m_alpha_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_alpha_mask;      \/\/ mask used to determine if a character is an alphabetic character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_backrefs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   unsigned                      m_backrefs;           \/\/ bitmask of permitted backrefs$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_bad_repeats	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   boost::uintmax_t              m_bad_repeats;        \/\/ bitmask of repeats we can't deduce a startmap for;$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_has_backrefs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                          m_has_backrefs;       \/\/ true if there are actually any backrefs$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_has_recursions	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                          m_has_recursions;     \/\/ set when we have recursive expresisons to fixup$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_icase	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                          m_icase;              \/\/ true for case insensitive matches$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_last_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base*               m_last_state;         \/\/ the last state we added$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_lower_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_lower_mask;       \/\/ mask used to determine if a character is a lowercase character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_mask_space	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_mask_space;      \/\/ mask used to determine if a character is a word character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_pdata	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   regex_data<charT, traits>*    m_pdata;              \/\/ pointer to the basic_regex_data struct we are filling in$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_recursion_checks	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<bool>             m_recursion_checks;   \/\/ notes which recursions we've followed while analysing this expression$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_repeater_id	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   unsigned                      m_repeater_id;        \/\/ the state_id of the next repeater$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_traits	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^                                 m_traits;             \/\/ convenience reference to traits class$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_upper_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_upper_mask;      \/\/ mask used to determine if a character is an uppercase character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::m_word_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_word_mask;       \/\/ mask used to determine if a character is a word character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
boost::re_detail::basic_regex_creator::operator =	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_regex_creator& operator=(const basic_regex_creator&);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(const basic_regex_creator&)
boost::re_detail::basic_regex_creator::probe_leading_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void probe_leading_repeat(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::probe_leading_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::probe_leading_repeat(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
boost::re_detail::basic_regex_creator::set_all_masks	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void set_all_masks(unsigned char* bits, unsigned char);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(unsigned char* bits, unsigned char)
boost::re_detail::basic_regex_creator::set_all_masks	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::set_all_masks(unsigned char* bits, unsigned char mask)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(unsigned char* bits, unsigned char mask)
boost::re_detail::basic_regex_creator::set_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void set_bad_repeat(re_syntax_base* pt);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* pt)
boost::re_detail::basic_regex_creator::set_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::set_bad_repeat(re_syntax_base* pt)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* pt)
boost::re_detail::basic_regex_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^class basic_regex_formatter$/;"	c	namespace:boost::re_detail
boost::re_detail::basic_regex_formatter::basic_regex_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^   basic_regex_formatter(const basic_regex_formatter&);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(const basic_regex_formatter&)
boost::re_detail::basic_regex_formatter::basic_regex_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^   basic_regex_formatter(OutputIterator o, const Results& r, const traits& t)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:public	signature:(OutputIterator o, const Results& r, const traits& t)
boost::re_detail::basic_regex_formatter::char_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename traits::char_type char_type;$/;"	t	class:boost::re_detail::basic_regex_formatter	access:public
boost::re_detail::basic_regex_formatter::format	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIterator format(ForwardIter p1, ForwardIter p2, match_flag_type f);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:public	signature:(ForwardIter p1, ForwardIter p2, match_flag_type f)
boost::re_detail::basic_regex_formatter::format	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIterator format(ForwardIter p1, match_flag_type f)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:public	signature:(ForwardIter p1, match_flag_type f)
boost::re_detail::basic_regex_formatter::format	/usr/include/boost/regex/v4/regex_format.hpp	/^OutputIterator basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format(ForwardIter p1, ForwardIter p2, match_flag_type f)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(ForwardIter p1, ForwardIter p2, match_flag_type f)
boost::re_detail::basic_regex_formatter::format_all	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_all();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
boost::re_detail::basic_regex_formatter::format_all	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_all()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
boost::re_detail::basic_regex_formatter::format_conditional	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_conditional();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
boost::re_detail::basic_regex_formatter::format_conditional	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_conditional()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
boost::re_detail::basic_regex_formatter::format_escape	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_escape();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
boost::re_detail::basic_regex_formatter::format_escape	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_escape()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
boost::re_detail::basic_regex_formatter::format_perl	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_perl();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
boost::re_detail::basic_regex_formatter::format_perl	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_perl()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
boost::re_detail::basic_regex_formatter::format_until_scope_end	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_until_scope_end();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
boost::re_detail::basic_regex_formatter::format_until_scope_end	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_until_scope_end()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
boost::re_detail::basic_regex_formatter::get_named_sub_index	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int get_named_sub_index(ForwardIter i, ForwardIter j)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter i, ForwardIter j)
boost::re_detail::basic_regex_formatter::get_named_sub_index	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int get_named_sub_index(ForwardIter i, ForwardIter j, const mpl::false_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::false_&)
boost::re_detail::basic_regex_formatter::get_named_sub_index	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int get_named_sub_index(ForwardIter i, ForwardIter j, const mpl::true_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::true_&)
boost::re_detail::basic_regex_formatter::handle_perl_verb	/usr/include/boost/regex/v4/regex_format.hpp	/^   bool handle_perl_verb(bool have_brace);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(bool have_brace)
boost::re_detail::basic_regex_formatter::handle_perl_verb	/usr/include/boost/regex/v4/regex_format.hpp	/^bool basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::handle_perl_verb(bool have_brace)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(bool have_brace)
boost::re_detail::basic_regex_formatter::m_end	/usr/include/boost/regex/v4/regex_format.hpp	/^   ForwardIter      m_end;       \/\/ format string end$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_flags	/usr/include/boost/regex/v4/regex_format.hpp	/^   match_flag_type  m_flags;      \/\/ format flags to use$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_have_conditional	/usr/include/boost/regex/v4/regex_format.hpp	/^   bool             m_have_conditional; \/\/ we are parsing a conditional$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_out	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIterator   m_out;         \/\/ where to send output.$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_position	/usr/include/boost/regex/v4/regex_format.hpp	/^   ForwardIter      m_position;  \/\/ format string, current position$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_restore_state	/usr/include/boost/regex/v4/regex_format.hpp	/^   output_state     m_restore_state;  \/\/ what state to restore to.$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_results	/usr/include/boost/regex/v4/regex_format.hpp	/^   const Results&   m_results;     \/\/ the match_results being used.$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_state	/usr/include/boost/regex/v4/regex_format.hpp	/^   output_state     m_state;      \/\/ what to do with the next character$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::m_traits	/usr/include/boost/regex/v4/regex_format.hpp	/^   const traits&    m_traits;       \/\/ the traits class for localised formatting operations$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   basic_regex_formatter& operator=(const basic_regex_formatter&);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(const basic_regex_formatter&)
boost::re_detail::basic_regex_formatter::output_copy	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_copy,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
boost::re_detail::basic_regex_formatter::output_lower	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_lower,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
boost::re_detail::basic_regex_formatter::output_next_lower	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_next_lower,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
boost::re_detail::basic_regex_formatter::output_next_upper	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_next_upper,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
boost::re_detail::basic_regex_formatter::output_none	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_none$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
boost::re_detail::basic_regex_formatter::output_state	/usr/include/boost/regex/v4/regex_format.hpp	/^   enum output_state$/;"	g	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::output_upper	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_upper,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
boost::re_detail::basic_regex_formatter::put	/usr/include/boost/regex/v4/regex_format.hpp	/^   void put(char_type c);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(char_type c)
boost::re_detail::basic_regex_formatter::put	/usr/include/boost/regex/v4/regex_format.hpp	/^   void put(const sub_match_type& sub);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(const sub_match_type& sub)
boost::re_detail::basic_regex_formatter::put	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::put(char_type c)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(char_type c)
boost::re_detail::basic_regex_formatter::put	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::put(const sub_match_type& sub)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(const sub_match_type& sub)
boost::re_detail::basic_regex_formatter::Results::get_named_sub	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline typename Results::value_type const& get_named_sub(ForwardIter i, ForwardIter j)$/;"	f	class:boost::re_detail::basic_regex_formatter::Results	access:private	signature:(ForwardIter i, ForwardIter j)
boost::re_detail::basic_regex_formatter::Results::get_named_sub	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline typename Results::value_type const& get_named_sub(ForwardIter i, ForwardIter j, const mpl::false_&)$/;"	f	class:boost::re_detail::basic_regex_formatter::Results	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::false_&)
boost::re_detail::basic_regex_formatter::Results::get_named_sub	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline typename Results::value_type const& get_named_sub(ForwardIter i, ForwardIter j, const mpl::true_&)$/;"	f	class:boost::re_detail::basic_regex_formatter::Results	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::true_&)
boost::re_detail::basic_regex_formatter::sub_match_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename Results::value_type sub_match_type;$/;"	t	class:boost::re_detail::basic_regex_formatter	access:private
boost::re_detail::basic_regex_formatter::toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int toi(ForwardIter& i, ForwardIter j, int base)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter& i, ForwardIter j, int base)
boost::re_detail::basic_regex_formatter::toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int toi(ForwardIter& i, ForwardIter j, int base, const boost::mpl::false_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter& i, ForwardIter j, int base, const boost::mpl::false_&)
boost::re_detail::basic_regex_formatter::toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int toi(ForwardIter& i, ForwardIter j, int base, const boost::mpl::true_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter& i, ForwardIter j, int base, const boost::mpl::true_&)
boost::re_detail::basic_regex_implementation	/usr/include/boost/regex/v4/basic_regex.hpp	/^class basic_regex_implementation$/;"	c	namespace:boost::re_detail	inherits:regex_data
boost::re_detail::basic_regex_implementation::assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   void assign(const charT* arg_first,$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(const charT* arg_first, const charT* arg_last, flag_type f)
boost::re_detail::basic_regex_implementation::basic_regex_implementation	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex_implementation(){}$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:()
boost::re_detail::basic_regex_implementation::basic_regex_implementation	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex_implementation(const ::boost::shared_ptr<$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(const ::boost::shared_ptr< ::boost::regex_traits_wrapper<traits> >& t)
boost::re_detail::basic_regex_implementation::begin	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL begin()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::can_be_null	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool can_be_null()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::const_iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const charT*                          const_iterator;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
boost::re_detail::basic_regex_implementation::difference_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::ptrdiff_t                        difference_type;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
boost::re_detail::basic_regex_implementation::end	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL end()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL expression()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::flags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type BOOST_REGEX_CALL flags()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef regex_constants::syntax_option_type   flag_type;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
boost::re_detail::basic_regex_implementation::getloc	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL getloc()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::get_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const regex_data<charT, traits>& get_data()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::get_first_state	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const re_detail::re_syntax_base* get_first_state()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::get_map	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const unsigned char* get_map()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::get_restart_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned get_restart_type()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::get_traits	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const ::boost::regex_traits_wrapper<traits>& get_traits()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::imbue	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL imbue(locale_type l)$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(locale_type l)
boost::re_detail::basic_regex_implementation::locale_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename traits::locale_type          locale_type;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
boost::re_detail::basic_regex_implementation::mark_count	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL mark_count()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::size	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL size()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           size_type; $/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
boost::re_detail::basic_regex_implementation::status	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int BOOST_REGEX_CALL status()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::str	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::basic_string<charT> BOOST_REGEX_CALL str()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
boost::re_detail::basic_regex_implementation::subexpression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::pair<const_iterator, const_iterator> BOOST_REGEX_CALL subexpression(std::size_t n)const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(std::size_t n) const
boost::re_detail::basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^class basic_regex_parser : public basic_regex_creator<charT, traits>$/;"	c	namespace:boost::re_detail	inherits:basic_regex_creator
boost::re_detail::basic_regex_parser::add_emacs_code	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool add_emacs_code(bool negate);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(bool negate)
boost::re_detail::basic_regex_parser::add_emacs_code	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::add_emacs_code(bool negate)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(bool negate)
boost::re_detail::basic_regex_parser::basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   basic_regex_parser(const basic_regex_parser&);$/;"	p	class:boost::re_detail::basic_regex_parser	access:private	signature:(const basic_regex_parser&)
boost::re_detail::basic_regex_parser::basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   basic_regex_parser(regex_data<charT, traits>* data);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_data<charT, traits>* data)
boost::re_detail::basic_regex_parser::basic_regex_parser	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^basic_regex_parser<charT, traits>::basic_regex_parser(regex_data<charT, traits>* data)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(regex_data<charT, traits>* data)
boost::re_detail::basic_regex_parser::char_class_type	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   typedef typename traits::char_class_type char_class_type;$/;"	t	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void fail(regex_constants::error_type error_code, std::ptrdiff_t position);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_constants::error_type error_code, std::ptrdiff_t position)
boost::re_detail::basic_regex_parser::fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void fail(regex_constants::error_type error_code, std::ptrdiff_t position, const std::string& message)$/;"	f	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_constants::error_type error_code, std::ptrdiff_t position, const std::string& message)
boost::re_detail::basic_regex_parser::fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void fail(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos)
boost::re_detail::basic_regex_parser::fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::fail(regex_constants::error_type error_code, std::ptrdiff_t position)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(regex_constants::error_type error_code, std::ptrdiff_t position)
boost::re_detail::basic_regex_parser::fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::fail(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos)
boost::re_detail::basic_regex_parser::get_next_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   digraph<charT> get_next_set_literal(basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_parser::get_next_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^digraph<charT> basic_regex_parser<charT, traits>::get_next_set_literal(basic_char_set<charT, traits>& char_set)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_parser::m_alt_insert_point	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::ptrdiff_t             m_alt_insert_point; \/\/ where to insert the next alternative$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_alt_jumps	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::vector<long>           m_alt_jumps;      \/\/ list of alternative in the current scope.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_alt_jumps	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::vector<std::ptrdiff_t> m_alt_jumps;      \/\/ list of alternative in the current scope.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_base	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   const charT*               m_base;           \/\/ the start of the string being parsed$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_end	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   const charT*               m_end;            \/\/ the end of the string being parsed$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_has_case_change	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool                       m_has_case_change; \/\/ true if somewhere in the current block the case has changed$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_mark_count	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   unsigned                   m_mark_count;     \/\/ how many sub-expressions we have$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_mark_reset	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   int                        m_mark_reset;     \/\/ used to indicate that we're inside a (?|...) block.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_max_mark	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   unsigned                   m_max_mark;       \/\/ largest mark count seen inside a (?|...) block.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_paren_start	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::ptrdiff_t             m_paren_start;    \/\/ where the last seen ')' began (where repeats are inserted).$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_parser_proc	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   parser_proc_type           m_parser_proc;    \/\/ the main parser to use$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::m_position	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   const charT*               m_position;       \/\/ our current parser position$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::operator =	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   basic_regex_parser& operator=(const basic_regex_parser&);$/;"	p	class:boost::re_detail::basic_regex_parser	access:private	signature:(const basic_regex_parser&)
boost::re_detail::basic_regex_parser::parse	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void parse(const charT* p1, const charT* p2, unsigned flags);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(const charT* p1, const charT* p2, unsigned flags)
boost::re_detail::basic_regex_parser::parse	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::parse(const charT* p1, const charT* p2, unsigned l_flags)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(const charT* p1, const charT* p2, unsigned l_flags)
boost::re_detail::basic_regex_parser::parser_proc_type	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   typedef bool (basic_regex_parser::*parser_proc_type)();$/;"	t	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::parse_all	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_all();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_all	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_all()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_alt	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_alt();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_alt	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_alt()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_backref	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_backref();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_backref	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_backref()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_basic	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_basic();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_basic	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_basic()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_basic_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_basic_escape();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_basic_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_basic_escape()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_extended	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_extended();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_extended	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_extended()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_extended_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_extended_escape();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_extended_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_extended_escape()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_inner_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_inner_set(basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_parser::parse_inner_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_inner_set(basic_char_set<charT, traits>& char_set)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_parser::parse_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_literal();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_literal()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_match_any	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_match_any();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_match_any	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_match_any()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_open_paren	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_open_paren();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_open_paren	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_open_paren()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_options	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   regex_constants::syntax_option_type parse_options();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_options	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^regex_constants::syntax_option_type basic_regex_parser<charT, traits>::parse_options()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_perl_extension	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_perl_extension();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_perl_extension	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_perl_extension()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_QE	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_QE();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_QE	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_QE()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_repeat	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_repeat(std::size_t low = 0, std::size_t high = (std::numeric_limits<std::size_t>::max)());$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(std::size_t low = 0, std::size_t high = (std::numeric_limits<std::size_t>::max)())
boost::re_detail::basic_regex_parser::parse_repeat	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_repeat(std::size_t low, std::size_t high)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(std::size_t low, std::size_t high)
boost::re_detail::basic_regex_parser::parse_repeat_range	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_repeat_range(bool isbasic);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(bool isbasic)
boost::re_detail::basic_regex_parser::parse_repeat_range	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_repeat_range(bool isbasic)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(bool isbasic)
boost::re_detail::basic_regex_parser::parse_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_set();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::parse_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_set()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::parse_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void parse_set_literal(basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_parser::parse_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::parse_set_literal(basic_char_set<charT, traits>& char_set)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(basic_char_set<charT, traits>& char_set)
boost::re_detail::basic_regex_parser::sizeof	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   BOOST_STATIC_ASSERT(sizeof(long) >= sizeof(void*));$/;"	p	class:boost::re_detail::basic_regex_parser	access:private	signature:(long)
boost::re_detail::basic_regex_parser::string_type	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   typedef typename traits::string_type string_type;$/;"	t	class:boost::re_detail::basic_regex_parser	access:private
boost::re_detail::basic_regex_parser::unescape_character	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   charT unescape_character();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
boost::re_detail::basic_regex_parser::unescape_character	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^charT basic_regex_parser<charT, traits>::unescape_character()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
boost::re_detail::basic_regex_parser::unwind_alts	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool unwind_alts(std::ptrdiff_t last_paren_start);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(std::ptrdiff_t last_paren_start)
boost::re_detail::basic_regex_parser::unwind_alts	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::unwind_alts(std::ptrdiff_t last_paren_start)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(std::ptrdiff_t last_paren_start)
boost::re_detail::binary_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char (&binary_type)[3];$/;"	t	namespace:boost::re_detail
boost::re_detail::BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^inline boost::shared_ptr<const cpp_regex_traits_implementation<charT> > create_cpp_regex_traits(const std::locale& l BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(charT))$/;"	f	namespace:boost::re_detail	signature:(charT)
boost::re_detail::BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^boost::shared_ptr<const w32_regex_traits_implementation<charT> > create_w32_regex_traits(::boost::re_detail::lcid_type l BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(charT))$/;"	f	namespace:boost::re_detail	signature:(charT)
boost::re_detail::bubble_down_one	/usr/include/boost/regex/v4/basic_regex.hpp	/^void bubble_down_one(I first, I last)$/;"	f	namespace:boost::re_detail	signature:(I first, I last)
boost::re_detail::can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(char c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(char c, const unsigned char* map, unsigned char mask)
boost::re_detail::can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(charT c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(charT c, const unsigned char* map, unsigned char mask)
boost::re_detail::can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(signed char c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(signed char c, const unsigned char* map, unsigned char mask)
boost::re_detail::can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(unsigned char c, const unsigned char* map, unsigned char mask)
boost::re_detail::can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(unsigned int c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(unsigned int c, const unsigned char* map, unsigned char mask)
boost::re_detail::can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(unsigned short c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(unsigned short c, const unsigned char* map, unsigned char mask)
boost::re_detail::can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(wchar_t c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(wchar_t c, const unsigned char* map, unsigned char mask)
boost::re_detail::cat_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^typedef ::boost::shared_ptr<void> cat_type; \/\/ placeholder for dll HANDLE.$/;"	t	namespace:boost::re_detail
boost::re_detail::character_pointer_range	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^struct character_pointer_range$/;"	s	namespace:boost::re_detail
boost::re_detail::character_pointer_range::operator <	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   bool operator < (const character_pointer_range& r)const$/;"	f	struct:boost::re_detail::character_pointer_range	access:public	signature:(const character_pointer_range& r) const
boost::re_detail::character_pointer_range::operator ==	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   bool operator == (const character_pointer_range& r)const$/;"	f	struct:boost::re_detail::character_pointer_range	access:public	signature:(const character_pointer_range& r) const
boost::re_detail::character_pointer_range::p1	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   const charT* p1;$/;"	m	struct:boost::re_detail::character_pointer_range	access:public
boost::re_detail::character_pointer_range::p2	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   const charT* p2;$/;"	m	struct:boost::re_detail::character_pointer_range	access:public
boost::re_detail::char_class_alnum	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_alnum=char_class_alpha|char_class_digit, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_alpha	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_alpha=1<<5, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_blank	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_blank=1<<9,$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_cntrl	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_cntrl=1<<2, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_digit	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_digit=1<<6, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_graph	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_graph=char_class_alnum|char_class_punct,$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_horizontal_space	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_horizontal_space=1<<12,$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_lower	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_lower=1<<4,$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_print	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_print=1<<1, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_punct	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_punct=1<<7, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_space	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_space=1<<0, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_unicode	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_unicode=1<<11,$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_upper	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_upper=1<<3, $/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_vertical_space	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_vertical_space=1<<13$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_word	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_word=1<<10,$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_class_xdigit	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_xdigit=1<<8,$/;"	e	enum:boost::re_detail::__anon2
boost::re_detail::char_less	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline bool char_less(char t1, char t2)$/;"	f	namespace:boost::re_detail	signature:(char t1, char t2)
boost::re_detail::char_less	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline bool char_less(signed char t1, signed char t2)$/;"	f	namespace:boost::re_detail	signature:(signed char t1, signed char t2)
boost::re_detail::char_less	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline bool char_less(T t1, T t2)$/;"	f	namespace:boost::re_detail	signature:(T t1, T t2)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^binary_type check_is_formatter(T const &, U const &, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(T const &, U const &, ternary_type)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^binary_type check_is_formatter(unary_type, T const &, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(unary_type, T const &, ternary_type)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^no_type check_is_formatter(unary_type, binary_type, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(unary_type, binary_type, ternary_type)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(T const &, binary_type, U const &);$/;"	p	namespace:boost::re_detail	signature:(T const &, binary_type, U const &)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(T const &, U const &, V const &);$/;"	p	namespace:boost::re_detail	signature:(T const &, U const &, V const &)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(unary_type, binary_type, T const &);$/;"	p	namespace:boost::re_detail	signature:(unary_type, binary_type, T const &)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(unary_type, T const &, U const &);$/;"	p	namespace:boost::re_detail	signature:(unary_type, T const &, U const &)
boost::re_detail::check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^unary_type check_is_formatter(T const &, binary_type, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(T const &, binary_type, ternary_type)
boost::re_detail::compute_functor_type	/usr/include/boost/regex/v4/regex_format.hpp	/^struct compute_functor_type$/;"	s	namespace:boost::re_detail
boost::re_detail::compute_functor_type::maybe_char_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename boost::remove_cv< typename boost::remove_pointer<Func>::type>::type maybe_char_type;$/;"	t	struct:boost::re_detail::compute_functor_type	access:public
boost::re_detail::compute_functor_type::tag	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename format_traits<Func, Match, OutputIterator>::type tag;$/;"	t	struct:boost::re_detail::compute_functor_type	access:public
boost::re_detail::compute_functor_type::type	/usr/include/boost/regex/v4/regex_format.hpp	/^   >::type type;$/;"	t	struct:boost::re_detail::compute_functor_type	access:public
boost::re_detail::compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base$/;"	s	namespace:boost::re_detail
boost::re_detail::compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base<BaseT, false>$/;"	s	namespace:boost::re_detail
boost::re_detail::compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base<c_regex_traits<char>, false>$/;"	s	namespace:boost::re_detail
boost::re_detail::compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base<c_regex_traits<wchar_t>, false>$/;"	s	namespace:boost::re_detail
boost::re_detail::compute_wrapper_base::type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef BaseT type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
boost::re_detail::compute_wrapper_base::type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef default_wrapper<BaseT> type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
boost::re_detail::compute_wrapper_base::type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef default_wrapper<c_regex_traits<char> > type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
boost::re_detail::compute_wrapper_base::type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef default_wrapper<c_regex_traits<wchar_t> > type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
boost::re_detail::concrete_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^class concrete_protected_call$/;"	c	namespace:boost::re_detail	inherits:abstract_protected_call
boost::re_detail::concrete_protected_call::call	/usr/include/boost/regex/v4/protected_call.hpp	/^   virtual bool call()const;$/;"	p	class:boost::re_detail::concrete_protected_call	access:private	signature:() const
boost::re_detail::concrete_protected_call::call	/usr/include/boost/regex/v4/protected_call.hpp	/^bool concrete_protected_call<T>::call()const$/;"	f	class:boost::re_detail::concrete_protected_call	signature:() const
boost::re_detail::concrete_protected_call::concrete_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^   concrete_protected_call(T* o, proc_type p)$/;"	f	class:boost::re_detail::concrete_protected_call	access:public	signature:(T* o, proc_type p)
boost::re_detail::concrete_protected_call::obj	/usr/include/boost/regex/v4/protected_call.hpp	/^   T* obj;$/;"	m	class:boost::re_detail::concrete_protected_call	access:private
boost::re_detail::concrete_protected_call::proc	/usr/include/boost/regex/v4/protected_call.hpp	/^   proc_type proc;$/;"	m	class:boost::re_detail::concrete_protected_call	access:private
boost::re_detail::concrete_protected_call::proc_type	/usr/include/boost/regex/v4/protected_call.hpp	/^   typedef bool (T::*proc_type)();$/;"	t	class:boost::re_detail::concrete_protected_call	access:public
boost::re_detail::const_pointer_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct const_pointer_iterator_traits$/;"	s	namespace:boost::re_detail
boost::re_detail::const_pointer_iterator_traits::difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
boost::re_detail::const_pointer_iterator_traits::iterator_category	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::random_access_iterator_tag iterator_category;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
boost::re_detail::const_pointer_iterator_traits::pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef const T* pointer;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
boost::re_detail::const_pointer_iterator_traits::reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef const T& reference;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
boost::re_detail::const_pointer_iterator_traits::value_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T value_type;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
boost::re_detail::copy	/usr/include/boost/regex/v4/regex_workaround.hpp	/^   inline OutputIterator copy($/;"	f	namespace:boost::re_detail	signature:( InputIterator first, InputIterator last, OutputIterator dest )
boost::re_detail::copy_results	/usr/include/boost/regex/icu.hpp	/^void copy_results(MR1& out, MR2 const& in)$/;"	f	namespace:boost::re_detail	signature:(MR1& out, MR2 const& in)
boost::re_detail::count_chars	/usr/include/boost/regex/v4/primary_transform.hpp	/^unsigned count_chars(const S& s, charT c)$/;"	f	namespace:boost::re_detail	signature:(const S& s, charT c)
boost::re_detail::cpp_regex_traits_base	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^struct cpp_regex_traits_base$/;"	s	namespace:boost::re_detail
boost::re_detail::cpp_regex_traits_base::cpp_regex_traits_base	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_base(const std::locale& l)$/;"	f	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const std::locale& l)
boost::re_detail::cpp_regex_traits_base::imbue	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::locale imbue(const std::locale& l);$/;"	p	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const std::locale& l)
boost::re_detail::cpp_regex_traits_base::imbue	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::locale cpp_regex_traits_base<charT>::imbue(const std::locale& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_base	signature:(const std::locale& l)
boost::re_detail::cpp_regex_traits_base::m_locale	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::locale m_locale;$/;"	m	struct:boost::re_detail::cpp_regex_traits_base	access:public
boost::re_detail::cpp_regex_traits_base::operator <	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool operator<(const cpp_regex_traits_base& b)const$/;"	f	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const cpp_regex_traits_base& b) const
boost::re_detail::cpp_regex_traits_base::operator ==	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool operator==(const cpp_regex_traits_base& b)const$/;"	f	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const cpp_regex_traits_base& b) const
boost::re_detail::cpp_regex_traits_base::std::m_pcollate	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::collate<charT> const* m_pcollate;$/;"	m	class:boost::re_detail::cpp_regex_traits_base::std	access:public
boost::re_detail::cpp_regex_traits_base::std::m_pctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::ctype<charT> const* m_pctype;$/;"	m	class:boost::re_detail::cpp_regex_traits_base::std	access:public
boost::re_detail::cpp_regex_traits_base::std::m_pmessages	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::messages<charT> const* m_pmessages;$/;"	m	class:boost::re_detail::cpp_regex_traits_base::std	access:public
boost::re_detail::cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class BOOST_REGEX_DECL cpp_regex_traits_char_layer<char> : public cpp_regex_traits_base<char>$/;"	c	namespace:boost::re_detail	inherits:cpp_regex_traits_base
boost::re_detail::cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class cpp_regex_traits_char_layer : public cpp_regex_traits_base<charT>$/;"	c	namespace:boost::re_detail	inherits:cpp_regex_traits_base
boost::re_detail::cpp_regex_traits_char_layer::cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer(const cpp_regex_traits_base<char>& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(const cpp_regex_traits_base<char>& l)
boost::re_detail::cpp_regex_traits_char_layer::cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer(const cpp_regex_traits_base<charT>& b)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(const cpp_regex_traits_base<charT>& b)
boost::re_detail::cpp_regex_traits_char_layer::cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer(const std::locale& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(const std::locale& l)
boost::re_detail::cpp_regex_traits_char_layer::escape_syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(char c) const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(char c) const
boost::re_detail::cpp_regex_traits_char_layer::escape_syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(charT c) const
boost::re_detail::cpp_regex_traits_char_layer::get_default_message	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	signature:(regex_constants::syntax_type i)
boost::re_detail::cpp_regex_traits_char_layer::get_default_message	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type get_default_message(regex_constants::syntax_type);$/;"	p	class:boost::re_detail::cpp_regex_traits_char_layer	access:private	signature:(regex_constants::syntax_type)
boost::re_detail::cpp_regex_traits_char_layer::init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::cpp_regex_traits_char_layer	access:private	signature:()
boost::re_detail::cpp_regex_traits_char_layer::init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:()
boost::re_detail::cpp_regex_traits_char_layer::init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^void cpp_regex_traits_char_layer<charT>::init()$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	signature:()
boost::re_detail::cpp_regex_traits_char_layer::map_iterator_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename map_type::const_iterator map_iterator_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
boost::re_detail::cpp_regex_traits_char_layer::map_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::map<charT, regex_constants::syntax_type> map_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
boost::re_detail::cpp_regex_traits_char_layer::m_char_map	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   map_type m_char_map;$/;"	m	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
boost::re_detail::cpp_regex_traits_char_layer::m_char_map	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type m_char_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
boost::re_detail::cpp_regex_traits_char_layer::string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
boost::re_detail::cpp_regex_traits_char_layer::string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::string string_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
boost::re_detail::cpp_regex_traits_char_layer::syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(char c)const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(char c) const
boost::re_detail::cpp_regex_traits_char_layer::syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(charT c) const
boost::re_detail::cpp_regex_traits_implementation	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class cpp_regex_traits_implementation : public cpp_regex_traits_char_layer<charT>$/;"	c	namespace:boost::re_detail	inherits:cpp_regex_traits_char_layer
boost::re_detail::cpp_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_blank = 1u << 24);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_blank = 1u << 24)
boost::re_detail::cpp_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_horizontal = 1u << 27);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_horizontal = 1u << 27)
boost::re_detail::cpp_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_unicode = 1u << 26);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_unicode = 1u << 26)
boost::re_detail::cpp_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_vertical = 1u << 28);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_vertical = 1u << 28)
boost::re_detail::cpp_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_word = 1u << 25);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_word = 1u << 25)
boost::re_detail::cpp_regex_traits_implementation::char_class_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename cpp_regex_traits<charT>::char_class_type char_class_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
boost::re_detail::cpp_regex_traits_implementation::char_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef charT char_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation(const cpp_regex_traits_base<charT>& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const cpp_regex_traits_base<charT>& l)
boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation(const std::locale& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const std::locale& l)
boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation::mask_blank	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_blank;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation::mask_horizontal	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_horizontal;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation::mask_unicode	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_unicode;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation::mask_vertical	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_vertical;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation::mask_word	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_word;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
boost::re_detail::cpp_regex_traits_implementation::error_string	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(regex_constants::error_type n) const
boost::re_detail::cpp_regex_traits_implementation::init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:private	signature:()
boost::re_detail::cpp_regex_traits_implementation::init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^void cpp_regex_traits_implementation<charT>::init()$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:()
boost::re_detail::cpp_regex_traits_implementation::isctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool isctype(charT c, char_class_type m)const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(charT c, char_class_type m) const
boost::re_detail::cpp_regex_traits_implementation::isctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^bool cpp_regex_traits_implementation<charT>::isctype(const charT c, char_class_type mask) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT c, char_class_type mask) const
boost::re_detail::cpp_regex_traits_implementation::lookup_classname	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::lookup_classname_imp	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:private	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::lookup_classname_imp	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::lookup_collatename	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::lookup_collatename	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::m_collate_delim	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT                          m_collate_delim;   \/\/ the collation group delimiter$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
boost::re_detail::cpp_regex_traits_implementation::m_collate_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   unsigned                       m_collate_type;    \/\/ the form of the collation string$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
boost::re_detail::cpp_regex_traits_implementation::m_custom_class_names	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::map<string_type, char_class_type>  m_custom_class_names; \/\/ character class names$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
boost::re_detail::cpp_regex_traits_implementation::m_custom_collate_names	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::map<string_type, string_type>      m_custom_collate_names; \/\/ collating element names$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
boost::re_detail::cpp_regex_traits_implementation::m_error_strings	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::map<int, std::string>     m_error_strings;   \/\/ error messages indexed by numberic ID$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
boost::re_detail::cpp_regex_traits_implementation::native_mask_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename std::ctype<charT>::mask                  native_mask_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
boost::re_detail::cpp_regex_traits_implementation::string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
boost::re_detail::cpp_regex_traits_implementation::transform	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::transform	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::transform_primary	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
boost::re_detail::cpp_regex_traits_implementation::transform_primary	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::default_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct default_wrapper : public BaseT$/;"	s	namespace:boost::re_detail	inherits:BaseT
boost::re_detail::default_wrapper::char_type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef typename BaseT::char_type char_type;$/;"	t	struct:boost::re_detail::default_wrapper	access:public
boost::re_detail::default_wrapper::error_string	/usr/include/boost/regex/v4/regex_traits.hpp	/^   std::string error_string(::boost::regex_constants::error_type e)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(::boost::regex_constants::error_type e) const
boost::re_detail::default_wrapper::escape_syntax_type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   ::boost::regex_constants::escape_syntax_type escape_syntax_type(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
boost::re_detail::default_wrapper::syntax_type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   ::boost::regex_constants::syntax_type syntax_type(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
boost::re_detail::default_wrapper::toi	/usr/include/boost/regex/v4/regex_traits.hpp	/^   int toi(const char_type*& p1, const char_type* p2, int radix)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(const char_type*& p1, const char_type* p2, int radix) const
boost::re_detail::default_wrapper::tolower	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type tolower(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
boost::re_detail::default_wrapper::toupper	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type toupper(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
boost::re_detail::default_wrapper::translate	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type translate(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
boost::re_detail::default_wrapper::translate	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type translate(char_type c, bool icase)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c, bool icase) const
boost::re_detail::digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^struct digraph : public std::pair<charT, charT>$/;"	s	namespace:boost::re_detail	inherits:std::pair
boost::re_detail::digraph::digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph() : std::pair<charT, charT>(0, 0){}$/;"	f	struct:boost::re_detail::digraph	access:public	signature:()
boost::re_detail::digraph::digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(charT c1) : std::pair<charT, charT>(c1, 0){}$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(charT c1)
boost::re_detail::digraph::digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(charT c1, charT c2) : std::pair<charT, charT>(c1, c2)$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(charT c1, charT c2)
boost::re_detail::digraph::digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(const digraph<charT>& d) : std::pair<charT, charT>(d.first, d.second){}$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(const digraph<charT>& d)
boost::re_detail::digraph::digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(const Seq& s) : std::pair<charT, charT>()$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(const Seq& s)
boost::re_detail::directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^class BOOST_REGEX_DECL directory_iterator$/;"	c	namespace:boost::re_detail
boost::re_detail::directory_iterator::data	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_data* data() { return &(ref->_data); }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
boost::re_detail::directory_iterator::difference_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::ptrdiff_t            difference_type;$/;"	t	class:boost::re_detail::directory_iterator	access:public
boost::re_detail::directory_iterator::directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator();$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:()
boost::re_detail::directory_iterator::directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator(const char* wild);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(const char* wild)
boost::re_detail::directory_iterator::directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator(const directory_iterator& other);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(const directory_iterator& other)
boost::re_detail::directory_iterator::iterator_category	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::input_iterator_tag   iterator_category;$/;"	t	class:boost::re_detail::directory_iterator	access:public
boost::re_detail::directory_iterator::name	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* name()const { return ptr; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:() const
boost::re_detail::directory_iterator::next	/usr/include/boost/regex/v4/fileiter.hpp	/^   void next();$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:()
boost::re_detail::directory_iterator::operator !=	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator != (const directory_iterator& f1, const directory_iterator& f2)$/;"	f	class:boost::re_detail::directory_iterator	access:friend	signature:(const directory_iterator& f1, const directory_iterator& f2)
boost::re_detail::directory_iterator::operator *	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* operator*() { return path(); }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
boost::re_detail::directory_iterator::operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator operator++(int);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(int)
boost::re_detail::directory_iterator::operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator& operator++() { next(); return *this; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
boost::re_detail::directory_iterator::operator =	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator& operator=(const directory_iterator& other);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(const directory_iterator& other)
boost::re_detail::directory_iterator::operator ==	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator == (const directory_iterator& f1, const directory_iterator& f2)$/;"	f	class:boost::re_detail::directory_iterator	access:friend	signature:(const directory_iterator& f1, const directory_iterator& f2)
boost::re_detail::directory_iterator::path	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* path()const { return _path; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:() const
boost::re_detail::directory_iterator::pointer	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char**              pointer;$/;"	t	class:boost::re_detail::directory_iterator	access:public
boost::re_detail::directory_iterator::ptr	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* ptr;$/;"	m	class:boost::re_detail::directory_iterator	access:private
boost::re_detail::directory_iterator::ref	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator_ref* ref;$/;"	m	class:boost::re_detail::directory_iterator	access:private
boost::re_detail::directory_iterator::reference	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*&              reference;$/;"	t	class:boost::re_detail::directory_iterator	access:public
boost::re_detail::directory_iterator::root	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* root()const { return _root; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:() const
boost::re_detail::directory_iterator::separator	/usr/include/boost/regex/v4/fileiter.hpp	/^   static const char* separator() { return _fi_sep; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
boost::re_detail::directory_iterator::value_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*               value_type;$/;"	t	class:boost::re_detail::directory_iterator	access:public
boost::re_detail::directory_iterator::_path	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _path;$/;"	m	class:boost::re_detail::directory_iterator	access:private
boost::re_detail::directory_iterator::_root	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _root;$/;"	m	class:boost::re_detail::directory_iterator	access:private
boost::re_detail::directory_iterator::~directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   ~directory_iterator();$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:()
boost::re_detail::distance	/usr/include/boost/regex/v4/regex_workaround.hpp	/^std::ptrdiff_t distance(const T& x, const T& y)$/;"	f	namespace:boost::re_detail	signature:(const T& x, const T& y)
boost::re_detail::dont_care	/usr/include/boost/regex/v4/states.hpp	/^   dont_care = 1,$/;"	e	enum:boost::re_detail::__anon16
boost::re_detail::do_global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL do_global_lower(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
boost::re_detail::do_global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL unsigned short BOOST_REGEX_CALL do_global_lower(unsigned short c);$/;"	p	namespace:boost::re_detail	signature:(unsigned short c)
boost::re_detail::do_global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL do_global_lower(wchar_t c);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c)
boost::re_detail::do_global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL do_global_upper(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
boost::re_detail::do_global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL unsigned short BOOST_REGEX_CALL do_global_upper(unsigned short c);$/;"	p	namespace:boost::re_detail	signature:(unsigned short c)
boost::re_detail::do_global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL do_global_upper(wchar_t c);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c)
boost::re_detail::do_make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex do_make_u32regex(InputIterator i, $/;"	f	namespace:boost::re_detail	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt, const boost::mpl::int_<1>*)
boost::re_detail::do_make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex do_make_u32regex(InputIterator i, $/;"	f	namespace:boost::re_detail	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt, const boost::mpl::int_<2>*)
boost::re_detail::do_make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex do_make_u32regex(InputIterator i, $/;"	f	namespace:boost::re_detail	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt, const boost::mpl::int_<4>*)
boost::re_detail::do_regex_match	/usr/include/boost/regex/icu.hpp	/^bool do_regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, boost::mpl::int_<1> const*)
boost::re_detail::do_regex_match	/usr/include/boost/regex/icu.hpp	/^bool do_regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, boost::mpl::int_<2> const*)
boost::re_detail::do_regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool do_regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, boost::mpl::int_<4> const*)
boost::re_detail::do_regex_replace	/usr/include/boost/regex/icu.hpp	/^OutputIterator do_regex_replace(OutputIterator out,$/;"	f	namespace:boost::re_detail	signature:(OutputIterator out, std::pair<I1, I1> const& in, const u32regex& e, const std::pair<I2, I2>& fmt, match_flag_type flags )
boost::re_detail::do_regex_search	/usr/include/boost/regex/icu.hpp	/^bool do_regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base, boost::mpl::int_<1> const*)
boost::re_detail::do_regex_search	/usr/include/boost/regex/icu.hpp	/^bool do_regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base, boost::mpl::int_<2> const*)
boost::re_detail::do_regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool do_regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base, boost::mpl::int_<4> const*)
boost::re_detail::do_toi	/usr/include/boost/regex/v4/sub_match.hpp	/^int do_toi(BidiIterator i, BidiIterator j, char c, int radix)$/;"	f	namespace:boost::re_detail	signature:(BidiIterator i, BidiIterator j, char c, int radix)
boost::re_detail::do_toi	/usr/include/boost/regex/v4/sub_match.hpp	/^int do_toi(I& i, I j, charT c)$/;"	f	namespace:boost::re_detail	signature:(I& i, I j, charT c)
boost::re_detail::empty_padding	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct empty_padding{};$/;"	s	namespace:boost::re_detail
boost::re_detail::equal	/usr/include/boost/regex/v4/regex_workaround.hpp	/^   inline bool equal($/;"	f	namespace:boost::re_detail	signature:( InputIterator1 first, InputIterator1 last, InputIterator2 with )
boost::re_detail::extract_output_base	/usr/include/boost/regex/icu.hpp	/^inline BaseIterator extract_output_base(const utf16_output_iterator<BaseIterator>& b)$/;"	f	namespace:boost::re_detail	signature:(const utf16_output_iterator<BaseIterator>& b)
boost::re_detail::extract_output_base	/usr/include/boost/regex/icu.hpp	/^inline BaseIterator extract_output_base(const utf8_output_iterator<BaseIterator>& b)$/;"	f	namespace:boost::re_detail	signature:(const utf8_output_iterator<BaseIterator>& b)
boost::re_detail::extract_output_base	/usr/include/boost/regex/icu.hpp	/^inline const BaseIterator& extract_output_base(const BaseIterator& b)$/;"	f	namespace:boost::re_detail	signature:(const BaseIterator& b)
boost::re_detail::file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^class BOOST_REGEX_DECL file_iterator $/;"	c	namespace:boost::re_detail
boost::re_detail::file_iterator::data	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_data* data() { return &(ref->_data); }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:()
boost::re_detail::file_iterator::difference_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::ptrdiff_t            difference_type;$/;"	t	class:boost::re_detail::file_iterator	access:public
boost::re_detail::file_iterator::file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator();$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:()
boost::re_detail::file_iterator::file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator(const char* wild);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(const char* wild)
boost::re_detail::file_iterator::file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator(const file_iterator&);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(const file_iterator&)
boost::re_detail::file_iterator::iterator_category	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::input_iterator_tag   iterator_category;$/;"	t	class:boost::re_detail::file_iterator	access:public
boost::re_detail::file_iterator::name	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* name()const { return ptr; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:() const
boost::re_detail::file_iterator::next	/usr/include/boost/regex/v4/fileiter.hpp	/^   void next();$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:()
boost::re_detail::file_iterator::operator !=	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator != (const file_iterator& f1, const file_iterator& f2)$/;"	f	class:boost::re_detail::file_iterator	access:friend	signature:(const file_iterator& f1, const file_iterator& f2)
boost::re_detail::file_iterator::operator *	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* operator*() { return path(); }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:()
boost::re_detail::file_iterator::operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator operator++(int);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(int)
boost::re_detail::file_iterator::operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator& operator++() { next(); return *this; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:()
boost::re_detail::file_iterator::operator =	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator& operator=(const file_iterator&);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(const file_iterator&)
boost::re_detail::file_iterator::operator ==	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator == (const file_iterator& f1, const file_iterator& f2)$/;"	f	class:boost::re_detail::file_iterator	access:friend	signature:(const file_iterator& f1, const file_iterator& f2)
boost::re_detail::file_iterator::path	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* path()const { return _path; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:() const
boost::re_detail::file_iterator::pointer	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char**              pointer;$/;"	t	class:boost::re_detail::file_iterator	access:public
boost::re_detail::file_iterator::ptr	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* ptr;$/;"	m	class:boost::re_detail::file_iterator	access:private
boost::re_detail::file_iterator::ref	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator_ref* ref;$/;"	m	class:boost::re_detail::file_iterator	access:private
boost::re_detail::file_iterator::reference	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*&              reference;$/;"	t	class:boost::re_detail::file_iterator	access:public
boost::re_detail::file_iterator::root	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* root()const { return _root; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:() const
boost::re_detail::file_iterator::value_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*               value_type;$/;"	t	class:boost::re_detail::file_iterator	access:public
boost::re_detail::file_iterator::_path	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _path;$/;"	m	class:boost::re_detail::file_iterator	access:private
boost::re_detail::file_iterator::_root	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _root;$/;"	m	class:boost::re_detail::file_iterator	access:private
boost::re_detail::file_iterator::~file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   ~file_iterator();$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:()
boost::re_detail::file_iterator_ref	/usr/include/boost/regex/v4/fileiter.hpp	/^struct file_iterator_ref$/;"	s	namespace:boost::re_detail
boost::re_detail::file_iterator_ref::count	/usr/include/boost/regex/v4/fileiter.hpp	/^   long count;$/;"	m	struct:boost::re_detail::file_iterator_ref	access:public
boost::re_detail::file_iterator_ref::hf	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_handle hf;$/;"	m	struct:boost::re_detail::file_iterator_ref	access:public
boost::re_detail::file_iterator_ref::_data	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_data _data;$/;"	m	struct:boost::re_detail::file_iterator_ref	access:public
boost::re_detail::find_sort_syntax	/usr/include/boost/regex/v4/primary_transform.hpp	/^unsigned find_sort_syntax(const traits* pt, charT* delim)$/;"	f	namespace:boost::re_detail	signature:(const traits* pt, charT* delim)
boost::re_detail::force_newline	/usr/include/boost/regex/v4/states.hpp	/^   force_newline = 2,$/;"	e	enum:boost::re_detail::__anon16
boost::re_detail::force_not_newline	/usr/include/boost/regex/v4/states.hpp	/^   force_not_newline = 0,$/;"	e	enum:boost::re_detail::__anon16
boost::re_detail::formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^struct formatter_wrapper$/;"	s	namespace:boost::re_detail	inherits:Formatter,unary_binary_ternary
boost::re_detail::formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^struct formatter_wrapper<Formatter *, false>$/;"	s	namespace:boost::re_detail	inherits:unary_binary_ternary
boost::re_detail::formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^struct formatter_wrapper<Formatter, true>$/;"	s	namespace:boost::re_detail	inherits:unary_binary_ternary
boost::re_detail::formatter_wrapper::formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^   formatter_wrapper(){}$/;"	f	struct:boost::re_detail::formatter_wrapper	access:public	signature:()
boost::re_detail::formatter_wrapper::operator Formatter *	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator Formatter *();$/;"	p	struct:boost::re_detail::formatter_wrapper	access:public	signature:()
boost::re_detail::format_functor1	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor1$/;"	s	namespace:boost::re_detail
boost::re_detail::format_functor1::do_format_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline OutputIter do_format_string(const S* s, OutputIter i)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const S* s, OutputIter i)
boost::re_detail::format_functor1::do_format_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter do_format_string(const S& s, OutputIter i)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const S& s, OutputIter i)
boost::re_detail::format_functor1::format_functor1	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor1(Base b) : func(b) {}$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(Base b)
boost::re_detail::format_functor1::format_functor1	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor1(const format_functor1&);$/;"	p	struct:boost::re_detail::format_functor1	access:private	signature:(const format_functor1&)
boost::re_detail::format_functor1::func	/usr/include/boost/regex/v4/regex_format.hpp	/^   Base func;$/;"	m	struct:boost::re_detail::format_functor1	access:private
boost::re_detail::format_functor1::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)
boost::re_detail::format_functor1::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type \/*f*\/)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type )
boost::re_detail::format_functor1::operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor1& operator=(const format_functor1&);$/;"	p	struct:boost::re_detail::format_functor1	access:private	signature:(const format_functor1&)
boost::re_detail::format_functor2	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor2$/;"	s	namespace:boost::re_detail
boost::re_detail::format_functor2::format_functor2	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor2(Base b) : func(b) {}$/;"	f	struct:boost::re_detail::format_functor2	access:public	signature:(Base b)
boost::re_detail::format_functor2::format_functor2	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor2(const format_functor2&);$/;"	p	struct:boost::re_detail::format_functor2	access:private	signature:(const format_functor2&)
boost::re_detail::format_functor2::func	/usr/include/boost/regex/v4/regex_format.hpp	/^   Base func;$/;"	m	struct:boost::re_detail::format_functor2	access:private
boost::re_detail::format_functor2::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)$/;"	f	struct:boost::re_detail::format_functor2	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)
boost::re_detail::format_functor2::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type \/*f*\/)$/;"	f	struct:boost::re_detail::format_functor2	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type )
boost::re_detail::format_functor2::operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor2& operator=(const format_functor2&);$/;"	p	struct:boost::re_detail::format_functor2	access:private	signature:(const format_functor2&)
boost::re_detail::format_functor3	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor3$/;"	s	namespace:boost::re_detail
boost::re_detail::format_functor3::format_functor3	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor3(Base b) : func(b) {}$/;"	f	struct:boost::re_detail::format_functor3	access:public	signature:(Base b)
boost::re_detail::format_functor3::format_functor3	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor3(const format_functor3&);$/;"	p	struct:boost::re_detail::format_functor3	access:private	signature:(const format_functor3&)
boost::re_detail::format_functor3::func	/usr/include/boost/regex/v4/regex_format.hpp	/^   Base func;$/;"	m	struct:boost::re_detail::format_functor3	access:private
boost::re_detail::format_functor3::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f)$/;"	f	struct:boost::re_detail::format_functor3	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f)
boost::re_detail::format_functor3::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)$/;"	f	struct:boost::re_detail::format_functor3	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)
boost::re_detail::format_functor3::operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor3& operator=(const format_functor3&);$/;"	p	struct:boost::re_detail::format_functor3	access:private	signature:(const format_functor3&)
boost::re_detail::format_functor_container	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor_container$/;"	s	namespace:boost::re_detail
boost::re_detail::format_functor_container::format_functor_container	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_container(const Container& c) : func(c) {}$/;"	f	struct:boost::re_detail::format_functor_container	access:public	signature:(const Container& c)
boost::re_detail::format_functor_container::format_functor_container	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_container(const format_functor_container&);$/;"	p	struct:boost::re_detail::format_functor_container	access:private	signature:(const format_functor_container&)
boost::re_detail::format_functor_container::func	/usr/include/boost/regex/v4/regex_format.hpp	/^   const Container& func;$/;"	m	struct:boost::re_detail::format_functor_container	access:private
boost::re_detail::format_functor_container::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())$/;"	f	struct:boost::re_detail::format_functor_container	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())
boost::re_detail::format_functor_container::operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_container& operator=(const format_functor_container&);$/;"	p	struct:boost::re_detail::format_functor_container	access:private	signature:(const format_functor_container&)
boost::re_detail::format_functor_c_string	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor_c_string$/;"	s	namespace:boost::re_detail
boost::re_detail::format_functor_c_string::format_functor_c_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_c_string(const charT* ps) : func(ps) {}$/;"	f	struct:boost::re_detail::format_functor_c_string	access:public	signature:(const charT* ps)
boost::re_detail::format_functor_c_string::format_functor_c_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_c_string(const format_functor_c_string&);$/;"	p	struct:boost::re_detail::format_functor_c_string	access:private	signature:(const format_functor_c_string&)
boost::re_detail::format_functor_c_string::func	/usr/include/boost/regex/v4/regex_format.hpp	/^   const charT* func;$/;"	m	struct:boost::re_detail::format_functor_c_string	access:private
boost::re_detail::format_functor_c_string::operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())$/;"	f	struct:boost::re_detail::format_functor_c_string	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())
boost::re_detail::format_functor_c_string::operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_c_string& operator=(const format_functor_c_string&);$/;"	p	struct:boost::re_detail::format_functor_c_string	access:private	signature:(const format_functor_c_string&)
boost::re_detail::format_traits	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_traits$/;"	s	namespace:boost::re_detail
boost::re_detail::format_traits::type	/usr/include/boost/regex/v4/regex_format.hpp	/^   >::type type;$/;"	t	struct:boost::re_detail::format_traits	access:public
boost::re_detail::format_traits_imp	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_traits_imp$/;"	s	namespace:boost::re_detail
boost::re_detail::format_traits_imp::BOOST_STATIC_ASSERT	/usr/include/boost/regex/v4/regex_format.hpp	/^   BOOST_STATIC_ASSERT((::boost::is_pointer<F>::value || ::boost::is_function<F>::value || ::boost::is_class<F>::value));$/;"	p	struct:boost::re_detail::format_traits_imp	access:private	signature:(::boost::is_pointer<F>::value || ::boost::is_function<F>::value || ::boost::is_class<F>::value)
boost::re_detail::format_traits_imp::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/regex_format.hpp	/^   BOOST_STATIC_CONSTANT(int, value = sizeof(check_is_formatter(f(m), f(m, out), f(m, out, flags))));$/;"	p	struct:boost::re_detail::format_traits_imp	access:public	signature:(int, value = sizeof(check_is_formatter(f(m), f(m, out), f(m, out, flags))))
boost::re_detail::format_traits_imp::f	/usr/include/boost/regex/v4/regex_format.hpp	/^   static formatter_wrapper<typename unwrap_reference<F>::type> f;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
boost::re_detail::format_traits_imp::flags	/usr/include/boost/regex/v4/regex_format.hpp	/^   static boost::regex_constants::match_flag_type flags;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
boost::re_detail::format_traits_imp::m	/usr/include/boost/regex/v4/regex_format.hpp	/^   static M m;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
boost::re_detail::format_traits_imp::out	/usr/include/boost/regex/v4/regex_format.hpp	/^   static O out;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
boost::re_detail::get_default_class_id	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^int get_default_class_id(const charT* p1, const charT* p2)$/;"	f	namespace:boost::re_detail	signature:(const charT* p1, const charT* p2)
boost::re_detail::get_default_error_string	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL const char* BOOST_REGEX_CALL get_default_error_string(regex_constants::error_type n);$/;"	p	namespace:boost::re_detail	signature:(regex_constants::error_type n)
boost::re_detail::get_default_escape_syntax_type	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL regex_constants::escape_syntax_type BOOST_REGEX_CALL get_default_escape_syntax_type(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
boost::re_detail::get_default_expression	/usr/include/boost/regex/v4/regex_split.hpp	/^const basic_regex<charT>& get_default_expression(charT)$/;"	f	namespace:boost::re_detail	signature:(charT)
boost::re_detail::get_default_syntax	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL const char* BOOST_REGEX_CALL get_default_syntax(regex_constants::syntax_type n);$/;"	p	namespace:boost::re_detail	signature:(regex_constants::syntax_type n)
boost::re_detail::get_default_syntax_type	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL regex_constants::syntax_type BOOST_REGEX_CALL get_default_syntax_type(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
boost::re_detail::get_escape_R_string	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline const char* get_escape_R_string<char>()$/;"	f	namespace:boost::re_detail	signature:()
boost::re_detail::get_escape_R_string	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline const charT* get_escape_R_string()$/;"	f	namespace:boost::re_detail	signature:()
boost::re_detail::get_icu_regex_traits_implementation	/usr/include/boost/regex/icu.hpp	/^inline boost::shared_ptr<icu_regex_traits_implementation> get_icu_regex_traits_implementation(const U_NAMESPACE_QUALIFIER Locale& loc)$/;"	f	namespace:boost::re_detail	signature:(const U_NAMESPACE_QUALIFIER Locale& loc)
boost::re_detail::get_mem_block	/usr/include/boost/regex/config.hpp	/^BOOST_REGEX_DECL void* BOOST_REGEX_CALL get_mem_block();$/;"	p	namespace:boost::re_detail	signature:()
boost::re_detail::global_length	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline std::ptrdiff_t global_length<char>(const char* p)$/;"	f	namespace:boost::re_detail	signature:(const char* p)
boost::re_detail::global_length	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline std::ptrdiff_t global_length<wchar_t>(const wchar_t* p)$/;"	f	namespace:boost::re_detail	signature:(const wchar_t* p)
boost::re_detail::global_length	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^std::ptrdiff_t global_length(const charT* p)$/;"	f	namespace:boost::re_detail	signature:(const charT* p)
boost::re_detail::global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline charT BOOST_REGEX_CALL global_lower(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
boost::re_detail::global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline char BOOST_REGEX_CALL global_lower<char>(char c){ return do_global_lower(c); }$/;"	f	namespace:boost::re_detail	signature:(char c)
boost::re_detail::global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline unsigned short BOOST_REGEX_CALL global_lower<unsigned short>(unsigned short c){ return do_global_lower(c); }$/;"	f	namespace:boost::re_detail	signature:(unsigned short c)
boost::re_detail::global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline wchar_t BOOST_REGEX_CALL global_lower<wchar_t>(wchar_t c){ return do_global_lower(c); }$/;"	f	namespace:boost::re_detail	signature:(wchar_t c)
boost::re_detail::global_toi	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^int global_toi(const charT*& p1, const charT* p2, int radix, const traits& t)$/;"	f	namespace:boost::re_detail	signature:(const charT*& p1, const charT* p2, int radix, const traits& t)
boost::re_detail::global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline charT BOOST_REGEX_CALL global_upper(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
boost::re_detail::global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline char BOOST_REGEX_CALL global_upper<char>(char c){ return do_global_upper(c); }$/;"	f	namespace:boost::re_detail	signature:(char c)
boost::re_detail::global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline unsigned short BOOST_REGEX_CALL global_upper<unsigned short>(unsigned short c){ return do_global_upper(c); }$/;"	f	namespace:boost::re_detail	signature:(unsigned short c)
boost::re_detail::global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline wchar_t BOOST_REGEX_CALL global_upper<wchar_t>(wchar_t c){ return do_global_upper(c); }$/;"	f	namespace:boost::re_detail	signature:(wchar_t c)
boost::re_detail::global_value	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^int global_value(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
boost::re_detail::hash_value_from_capture_name	/usr/include/boost/regex/v4/basic_regex.hpp	/^inline int hash_value_from_capture_name(Iterator i, Iterator j)$/;"	f	namespace:boost::re_detail	signature:(Iterator i, Iterator j)
boost::re_detail::icu_regex_traits_implementation	/usr/include/boost/regex/icu.hpp	/^class BOOST_REGEX_DECL icu_regex_traits_implementation$/;"	c	namespace:boost::re_detail
boost::re_detail::icu_regex_traits_implementation::char_class_type	/usr/include/boost/regex/icu.hpp	/^   typedef boost::uint_least32_t        char_class_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::char_type	/usr/include/boost/regex/icu.hpp	/^   typedef UChar32                      char_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::do_transform	/usr/include/boost/regex/icu.hpp	/^   string_type do_transform(const char_type* p1, const char_type* p2, const U_NAMESPACE_QUALIFIER Collator* pcoll) const;$/;"	p	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const char_type* p1, const char_type* p2, const U_NAMESPACE_QUALIFIER Collator* pcoll) const
boost::re_detail::icu_regex_traits_implementation::getloc	/usr/include/boost/regex/icu.hpp	/^   U_NAMESPACE_QUALIFIER Locale getloc()const$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:() const
boost::re_detail::icu_regex_traits_implementation::icu_regex_traits_implementation	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits_implementation(const U_NAMESPACE_QUALIFIER Locale& l)$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const U_NAMESPACE_QUALIFIER Locale& l)
boost::re_detail::icu_regex_traits_implementation::init_error	/usr/include/boost/regex/icu.hpp	/^   void init_error()$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:private	signature:()
boost::re_detail::icu_regex_traits_implementation::locale_type	/usr/include/boost/regex/icu.hpp	/^   typedef U_NAMESPACE_QUALIFIER Locale locale_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::m_collator	/usr/include/boost/regex/icu.hpp	/^   boost::scoped_ptr< U_NAMESPACE_QUALIFIER Collator> m_collator;          \/\/ The full collation object$/;"	m	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::m_locale	/usr/include/boost/regex/icu.hpp	/^   U_NAMESPACE_QUALIFIER Locale m_locale;                                  \/\/ The ICU locale that we're using$/;"	m	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::m_primary_collator	/usr/include/boost/regex/icu.hpp	/^   boost::scoped_ptr< U_NAMESPACE_QUALIFIER Collator> m_primary_collator;  \/\/ The primary collation object$/;"	m	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::size_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::size_t                  size_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::string_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::vector<char_type>       string_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
boost::re_detail::icu_regex_traits_implementation::transform	/usr/include/boost/regex/icu.hpp	/^   string_type transform(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const char_type* p1, const char_type* p2) const
boost::re_detail::icu_regex_traits_implementation::transform_primary	/usr/include/boost/regex/icu.hpp	/^   string_type transform_primary(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const char_type* p1, const char_type* p2) const
boost::re_detail::inplace_destroy	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void inplace_destroy(T* p)$/;"	f	namespace:boost::re_detail	signature:(T* p)
boost::re_detail::is_byte	/usr/include/boost/regex/v4/states.hpp	/^template <class charT> struct is_byte               { typedef _wide_type width_type; };$/;"	s	namespace:boost::re_detail
boost::re_detail::is_byte	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<char>         { typedef _narrow_type width_type; };$/;"	s	namespace:boost::re_detail
boost::re_detail::is_byte	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<signed char>  { typedef _narrow_type width_type; };$/;"	s	namespace:boost::re_detail
boost::re_detail::is_byte	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<unsigned char>{ typedef _narrow_type width_type; };$/;"	s	namespace:boost::re_detail
boost::re_detail::is_byte::width_type	/usr/include/boost/regex/v4/states.hpp	/^template <class charT> struct is_byte               { typedef _wide_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
boost::re_detail::is_byte::width_type	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<char>         { typedef _narrow_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
boost::re_detail::is_byte::width_type	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<signed char>  { typedef _narrow_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
boost::re_detail::is_byte::width_type	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<unsigned char>{ typedef _narrow_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
boost::re_detail::is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
boost::re_detail::is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<char>(char)$/;"	f	namespace:boost::re_detail	signature:(char)
boost::re_detail::is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<signed char>(signed char)$/;"	f	namespace:boost::re_detail	signature:(signed char)
boost::re_detail::is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<unsigned char>(unsigned char)$/;"	f	namespace:boost::re_detail	signature:(unsigned char)
boost::re_detail::is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<wchar_t>(wchar_t c)$/;"	f	namespace:boost::re_detail	signature:(wchar_t c)
boost::re_detail::is_combining_implementation	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL is_combining_implementation(uint_least16_t s);$/;"	p	namespace:boost::re_detail	signature:(uint_least16_t s)
boost::re_detail::is_extended	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_extended(char)$/;"	f	namespace:boost::re_detail	signature:(char)
boost::re_detail::is_extended	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_extended(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
boost::re_detail::is_separator	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_separator(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
boost::re_detail::is_separator	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_separator<char>(char c)$/;"	f	namespace:boost::re_detail	signature:(char c)
boost::re_detail::lcid_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^typedef ::boost::uint32_t lcid_type;   \/\/ placeholder for LCID.$/;"	t	namespace:boost::re_detail
boost::re_detail::lookup_default_collate_name	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL std::string BOOST_REGEX_CALL lookup_default_collate_name(const std::string& name);$/;"	p	namespace:boost::re_detail	signature:(const std::string& name)
boost::re_detail::make_utf32_out	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator make_utf32_out(OutputIterator o, mpl::int_<4> const*)$/;"	f	namespace:boost::re_detail	signature:(OutputIterator o, mpl::int_<4> const*)
boost::re_detail::make_utf32_out	/usr/include/boost/regex/icu.hpp	/^inline utf16_output_iterator<OutputIterator> make_utf32_out(OutputIterator o, mpl::int_<2> const*)$/;"	f	namespace:boost::re_detail	signature:(OutputIterator o, mpl::int_<2> const*)
boost::re_detail::make_utf32_out	/usr/include/boost/regex/icu.hpp	/^inline utf8_output_iterator<OutputIterator> make_utf32_out(OutputIterator o, mpl::int_<1> const*)$/;"	f	namespace:boost::re_detail	signature:(OutputIterator o, mpl::int_<1> const*)
boost::re_detail::make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(const charT* p, mpl::int_<1> const*)$/;"	f	namespace:boost::re_detail	signature:(const charT* p, mpl::int_<1> const*)
boost::re_detail::make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(const charT* p, mpl::int_<2> const*)$/;"	f	namespace:boost::re_detail	signature:(const charT* p, mpl::int_<2> const*)
boost::re_detail::make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(const charT* p, mpl::int_<4> const*)$/;"	f	namespace:boost::re_detail	signature:(const charT* p, mpl::int_<4> const*)
boost::re_detail::make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(I i, I j, mpl::int_<1> const*)$/;"	f	namespace:boost::re_detail	signature:(I i, I j, mpl::int_<1> const*)
boost::re_detail::make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(I i, I j, mpl::int_<2> const*)$/;"	f	namespace:boost::re_detail	signature:(I i, I j, mpl::int_<2> const*)
boost::re_detail::make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(I i, I j, mpl::int_<4> const*)$/;"	f	namespace:boost::re_detail	signature:(I i, I j, mpl::int_<4> const*)
boost::re_detail::mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^class BOOST_REGEX_DECL mapfile$/;"	c	namespace:boost::re_detail
boost::re_detail::mapfile::begin	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* begin(){ return _first; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
boost::re_detail::mapfile::close	/usr/include/boost/regex/v4/fileiter.hpp	/^   void close();$/;"	p	class:boost::re_detail::mapfile	access:public	signature:()
boost::re_detail::mapfile::end	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* end(){ return _last; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
boost::re_detail::mapfile::hfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   HANDLE hfile;$/;"	m	class:boost::re_detail::mapfile	access:private
boost::re_detail::mapfile::hmap	/usr/include/boost/regex/v4/fileiter.hpp	/^   HANDLE hmap;$/;"	m	class:boost::re_detail::mapfile	access:private
boost::re_detail::mapfile::iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char* iterator;$/;"	t	class:boost::re_detail::mapfile	access:public
boost::re_detail::mapfile::mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   mapfile(){ hfile = hmap = 0; _first = _last = 0; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
boost::re_detail::mapfile::mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   mapfile(const char* file){ hfile = hmap = 0; _first = _last = 0; open(file); }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:(const char* file)
boost::re_detail::mapfile::open	/usr/include/boost/regex/v4/fileiter.hpp	/^   void open(const char* file);$/;"	p	class:boost::re_detail::mapfile	access:public	signature:(const char* file)
boost::re_detail::mapfile::size	/usr/include/boost/regex/v4/fileiter.hpp	/^   size_t size(){ return _last - _first; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
boost::re_detail::mapfile::valid	/usr/include/boost/regex/v4/fileiter.hpp	/^   bool valid(){ return (hfile != 0) && (hfile != INVALID_HANDLE_VALUE); }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
boost::re_detail::mapfile::_first	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* _first;$/;"	m	class:boost::re_detail::mapfile	access:private
boost::re_detail::mapfile::_last	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* _last;$/;"	m	class:boost::re_detail::mapfile	access:private
boost::re_detail::mapfile::~mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   ~mapfile(){ close(); }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
boost::re_detail::mask_all	/usr/include/boost/regex/v4/states.hpp	/^   mask_all = mask_any$/;"	e	enum:boost::re_detail::mask_type
boost::re_detail::mask_any	/usr/include/boost/regex/v4/states.hpp	/^   mask_any = mask_skip | mask_take,$/;"	e	enum:boost::re_detail::mask_type
boost::re_detail::mask_init	/usr/include/boost/regex/v4/states.hpp	/^   mask_init = 4,$/;"	e	enum:boost::re_detail::mask_type
boost::re_detail::mask_skip	/usr/include/boost/regex/v4/states.hpp	/^   mask_skip = 2,$/;"	e	enum:boost::re_detail::mask_type
boost::re_detail::mask_take	/usr/include/boost/regex/v4/states.hpp	/^   mask_take = 1,$/;"	e	enum:boost::re_detail::mask_type
boost::re_detail::mask_type	/usr/include/boost/regex/v4/states.hpp	/^enum mask_type$/;"	g	namespace:boost::re_detail
boost::re_detail::mem_block_cache	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^struct mem_block_cache$/;"	s	namespace:boost::re_detail
boost::re_detail::mem_block_cache::cached_blocks	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   unsigned cached_blocks;$/;"	m	struct:boost::re_detail::mem_block_cache	access:public
boost::re_detail::mem_block_cache::get	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   void* get()$/;"	f	struct:boost::re_detail::mem_block_cache	access:public	signature:()
boost::re_detail::mem_block_cache::mut	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   boost::static_mutex mut;$/;"	m	struct:boost::re_detail::mem_block_cache	access:public
boost::re_detail::mem_block_cache::next	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   mem_block_node* next;$/;"	m	struct:boost::re_detail::mem_block_cache	access:public
boost::re_detail::mem_block_cache::put	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   void put(void* p)$/;"	f	struct:boost::re_detail::mem_block_cache	access:public	signature:(void* p)
boost::re_detail::mem_block_cache::~mem_block_cache	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   ~mem_block_cache()$/;"	f	struct:boost::re_detail::mem_block_cache	access:public	signature:()
boost::re_detail::mem_block_node	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^struct mem_block_node$/;"	s	namespace:boost::re_detail
boost::re_detail::mem_block_node::next	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   mem_block_node* next;$/;"	m	struct:boost::re_detail::mem_block_node	access:public
boost::re_detail::mfc_string_out_iterator	/usr/include/boost/regex/mfc.hpp	/^class mfc_string_out_iterator$/;"	c	namespace:boost::re_detail
boost::re_detail::mfc_string_out_iterator::difference_type	/usr/include/boost/regex/mfc.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
boost::re_detail::mfc_string_out_iterator::iterator_category	/usr/include/boost/regex/mfc.hpp	/^   typedef std::output_iterator_tag iterator_category;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
boost::re_detail::mfc_string_out_iterator::mfc_string_out_iterator	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator(ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s) : out(&s) {}$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:(ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s)
boost::re_detail::mfc_string_out_iterator::operator *	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator*() { return *this; }$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:()
boost::re_detail::mfc_string_out_iterator::operator ++	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator++() { return *this; }$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:()
boost::re_detail::mfc_string_out_iterator::operator ++	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator++(int) { return *this; }$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:(int)
boost::re_detail::mfc_string_out_iterator::operator =	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator=(B v) $/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:(B v)
boost::re_detail::mfc_string_out_iterator::out	/usr/include/boost/regex/mfc.hpp	/^   ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>* out;$/;"	m	class:boost::re_detail::mfc_string_out_iterator	access:private
boost::re_detail::mfc_string_out_iterator::pointer	/usr/include/boost/regex/mfc.hpp	/^   typedef value_type* pointer;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
boost::re_detail::mfc_string_out_iterator::reference	/usr/include/boost/regex/mfc.hpp	/^   typedef value_type& reference;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
boost::re_detail::mfc_string_out_iterator::value_type	/usr/include/boost/regex/mfc.hpp	/^   typedef B value_type;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
boost::re_detail::named_subexpressions	/usr/include/boost/regex/v4/basic_regex.hpp	/^class named_subexpressions$/;"	c	namespace:boost::re_detail
boost::re_detail::named_subexpressions::const_iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::vector<name>::const_iterator const_iterator;$/;"	t	class:boost::re_detail::named_subexpressions	access:public
boost::re_detail::named_subexpressions::equal_range	/usr/include/boost/regex/v4/basic_regex.hpp	/^   range_type equal_range(const charT* i, const charT* j)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(const charT* i, const charT* j) const
boost::re_detail::named_subexpressions::equal_range	/usr/include/boost/regex/v4/basic_regex.hpp	/^   range_type equal_range(int h)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(int h) const
boost::re_detail::named_subexpressions::get_id	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int get_id(const charT* i, const charT* j)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(const charT* i, const charT* j) const
boost::re_detail::named_subexpressions::get_id	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int get_id(int h)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(int h) const
boost::re_detail::named_subexpressions::m_sub_names	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::vector<name> m_sub_names;$/;"	m	class:boost::re_detail::named_subexpressions	access:private
boost::re_detail::named_subexpressions::name	/usr/include/boost/regex/v4/basic_regex.hpp	/^   struct name$/;"	s	class:boost::re_detail::named_subexpressions	access:public
boost::re_detail::named_subexpressions::name::hash	/usr/include/boost/regex/v4/basic_regex.hpp	/^      int hash;$/;"	m	struct:boost::re_detail::named_subexpressions::name	access:public
boost::re_detail::named_subexpressions::name::index	/usr/include/boost/regex/v4/basic_regex.hpp	/^      int index;$/;"	m	struct:boost::re_detail::named_subexpressions::name	access:public
boost::re_detail::named_subexpressions::name::name	/usr/include/boost/regex/v4/basic_regex.hpp	/^      name(const charT* i, const charT* j, int idx)$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(const charT* i, const charT* j, int idx)
boost::re_detail::named_subexpressions::name::name	/usr/include/boost/regex/v4/basic_regex.hpp	/^      name(int h, int idx)$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(int h, int idx)
boost::re_detail::named_subexpressions::name::operator <	/usr/include/boost/regex/v4/basic_regex.hpp	/^      bool operator < (const name& other)const$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(const name& other) const
boost::re_detail::named_subexpressions::name::operator ==	/usr/include/boost/regex/v4/basic_regex.hpp	/^      bool operator == (const name& other)const$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(const name& other) const
boost::re_detail::named_subexpressions::name::swap	/usr/include/boost/regex/v4/basic_regex.hpp	/^      void swap(name& other)$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(name& other)
boost::re_detail::named_subexpressions::named_subexpressions	/usr/include/boost/regex/v4/basic_regex.hpp	/^   named_subexpressions(){}$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:()
boost::re_detail::named_subexpressions::range_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::pair<const_iterator, const_iterator> range_type;$/;"	t	class:boost::re_detail::named_subexpressions	access:public
boost::re_detail::named_subexpressions::set_name	/usr/include/boost/regex/v4/basic_regex.hpp	/^   void set_name(const charT* i, const charT* j, int index)$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(const charT* i, const charT* j, int index)
boost::re_detail::no_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char no_type;$/;"	t	namespace:boost::re_detail
boost::re_detail::offset_type	/usr/include/boost/regex/v4/states.hpp	/^union offset_type$/;"	u	namespace:boost::re_detail
boost::re_detail::offset_type::i	/usr/include/boost/regex/v4/states.hpp	/^   std::ptrdiff_t    i;$/;"	m	union:boost::re_detail::offset_type	access:public
boost::re_detail::offset_type::p	/usr/include/boost/regex/v4/states.hpp	/^   re_syntax_base*   p;$/;"	m	union:boost::re_detail::offset_type	access:public
boost::re_detail::operator <	/usr/include/boost/regex/v4/fileiter.hpp	/^inline bool operator < (const directory_iterator&, const directory_iterator&)$/;"	f	namespace:boost::re_detail	signature:(const directory_iterator&, const directory_iterator&)
boost::re_detail::operator <	/usr/include/boost/regex/v4/fileiter.hpp	/^inline bool operator < (const file_iterator&, const file_iterator&)$/;"	f	namespace:boost::re_detail	signature:(const file_iterator&, const file_iterator&)
boost::re_detail::operator <<	/usr/include/boost/regex/v4/states.hpp	/^std::ostream& operator<<(std::ostream&, syntax_element_type);$/;"	p	namespace:boost::re_detail	signature:(std::ostream&, syntax_element_type)
boost::re_detail::overflow_error_if_not_zero	/usr/include/boost/regex/v4/regex_workaround.hpp	/^   inline void overflow_error_if_not_zero(std::size_t i)$/;"	f	namespace:boost::re_detail	signature:(std::size_t i)
boost::re_detail::padding	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^union padding$/;"	u	namespace:boost::re_detail
boost::re_detail::padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3$/;"	s	namespace:boost::re_detail
boost::re_detail::padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<16>$/;"	s	namespace:boost::re_detail
boost::re_detail::padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<2>$/;"	s	namespace:boost::re_detail
boost::re_detail::padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<4>$/;"	s	namespace:boost::re_detail
boost::re_detail::padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<8>$/;"	s	namespace:boost::re_detail
boost::re_detail::padding3::padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 1$/;"	e	enum:boost::re_detail::padding3::__anon11
boost::re_detail::padding3::padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 15$/;"	e	enum:boost::re_detail::padding3::__anon14
boost::re_detail::padding3::padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 3$/;"	e	enum:boost::re_detail::padding3::__anon12
boost::re_detail::padding3::padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 7$/;"	e	enum:boost::re_detail::padding3::__anon10
boost::re_detail::padding3::padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 7$/;"	e	enum:boost::re_detail::padding3::__anon13
boost::re_detail::padding3::padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 16,$/;"	e	enum:boost::re_detail::padding3::__anon14
boost::re_detail::padding3::padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 2,$/;"	e	enum:boost::re_detail::padding3::__anon11
boost::re_detail::padding3::padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 4,$/;"	e	enum:boost::re_detail::padding3::__anon12
boost::re_detail::padding3::padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 8,$/;"	e	enum:boost::re_detail::padding3::__anon10
boost::re_detail::padding3::padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 8,$/;"	e	enum:boost::re_detail::padding3::__anon13
boost::re_detail::padding::i	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   unsigned int i;$/;"	m	union:boost::re_detail::padding	access:public
boost::re_detail::padding::p	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* p;$/;"	m	union:boost::re_detail::padding	access:public
boost::re_detail::padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   padding_mask = padding3<sizeof(padding)>::padding_mask$/;"	e	enum:boost::re_detail::__anon15
boost::re_detail::padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   padding_size = padding3<sizeof(padding)>::padding_size,$/;"	e	enum:boost::re_detail::__anon15
boost::re_detail::parser_buf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class parser_buf : public ::std::basic_streambuf<charT, traits>$/;"	c	namespace:boost::re_detail	inherits:::std::basic_streambuf
boost::re_detail::parser_buf::base_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef ::std::basic_streambuf<charT, traits> base_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
boost::re_detail::parser_buf::char_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::char_type char_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
boost::re_detail::parser_buf::getnext	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   const charT* getnext() { return this->gptr(); }$/;"	f	class:boost::re_detail::parser_buf	access:public	signature:()
boost::re_detail::parser_buf::int_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::int_type int_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
boost::re_detail::parser_buf::off_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::off_type off_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
boost::re_detail::parser_buf::operator =	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   parser_buf& operator=(const parser_buf&);$/;"	p	class:boost::re_detail::parser_buf	access:private	signature:(const parser_buf&)
boost::re_detail::parser_buf::parser_buf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   parser_buf() : base_type() { setbuf(0, 0); }$/;"	f	class:boost::re_detail::parser_buf	access:public	signature:()
boost::re_detail::parser_buf::parser_buf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   parser_buf(const parser_buf&);$/;"	p	class:boost::re_detail::parser_buf	access:private	signature:(const parser_buf&)
boost::re_detail::parser_buf::pos_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::pos_type pos_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
boost::re_detail::parser_buf::seekoff	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typename parser_buf<charT, traits>::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which);$/;"	p	class:boost::re_detail::parser_buf	access:protected	signature:(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
boost::re_detail::parser_buf::seekoff	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^parser_buf<charT, traits>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)$/;"	f	class:boost::re_detail::parser_buf	signature:(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
boost::re_detail::parser_buf::seekpos	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typename parser_buf<charT, traits>::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which);$/;"	p	class:boost::re_detail::parser_buf	access:protected	signature:(pos_type sp, ::std::ios_base::openmode which)
boost::re_detail::parser_buf::seekpos	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^parser_buf<charT, traits>::seekpos(pos_type sp, ::std::ios_base::openmode which)$/;"	f	class:boost::re_detail::parser_buf	signature:(pos_type sp, ::std::ios_base::openmode which)
boost::re_detail::parser_buf::setbuf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::basic_streambuf<charT, traits>* setbuf(char_type* s, streamsize n);$/;"	p	class:boost::re_detail::parser_buf	access:protected	signature:(char_type* s, streamsize n)
boost::re_detail::parser_buf::setbuf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^parser_buf<charT, traits>::setbuf(char_type* s, streamsize n)$/;"	f	class:boost::re_detail::parser_buf	signature:(char_type* s, streamsize n)
boost::re_detail::parser_buf::streamsize	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef ::std::streamsize streamsize;$/;"	t	class:boost::re_detail::parser_buf	access:private
boost::re_detail::perl_matcher	/usr/include/boost/regex/v4/perl_matcher.hpp	/^class perl_matcher$/;"	c	namespace:boost::re_detail
boost::re_detail::perl_matcher::backstop	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator backstop;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::backtrack_till_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool backtrack_till_match(std::size_t count);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(std::size_t count)
boost::re_detail::perl_matcher::backtrack_till_match	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::backtrack_till_match(std::size_t count)$/;"	f	class:boost::re_detail::perl_matcher	signature:(std::size_t count)
boost::re_detail::perl_matcher::base	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator base;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::char_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename traits::char_type char_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
boost::re_detail::perl_matcher::construct_init	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void construct_init(const basic_regex<char_type, traits>& e, match_flag_type f);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const basic_regex<char_type, traits>& e, match_flag_type f)
boost::re_detail::perl_matcher::construct_init	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::construct_init(const basic_regex<char_type, traits>& e, match_flag_type f)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const basic_regex<char_type, traits>& e, match_flag_type f)
boost::re_detail::perl_matcher::destroy_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void destroy_single_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::destroy_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::destroy_single_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::difference_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename regex_iterator_traits<BidiIterator>::difference_type difference_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
boost::re_detail::perl_matcher::estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void estimate_max_state_count(std::random_access_iterator_tag*);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(std::random_access_iterator_tag*)
boost::re_detail::perl_matcher::estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void estimate_max_state_count(void*);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(void*)
boost::re_detail::perl_matcher::estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::estimate_max_state_count(void*)$/;"	f	class:boost::re_detail::perl_matcher	signature:(void*)
boost::re_detail::perl_matcher::estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::estimate_max_state_count(std::random_access_iterator_tag*)$/;"	f	class:boost::re_detail::perl_matcher	signature:(std::random_access_iterator_tag*)
boost::re_detail::perl_matcher::extend_stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void extend_stack();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::extend_stack	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::extend_stack()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::find	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find();$/;"	p	class:boost::re_detail::perl_matcher	access:public	signature:()
boost::re_detail::perl_matcher::find	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::find()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::find_imp	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_imp();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::find_imp	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_imp()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::find_restart_any	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_any();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::find_restart_any	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_any()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::find_restart_buf	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_buf();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::find_restart_buf	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_buf()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::find_restart_line	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_line();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::find_restart_line	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_line()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::find_restart_lit	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_lit();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::find_restart_lit	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_lit()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::find_restart_word	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_word();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::find_restart_word	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_word()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::icase	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool icase;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::last	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator last; $/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match();$/;"	p	class:boost::re_detail::perl_matcher	access:public	signature:()
boost::re_detail::perl_matcher::match	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::match()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::matcher_proc_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef bool (self_type::*matcher_proc_type)(void);$/;"	t	class:boost::re_detail::perl_matcher	access:public
boost::re_detail::perl_matcher::match_all_states	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_all_states();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_all_states	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_all_states()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_all_states	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_all_states()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_alt();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_alt	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_alt()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_alt	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_alt()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_any_mask	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   unsigned char match_any_mask;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::match_assert_backref	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_assert_backref();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_assert_backref	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::match_assert_backref()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_backref	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_backref();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_backref	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_backref()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_backstep	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_backstep();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_backstep	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_backstep()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_buffer_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_buffer_end();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_buffer_end	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_buffer_end()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_buffer_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_buffer_start();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_buffer_start	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_buffer_start()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_char_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_char_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_char_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_char_repeat	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_combining	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_combining();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_combining	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_combining()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_dot_repeat_dispatch	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_dot_repeat_dispatch()$/;"	f	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_dot_repeat_fast	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_dot_repeat_fast();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_dot_repeat_fast	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_dot_repeat_fast	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_dot_repeat_slow	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_dot_repeat_slow();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_dot_repeat_slow	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_dot_repeat_slow	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_endmark	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_endmark();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_endmark	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_endmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_endmark	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_endmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_end_line	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_end_line();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_end_line	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_end_line()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_imp	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_imp();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_imp	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_imp()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_jump	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_jump();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_jump	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_jump()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_literal	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_literal();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_literal	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_literal()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_long_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_long_set();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_long_set	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_long_set_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_match();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_match	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_match()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_match	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_match()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_prefix	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_prefix();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_prefix	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_prefix()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_recursion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_recursion();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_recursion()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_recursion	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_recursion()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_rep	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_rep();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_rep	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_rep()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_rep	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_rep()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_restart_continue	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_restart_continue();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_restart_continue	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_restart_continue()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_set();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_set	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_set()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_set_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_set_repeat	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_soft_buffer_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_soft_buffer_end();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_soft_buffer_end	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_soft_buffer_end()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_startmark	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_startmark();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_startmark	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_startmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_startmark	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_startmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_start_line	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_start_line();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_start_line	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_start_line()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_toggle_case	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_toggle_case();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_toggle_case	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_wild	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_wild();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_wild	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_wild()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_within_word	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_within_word();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_within_word	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_within_word()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_word_boundary	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_word_boundary();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_word_boundary	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_word_boundary()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_word_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_word_end();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_word_end	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_word_end()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::match_word_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_word_start();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::match_word_start	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_word_start()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::max_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::ptrdiff_t max_state_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_backup_state	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state* m_backup_state;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_has_found_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_has_found_match;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_has_partial_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_has_partial_match;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_independent	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_independent;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_match_flags	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   match_flag_type m_match_flags;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_presult	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   match_results<BidiIterator, Allocator>* m_presult;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_recursive_result	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_recursive_result;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_result	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   match_results<BidiIterator, Allocator>& m_result;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_stack_base	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state* m_stack_base;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_temp_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   scoped_ptr<match_results<BidiIterator, Allocator> > m_temp_match;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::m_word_mask	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typename traits::char_class_type m_word_mask;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::next_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count<BidiIterator>* next_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::operator =	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   perl_matcher& operator=(const perl_matcher&)$/;"	f	class:boost::re_detail::perl_matcher	access:private	signature:(const perl_matcher&)
boost::re_detail::perl_matcher::perl_matcher	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   perl_matcher(BidiIterator first, BidiIterator end, $/;"	f	class:boost::re_detail::perl_matcher	access:public	signature:(BidiIterator first, BidiIterator end, match_results<BidiIterator, Allocator>& what, const basic_regex<char_type, traits>& e, match_flag_type f, BidiIterator l_base)
boost::re_detail::perl_matcher::perl_matcher	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   perl_matcher(const perl_matcher& that)$/;"	f	class:boost::re_detail::perl_matcher	access:private	signature:(const perl_matcher& that)
boost::re_detail::perl_matcher::position	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator position;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::protected_call	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool protected_call(protected_proc_type);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(protected_proc_type)
boost::re_detail::perl_matcher::protected_call	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::protected_call($/;"	f	class:boost::re_detail::perl_matcher	signature:( protected_proc_type proc)
boost::re_detail::perl_matcher::protected_proc_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef bool (perl_matcher::*protected_proc_type)();$/;"	t	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::pstate	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const re_syntax_base* pstate;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::push_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_alt(const re_syntax_base* ps);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const re_syntax_base* ps)
boost::re_detail::perl_matcher::push_alt	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_alt(const re_syntax_base* ps)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const re_syntax_base* ps)
boost::re_detail::perl_matcher::push_assertion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_assertion(const re_syntax_base* ps, bool positive);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const re_syntax_base* ps, bool positive)
boost::re_detail::perl_matcher::push_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_assertion(const re_syntax_base* ps, bool positive)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const re_syntax_base* ps, bool positive)
boost::re_detail::perl_matcher::push_matched_paren	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_matched_paren(int index, const sub_match<BidiIterator>& sub);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(int index, const sub_match<BidiIterator>& sub)
boost::re_detail::perl_matcher::push_matched_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_matched_paren(int index, const sub_match<BidiIterator>& sub)$/;"	f	class:boost::re_detail::perl_matcher	signature:(int index, const sub_match<BidiIterator>& sub)
boost::re_detail::perl_matcher::push_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_non_greedy_repeat(const re_syntax_base* ps);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const re_syntax_base* ps)
boost::re_detail::perl_matcher::push_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_non_greedy_repeat(const re_syntax_base* ps)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const re_syntax_base* ps)
boost::re_detail::perl_matcher::push_recursion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_recursion(int idx, const re_syntax_base* p, results_type* presults);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(int idx, const re_syntax_base* p, results_type* presults)
boost::re_detail::perl_matcher::push_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion(int idx, const re_syntax_base* p, results_type* presults)$/;"	f	class:boost::re_detail::perl_matcher	signature:(int idx, const re_syntax_base* p, results_type* presults)
boost::re_detail::perl_matcher::push_recursion_pop	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_recursion_pop();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::push_recursion_pop	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_pop()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::push_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_recursion_stopper();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
boost::re_detail::perl_matcher::push_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_stopper()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
boost::re_detail::perl_matcher::push_repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_repeater_count(int i, repeater_count<BidiIterator>** s);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(int i, repeater_count<BidiIterator>** s)
boost::re_detail::perl_matcher::push_repeater_count	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_repeater_count(int i, repeater_count<BidiIterator>** s)$/;"	f	class:boost::re_detail::perl_matcher	signature:(int i, repeater_count<BidiIterator>** s)
boost::re_detail::perl_matcher::push_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
boost::re_detail::perl_matcher::push_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)$/;"	f	class:boost::re_detail::perl_matcher	signature:(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
boost::re_detail::perl_matcher::re	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const basic_regex<char_type, traits>& re;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::recursion_stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::vector<recursion_info<results_type> > recursion_stack;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::rep_obj	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count<BidiIterator> rep_obj;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::restart	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator restart;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::results_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef match_results<BidiIterator, Allocator> results_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
boost::re_detail::perl_matcher::search_base	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator search_base;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::self_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef perl_matcher<BidiIterator, Allocator, traits> self_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
boost::re_detail::perl_matcher::setf	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void setf(match_flag_type f)$/;"	f	class:boost::re_detail::perl_matcher	access:public	signature:(match_flag_type f)
boost::re_detail::perl_matcher::state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::ptrdiff_t state_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::traits_inst	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const ::boost::regex_traits_wrapper<traits>& traits_inst;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::traits_size_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef std::size_t traits_size_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
boost::re_detail::perl_matcher::unsetf	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void unsetf(match_flag_type f)$/;"	f	class:boost::re_detail::perl_matcher	access:public	signature:(match_flag_type f)
boost::re_detail::perl_matcher::unwind	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind(bool have_match)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool have_match)
boost::re_detail::perl_matcher::unwind_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_alt(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_alt	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_alt(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_assertion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_assertion(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_char_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_char_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_char_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_end(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_end	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_end(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
boost::re_detail::perl_matcher::unwind_extra_block	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_extra_block(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_extra_block	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
boost::re_detail::perl_matcher::unwind_fast_dot_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_fast_dot_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_fast_dot_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_greedy_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_greedy_single_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_greedy_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_long_set_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_non_greedy_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_paren	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_paren(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_paren(bool have_match)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool have_match)
boost::re_detail::perl_matcher::unwind_proc_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef bool (self_type::*unwind_proc_type)(bool);$/;"	t	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::unwind_recursion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_recursion(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_recursion_pop	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_recursion_pop(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_recursion_pop	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_pop(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_recursion_stopper(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
boost::re_detail::perl_matcher::unwind_repeater_counter	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_repeater_counter(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_repeater_counter	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
boost::re_detail::perl_matcher::unwind_short_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_short_set_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_short_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::unwind_slow_dot_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_slow_dot_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
boost::re_detail::perl_matcher::unwind_slow_dot_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
boost::re_detail::perl_matcher::used_block_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   unsigned used_block_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
boost::re_detail::perl_matcher::width_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename is_byte<char_type>::width_type width_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
boost::re_detail::pointer_construct	/usr/include/boost/regex/v4/regex_workaround.hpp	/^inline void pointer_construct(T* p, const T& t)$/;"	f	namespace:boost::re_detail	signature:(T* p, const T& t)
boost::re_detail::pointer_destroy	/usr/include/boost/regex/v4/regex_workaround.hpp	/^inline void pointer_destroy(T* p)$/;"	f	namespace:boost::re_detail	signature:(T* p)
boost::re_detail::pointer_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct pointer_iterator_traits$/;"	s	namespace:boost::re_detail
boost::re_detail::pointer_iterator_traits::difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
boost::re_detail::pointer_iterator_traits::iterator_category	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::random_access_iterator_tag iterator_category;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
boost::re_detail::pointer_iterator_traits::pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T* pointer;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
boost::re_detail::pointer_iterator_traits::reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T& reference;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
boost::re_detail::pointer_iterator_traits::value_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T value_type;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
boost::re_detail::put_mem_block	/usr/include/boost/regex/config.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL put_mem_block(void*);$/;"	p	namespace:boost::re_detail	signature:(void*)
boost::re_detail::raise_error	/usr/include/boost/regex/pattern_except.hpp	/^void raise_error(const traits& t, regex_constants::error_type code)$/;"	f	namespace:boost::re_detail	signature:(const traits& t, regex_constants::error_type code)
boost::re_detail::raise_runtime_error	/usr/include/boost/regex/pattern_except.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL raise_runtime_error(const std::runtime_error& ex);$/;"	p	namespace:boost::re_detail	signature:(const std::runtime_error& ex)
boost::re_detail::raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^class BOOST_REGEX_DECL raw_storage$/;"	c	namespace:boost::re_detail
boost::re_detail::raw_storage::align	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void BOOST_REGEX_CALL align()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
boost::re_detail::raw_storage::capacity	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   size_type BOOST_REGEX_CALL capacity()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
boost::re_detail::raw_storage::clear	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void BOOST_REGEX_CALL clear()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
boost::re_detail::raw_storage::data	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* BOOST_REGEX_CALL data()const$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:() const
boost::re_detail::raw_storage::end	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   pointer last, start, end;$/;"	m	class:boost::re_detail::raw_storage	access:private
boost::re_detail::raw_storage::extend	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* BOOST_REGEX_CALL extend(size_type n)$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:(size_type n)
boost::re_detail::raw_storage::index	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   size_type BOOST_REGEX_CALL index(void* ptr)$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:(void* ptr)
boost::re_detail::raw_storage::insert	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* BOOST_REGEX_CALL insert(size_type pos, size_type n);$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:(size_type pos, size_type n)
boost::re_detail::raw_storage::last	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   pointer last, start, end;$/;"	m	class:boost::re_detail::raw_storage	access:private
boost::re_detail::raw_storage::pointer	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   typedef unsigned char*        pointer;$/;"	t	class:boost::re_detail::raw_storage	access:public
boost::re_detail::raw_storage::raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   raw_storage();$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:()
boost::re_detail::raw_storage::raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   raw_storage(size_type n);$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:(size_type n)
boost::re_detail::raw_storage::raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^inline raw_storage::raw_storage()$/;"	f	class:boost::re_detail::raw_storage	signature:()
boost::re_detail::raw_storage::raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^inline raw_storage::raw_storage(size_type n)$/;"	f	class:boost::re_detail::raw_storage	signature:(size_type n)
boost::re_detail::raw_storage::resize	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void BOOST_REGEX_CALL resize(size_type n);$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:(size_type n)
boost::re_detail::raw_storage::size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   size_type BOOST_REGEX_CALL size()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
boost::re_detail::raw_storage::size_type	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   typedef std::size_t           size_type;$/;"	t	class:boost::re_detail::raw_storage	access:public
boost::re_detail::raw_storage::start	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   pointer last, start, end;$/;"	m	class:boost::re_detail::raw_storage	access:private
boost::re_detail::raw_storage::swap	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void swap(raw_storage& that)$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:(raw_storage& that)
boost::re_detail::raw_storage::~raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   ~raw_storage()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
boost::re_detail::recursion_info	/usr/include/boost/regex/v4/perl_matcher.hpp	/^struct recursion_info$/;"	s	namespace:boost::re_detail
boost::re_detail::recursion_info::idx	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   int idx;$/;"	m	struct:boost::re_detail::recursion_info	access:public
boost::re_detail::recursion_info::iterator	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename value_type::iterator iterator;$/;"	t	struct:boost::re_detail::recursion_info	access:public
boost::re_detail::recursion_info::preturn_address	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const re_syntax_base* preturn_address;$/;"	m	struct:boost::re_detail::recursion_info	access:public
boost::re_detail::recursion_info::repeater_stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count<iterator>* repeater_stack;$/;"	m	struct:boost::re_detail::recursion_info	access:public
boost::re_detail::recursion_info::results	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   Results results;$/;"	m	struct:boost::re_detail::recursion_info	access:public
boost::re_detail::recursion_info::value_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename Results::value_type value_type;$/;"	t	struct:boost::re_detail::recursion_info	access:public
boost::re_detail::regex_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^struct regex_data : public named_subexpressions$/;"	s	namespace:boost::re_detail	inherits:named_subexpressions
boost::re_detail::regex_data::flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef regex_constants::syntax_option_type   flag_type;$/;"	t	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_can_be_null	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int                m_can_be_null;             \/\/ whether we can match a null string$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   re_detail::raw_storage      m_data;                    \/\/ the buffer in which our states are constructed$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const charT*                m_expression;              \/\/ the original expression$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_expression_len	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::ptrdiff_t              m_expression_len;          \/\/ the length of the original expression$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_first_state	/usr/include/boost/regex/v4/basic_regex.hpp	/^   re_detail::re_syntax_base*  m_first_state;             \/\/ the first state of the machine$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_flags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type                   m_flags;                   \/\/ flags with which we were compiled$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_has_recursions	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool                        m_has_recursions;          \/\/ whether we have recursive expressions;$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_mark_count	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type                   m_mark_count;              \/\/ the number of marked sub-expressions$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_ptraits	/usr/include/boost/regex/v4/basic_regex.hpp	/^      >                        m_ptraits;                 \/\/ traits class instance$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_restart_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned                    m_restart_type;            \/\/ search optimisation type$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_startmap	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned char               m_startmap[1 << CHAR_BIT]; \/\/ which characters can start a match$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_status	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int                         m_status;                  \/\/ error code (0 implies OK).$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_subs	/usr/include/boost/regex/v4/basic_regex.hpp	/^      std::size_t, std::size_t> > m_subs;                 \/\/ Position of sub-expressions within the *string*.$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::m_word_mask	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typename traits::char_class_type    m_word_mask;       \/\/ mask used to determine if a character is a word character$/;"	m	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_data::regex_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   regex_data() $/;"	f	struct:boost::re_detail::regex_data	access:public	signature:()
boost::re_detail::regex_data::regex_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   regex_data(const ::boost::shared_ptr<$/;"	f	struct:boost::re_detail::regex_data	access:public	signature:(const ::boost::shared_ptr< ::boost::regex_traits_wrapper<traits> >& t)
boost::re_detail::regex_data::size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           size_type;  $/;"	t	struct:boost::re_detail::regex_data	access:public
boost::re_detail::regex_format_imp	/usr/include/boost/regex/v4/regex_format.hpp	/^OutputIterator regex_format_imp(OutputIterator out,$/;"	f	namespace:boost::re_detail	signature:(OutputIterator out, const match_results<Iterator, Alloc>& m, ForwardIter p1, ForwardIter p2, match_flag_type flags, const traits& t )
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits $/;"	s	namespace:boost::re_detail
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<char*> : pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const char*> : const_pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const int*> : const_pointer_iterator_traits<int>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const unsigned char*> : const_pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const unsigned short*> : const_pointer_iterator_traits<unsigned short>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const wchar_t*> : const_pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<int*> : pointer_iterator_traits<int>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::string::const_iterator> : const_pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::string::iterator> : pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::wstring::const_iterator> : const_pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::wstring::iterator> : pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<unsigned char*> : pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<unsigned short*> : pointer_iterator_traits<unsigned short>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
boost::re_detail::regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<wchar_t*> : pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
boost::re_detail::regex_iterator_traits::difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef std::ptrdiff_t                difference_type;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::regex_iterator_traits::difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::difference_type   difference_type;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::regex_iterator_traits::iterator_category	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::iterator_category iterator_category;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::regex_iterator_traits::pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::pointer           pointer;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::regex_iterator_traits::pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef value_type*                   pointer;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::regex_iterator_traits::reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::reference         reference;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::regex_iterator_traits::reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef value_type&                   reference;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::regex_iterator_traits::value_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::value_type        value_type;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
boost::re_detail::repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^class repeater_count$/;"	c	namespace:boost::re_detail
boost::re_detail::repeater_count::check_null_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool check_null_repeat(const BidiIterator& pos, std::size_t max)$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:(const BidiIterator& pos, std::size_t max)
boost::re_detail::repeater_count::count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::size_t count;        \/\/ the number of iterations so far$/;"	m	class:boost::re_detail::repeater_count	access:private
boost::re_detail::repeater_count::get_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::size_t get_count() { return count; }$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
boost::re_detail::repeater_count::get_id	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   int get_id() { return state_id; }$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
boost::re_detail::repeater_count::next	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count* next;$/;"	m	class:boost::re_detail::repeater_count	access:private
boost::re_detail::repeater_count::operator ++	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::size_t operator++() { return ++count; }$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
boost::re_detail::repeater_count::repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count(int i, repeater_count** s, BidiIterator start)$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:(int i, repeater_count** s, BidiIterator start)
boost::re_detail::repeater_count::repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count(repeater_count** s)$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:(repeater_count** s)
boost::re_detail::repeater_count::stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count** stack;$/;"	m	class:boost::re_detail::repeater_count	access:private
boost::re_detail::repeater_count::start_pos	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator start_pos;   \/\/ where the last repeat started$/;"	m	class:boost::re_detail::repeater_count	access:private
boost::re_detail::repeater_count::state_id	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   int state_id;$/;"	m	class:boost::re_detail::repeater_count	access:private
boost::re_detail::repeater_count::~repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   ~repeater_count()$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
boost::re_detail::reset_stack_guard_page	/usr/include/boost/regex/config.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL reset_stack_guard_page();$/;"	p	namespace:boost::re_detail	signature:()
boost::re_detail::re_alt	/usr/include/boost/regex/v4/states.hpp	/^struct re_alt : public re_jump$/;"	s	namespace:boost::re_detail	inherits:re_jump
boost::re_detail::re_alt::can_be_null	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int    can_be_null;         \/\/ true if we match a NULL string$/;"	m	struct:boost::re_detail::re_alt	access:public
boost::re_detail::re_alt::_map	/usr/include/boost/regex/v4/states.hpp	/^   unsigned char   _map[1 << CHAR_BIT]; \/\/ which characters can take the jump$/;"	m	struct:boost::re_detail::re_alt	access:public
boost::re_detail::re_alt_size	/usr/include/boost/regex/v4/states.hpp	/^   re_alt_size = (sizeof(re_alt) + padding_mask) & ~(padding_mask)$/;"	e	enum:boost::re_detail::re_jump_size_type
boost::re_detail::re_brace	/usr/include/boost/regex/v4/states.hpp	/^struct re_brace : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
boost::re_detail::re_brace::icase	/usr/include/boost/regex/v4/states.hpp	/^   bool icase;$/;"	m	struct:boost::re_detail::re_brace	access:public
boost::re_detail::re_brace::index	/usr/include/boost/regex/v4/states.hpp	/^   int index;$/;"	m	struct:boost::re_detail::re_brace	access:public
boost::re_detail::re_case	/usr/include/boost/regex/v4/states.hpp	/^struct re_case : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
boost::re_detail::re_case::icase	/usr/include/boost/regex/v4/states.hpp	/^   bool icase;$/;"	m	struct:boost::re_detail::re_case	access:public
boost::re_detail::re_dot	/usr/include/boost/regex/v4/states.hpp	/^struct re_dot : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
boost::re_detail::re_dot::mask	/usr/include/boost/regex/v4/states.hpp	/^   unsigned char mask;$/;"	m	struct:boost::re_detail::re_dot	access:public
boost::re_detail::re_is_set_member	/usr/include/boost/regex/v4/perl_matcher.hpp	/^iterator BOOST_REGEX_CALL re_is_set_member(iterator next, $/;"	f	namespace:boost::re_detail	signature:(iterator next, iterator last, const re_set_long<char_classT>* set_, const regex_data<charT, traits_type>& e, bool icase)
boost::re_detail::re_is_set_member	/usr/include/boost/regex/v4/states.hpp	/^iterator BOOST_REGEX_CALL re_is_set_member(iterator next, $/;"	p	namespace:boost::re_detail	signature:(iterator next, iterator last, const re_set_long<char_classT>* set_, const regex_data<charT, traits_type>& e, bool icase)
boost::re_detail::re_jump	/usr/include/boost/regex/v4/states.hpp	/^struct re_jump : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
boost::re_detail::re_jump::alt	/usr/include/boost/regex/v4/states.hpp	/^   offset_type     alt;                 \/\/ location to jump to$/;"	m	struct:boost::re_detail::re_jump	access:public
boost::re_detail::re_jump_size	/usr/include/boost/regex/v4/states.hpp	/^   re_jump_size = (sizeof(re_jump) + padding_mask) & ~(padding_mask),$/;"	e	enum:boost::re_detail::re_jump_size_type
boost::re_detail::re_jump_size_type	/usr/include/boost/regex/v4/states.hpp	/^enum re_jump_size_type$/;"	g	namespace:boost::re_detail
boost::re_detail::re_literal	/usr/include/boost/regex/v4/states.hpp	/^struct re_literal : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
boost::re_detail::re_literal::length	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int length;$/;"	m	struct:boost::re_detail::re_literal	access:public
boost::re_detail::re_recurse	/usr/include/boost/regex/v4/states.hpp	/^struct re_recurse : public re_jump$/;"	s	namespace:boost::re_detail	inherits:re_jump
boost::re_detail::re_recurse::state_id	/usr/include/boost/regex/v4/states.hpp	/^   int state_id;             \/\/ identifier of first nested repeat within the recursion.$/;"	m	struct:boost::re_detail::re_recurse	access:public
boost::re_detail::re_repeat	/usr/include/boost/regex/v4/states.hpp	/^struct re_repeat : public re_alt$/;"	s	namespace:boost::re_detail	inherits:re_alt
boost::re_detail::re_repeat::greedy	/usr/include/boost/regex/v4/states.hpp	/^   bool          greedy;    \/\/ True if this is a greedy repeat$/;"	m	struct:boost::re_detail::re_repeat	access:public
boost::re_detail::re_repeat::leading	/usr/include/boost/regex/v4/states.hpp	/^   bool          leading;   \/\/ True if this repeat is at the start of the machine (lets us optimize some searches)$/;"	m	struct:boost::re_detail::re_repeat	access:public
boost::re_detail::re_repeat::max	/usr/include/boost/regex/v4/states.hpp	/^   std::size_t   min, max;  \/\/ min and max allowable repeats$/;"	m	struct:boost::re_detail::re_repeat	access:public
boost::re_detail::re_repeat::min	/usr/include/boost/regex/v4/states.hpp	/^   std::size_t   min, max;  \/\/ min and max allowable repeats$/;"	m	struct:boost::re_detail::re_repeat	access:public
boost::re_detail::re_repeat::state_id	/usr/include/boost/regex/v4/states.hpp	/^   int           state_id;        \/\/ Unique identifier for this repeat$/;"	m	struct:boost::re_detail::re_repeat	access:public
boost::re_detail::re_repeater_size	/usr/include/boost/regex/v4/states.hpp	/^   re_repeater_size = (sizeof(re_repeat) + padding_mask) & ~(padding_mask),$/;"	e	enum:boost::re_detail::re_jump_size_type
boost::re_detail::re_set	/usr/include/boost/regex/v4/states.hpp	/^struct re_set : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
boost::re_detail::re_set::_map	/usr/include/boost/regex/v4/states.hpp	/^   unsigned char _map[1 << CHAR_BIT];$/;"	m	struct:boost::re_detail::re_set	access:public
boost::re_detail::re_set_long	/usr/include/boost/regex/v4/states.hpp	/^struct re_set_long : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
boost::re_detail::re_set_long::cclasses	/usr/include/boost/regex/v4/states.hpp	/^   mask_type               cclasses;$/;"	m	struct:boost::re_detail::re_set_long	access:public
boost::re_detail::re_set_long::cequivalents	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int            csingles, cranges, cequivalents;$/;"	m	struct:boost::re_detail::re_set_long	access:public
boost::re_detail::re_set_long::cnclasses	/usr/include/boost/regex/v4/states.hpp	/^   mask_type               cnclasses;$/;"	m	struct:boost::re_detail::re_set_long	access:public
boost::re_detail::re_set_long::cranges	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int            csingles, cranges, cequivalents;$/;"	m	struct:boost::re_detail::re_set_long	access:public
boost::re_detail::re_set_long::csingles	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int            csingles, cranges, cequivalents;$/;"	m	struct:boost::re_detail::re_set_long	access:public
boost::re_detail::re_set_long::isnot	/usr/include/boost/regex/v4/states.hpp	/^   bool                    isnot;$/;"	m	struct:boost::re_detail::re_set_long	access:public
boost::re_detail::re_set_long::singleton	/usr/include/boost/regex/v4/states.hpp	/^   bool                    singleton;$/;"	m	struct:boost::re_detail::re_set_long	access:public
boost::re_detail::re_skip_past_null	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline const charT* re_skip_past_null(const charT* p)$/;"	f	namespace:boost::re_detail	signature:(const charT* p)
boost::re_detail::re_syntax_base	/usr/include/boost/regex/v4/states.hpp	/^struct re_syntax_base$/;"	s	namespace:boost::re_detail
boost::re_detail::re_syntax_base::next	/usr/include/boost/regex/v4/states.hpp	/^   offset_type           next;         \/\/ next state in the machine$/;"	m	struct:boost::re_detail::re_syntax_base	access:public
boost::re_detail::re_syntax_base::type	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_type   type;         \/\/ what kind of state this is$/;"	m	struct:boost::re_detail::re_syntax_base	access:public
boost::re_detail::saved_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_assertion : public saved_position<BidiIterator>$/;"	s	namespace:boost::re_detail	inherits:saved_position
boost::re_detail::saved_assertion::positive	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   bool positive;$/;"	m	struct:boost::re_detail::saved_assertion	access:public
boost::re_detail::saved_assertion::saved_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_assertion(bool p, const re_syntax_base* ps, BidiIterator pos) $/;"	f	struct:boost::re_detail::saved_assertion	access:public	signature:(bool p, const re_syntax_base* ps, BidiIterator pos)
boost::re_detail::saved_extra_block	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_extra_block : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
boost::re_detail::saved_extra_block::base	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state *base, *end;$/;"	m	struct:boost::re_detail::saved_extra_block	access:public
boost::re_detail::saved_extra_block::end	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state *base, *end;$/;"	m	struct:boost::re_detail::saved_extra_block	access:public
boost::re_detail::saved_extra_block::saved_extra_block	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_extra_block(saved_state* b, saved_state* e) $/;"	f	struct:boost::re_detail::saved_extra_block	access:public	signature:(saved_state* b, saved_state* e)
boost::re_detail::saved_matched_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_matched_paren : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
boost::re_detail::saved_matched_paren::index	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   int index;$/;"	m	struct:boost::re_detail::saved_matched_paren	access:public
boost::re_detail::saved_matched_paren::saved_matched_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_matched_paren(int i, const sub_match<BidiIterator>& s) : saved_state(1), index(i), sub(s){};$/;"	f	struct:boost::re_detail::saved_matched_paren	access:public	signature:(int i, const sub_match<BidiIterator>& s)
boost::re_detail::saved_matched_paren::sub	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   sub_match<BidiIterator> sub;$/;"	m	struct:boost::re_detail::saved_matched_paren	access:public
boost::re_detail::saved_position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_position : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
boost::re_detail::saved_position::position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   BidiIterator position;$/;"	m	struct:boost::re_detail::saved_position	access:public
boost::re_detail::saved_position::pstate	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   const re_syntax_base* pstate;$/;"	m	struct:boost::re_detail::saved_position	access:public
boost::re_detail::saved_position::saved_position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_position(const re_syntax_base* ps, BidiIterator pos, int i) : saved_state(i), pstate(ps), position(pos){};$/;"	f	struct:boost::re_detail::saved_position	access:public	signature:(const re_syntax_base* ps, BidiIterator pos, int i)
boost::re_detail::saved_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_recursion : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
boost::re_detail::saved_recursion::preturn_address	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   const re_syntax_base* preturn_address;$/;"	m	struct:boost::re_detail::saved_recursion	access:public
boost::re_detail::saved_recursion::recursion_id	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   int recursion_id;$/;"	m	struct:boost::re_detail::saved_recursion	access:public
boost::re_detail::saved_recursion::results	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   Results results;$/;"	m	struct:boost::re_detail::saved_recursion	access:public
boost::re_detail::saved_recursion::saved_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_recursion(int idx, const re_syntax_base* p, Results* pr) $/;"	f	struct:boost::re_detail::saved_recursion	access:public	signature:(int idx, const re_syntax_base* p, Results* pr)
boost::re_detail::saved_repeater	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_repeater : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
boost::re_detail::saved_repeater::count	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   repeater_count<BidiIterator> count;$/;"	m	struct:boost::re_detail::saved_repeater	access:public
boost::re_detail::saved_repeater::saved_repeater	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_repeater(int i, repeater_count<BidiIterator>** s, BidiIterator start) $/;"	f	struct:boost::re_detail::saved_repeater	access:public	signature:(int i, repeater_count<BidiIterator>** s, BidiIterator start)
boost::re_detail::saved_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_single_repeat : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
boost::re_detail::saved_single_repeat::count	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   std::size_t count;$/;"	m	struct:boost::re_detail::saved_single_repeat	access:public
boost::re_detail::saved_single_repeat::last_position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   BidiIterator last_position;$/;"	m	struct:boost::re_detail::saved_single_repeat	access:public
boost::re_detail::saved_single_repeat::rep	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   const re_repeat* rep;$/;"	m	struct:boost::re_detail::saved_single_repeat	access:public
boost::re_detail::saved_single_repeat::saved_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_single_repeat(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id) $/;"	f	struct:boost::re_detail::saved_single_repeat	access:public	signature:(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id)
boost::re_detail::saved_state	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_state$/;"	s	namespace:boost::re_detail
boost::re_detail::saved_state::saved_state	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state(unsigned i) : state_id(i) {}$/;"	f	struct:boost::re_detail::saved_state	access:public	signature:(unsigned i)
boost::re_detail::saved_state::__anon8::padding1	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      std::size_t padding1;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
boost::re_detail::saved_state::__anon8::padding2	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      std::ptrdiff_t padding2;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
boost::re_detail::saved_state::__anon8::padding3	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      void* padding3;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
boost::re_detail::saved_state::__anon8::state_id	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      unsigned int state_id;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
boost::re_detail::saved_state_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_alt = 4,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_count = 14$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_extra_block	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_extra_block = 6,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_greedy_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_greedy_single_repeat = 7,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_non_greedy_long_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_non_greedy_long_repeat = 13, $/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_repeater_count = 5,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_rep_char	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_char = 10,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_rep_fast_dot	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_fast_dot = 9,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_rep_long_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_long_set = 12,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_rep_short_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_short_set = 11,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_rep_slow_dot	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_slow_dot = 8,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_state_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^enum saved_state_type$/;"	g	namespace:boost::re_detail
boost::re_detail::saved_type_assertion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_assertion = 3,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_type_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_end = 0,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_type_paren	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_paren = 1,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::saved_type_recurse	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_recurse = 2,$/;"	e	enum:boost::re_detail::saved_state_type
boost::re_detail::save_state_init	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct save_state_init$/;"	s	namespace:boost::re_detail
boost::re_detail::save_state_init::save_state_init	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   save_state_init(saved_state** base, saved_state** end)$/;"	f	struct:boost::re_detail::save_state_init	access:public	signature:(saved_state** base, saved_state** end)
boost::re_detail::save_state_init::stack	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state** stack;$/;"	m	struct:boost::re_detail::save_state_init	access:public
boost::re_detail::save_state_init::~save_state_init	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   ~save_state_init()$/;"	f	struct:boost::re_detail::save_state_init	access:public	signature:()
boost::re_detail::sort_C	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_C,$/;"	e	enum:boost::re_detail::__anon9
boost::re_detail::sort_delim	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_delim,$/;"	e	enum:boost::re_detail::__anon9
boost::re_detail::sort_fixed	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_fixed,$/;"	e	enum:boost::re_detail::__anon9
boost::re_detail::sort_unknown	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_unknown$/;"	e	enum:boost::re_detail::__anon9
boost::re_detail::split_pred	/usr/include/boost/regex/v4/regex_split.hpp	/^class split_pred$/;"	c	namespace:boost::re_detail
boost::re_detail::split_pred::initial_max	/usr/include/boost/regex/v4/regex_split.hpp	/^   std::size_t initial_max;$/;"	m	class:boost::re_detail::split_pred	access:private
boost::re_detail::split_pred::iterator_type	/usr/include/boost/regex/v4/regex_split.hpp	/^   typedef typename string_type::const_iterator iterator_type;$/;"	t	class:boost::re_detail::split_pred	access:private
boost::re_detail::split_pred::operator ()	/usr/include/boost/regex/v4/regex_split.hpp	/^   bool operator()(const match_results<iterator_type>& what);$/;"	p	class:boost::re_detail::split_pred	access:public	signature:(const match_results<iterator_type>& what)
boost::re_detail::split_pred::operator ()	/usr/include/boost/regex/v4/regex_split.hpp	/^bool split_pred<OutputIterator, charT, Traits1, Alloc1>::operator()$/;"	f	class:boost::re_detail::split_pred	signature:(const match_results<iterator_type>& what)
boost::re_detail::split_pred::p_last	/usr/include/boost/regex/v4/regex_split.hpp	/^   iterator_type* p_last;$/;"	m	class:boost::re_detail::split_pred	access:private
boost::re_detail::split_pred::p_max	/usr/include/boost/regex/v4/regex_split.hpp	/^   std::size_t* p_max;$/;"	m	class:boost::re_detail::split_pred	access:private
boost::re_detail::split_pred::p_out	/usr/include/boost/regex/v4/regex_split.hpp	/^   OutputIterator* p_out;$/;"	m	class:boost::re_detail::split_pred	access:private
boost::re_detail::split_pred::split_pred	/usr/include/boost/regex/v4/regex_split.hpp	/^   split_pred(iterator_type* a, OutputIterator* b, std::size_t* c)$/;"	f	class:boost::re_detail::split_pred	access:public	signature:(iterator_type* a, OutputIterator* b, std::size_t* c)
boost::re_detail::split_pred::string_type	/usr/include/boost/regex/v4/regex_split.hpp	/^   typedef std::basic_string<charT, Traits1, Alloc1> string_type;$/;"	t	class:boost::re_detail::split_pred	access:private
boost::re_detail::string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const Seq& s, const C* p)$/;"	f	namespace:boost::re_detail	signature:(const Seq& s, const C* p)
boost::re_detail::string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const std::basic_string<C,T,A>& s, const C* p)$/;"	f	namespace:boost::re_detail	signature:(const std::basic_string<C,T,A>& s, const C* p)
boost::re_detail::string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const std::string& s, const char* p)$/;"	f	namespace:boost::re_detail	signature:(const std::string& s, const char* p)
boost::re_detail::string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const std::wstring& s, const wchar_t* p)$/;"	f	namespace:boost::re_detail	signature:(const std::wstring& s, const wchar_t* p)
boost::re_detail::string_out_iterator	/usr/include/boost/regex/v4/regex_format.hpp	/^class string_out_iterator$/;"	c	namespace:boost::re_detail	inherits:std::iterator
boost::re_detail::string_out_iterator::difference_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
boost::re_detail::string_out_iterator::iterator_category	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef std::output_iterator_tag iterator_category;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
boost::re_detail::string_out_iterator::operator *	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator*() { return *this; }$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:()
boost::re_detail::string_out_iterator::operator ++	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator++() { return *this; }$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:()
boost::re_detail::string_out_iterator::operator ++	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator++(int) { return *this; }$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:(int)
boost::re_detail::string_out_iterator::operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator=(typename S::value_type v) $/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:(typename S::value_type v)
boost::re_detail::string_out_iterator::out	/usr/include/boost/regex/v4/regex_format.hpp	/^   S* out;$/;"	m	class:boost::re_detail::string_out_iterator	access:private
boost::re_detail::string_out_iterator::pointer	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef value_type* pointer;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
boost::re_detail::string_out_iterator::reference	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef value_type& reference;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
boost::re_detail::string_out_iterator::string_out_iterator	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator(S& s) : out(&s) {}$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:(S& s)
boost::re_detail::string_out_iterator::value_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename S::value_type value_type;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
boost::re_detail::syntax_element_alt	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_alt = syntax_element_jump + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_assert_backref	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_assert_backref = syntax_element_backstep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_backref	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_backref = syntax_element_buffer_end + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_backstep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_backstep = syntax_element_long_set_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_buffer_end	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_buffer_end = syntax_element_buffer_start + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_buffer_start	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_buffer_start = syntax_element_word_end + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_char_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_char_rep = syntax_element_dot_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_combining	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_combining = syntax_element_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_dot_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_dot_rep = syntax_element_restart_continue + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_endmark	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_endmark = syntax_element_startmark + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_end_line	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_end_line = syntax_element_start_line + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_jump	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_jump = syntax_element_set + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_literal	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_literal = syntax_element_endmark + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_long_set	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_long_set = syntax_element_backref + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_long_set_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_long_set_rep = syntax_element_short_set_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_match	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_match = syntax_element_wild + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_recurse	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_recurse = syntax_element_toggle_case + 1$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_rep = syntax_element_alt + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_restart_continue	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_restart_continue = syntax_element_soft_buffer_end + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_set	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_set = syntax_element_long_set + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_short_set_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_short_set_rep = syntax_element_char_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_soft_buffer_end	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_soft_buffer_end = syntax_element_combining + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_startmark	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_startmark = 0,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_start_line	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_start_line = syntax_element_literal + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_toggle_case	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_toggle_case = syntax_element_assert_backref + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_type	/usr/include/boost/regex/v4/states.hpp	/^enum syntax_element_type$/;"	g	namespace:boost::re_detail
boost::re_detail::syntax_element_wild	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_wild = syntax_element_end_line + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_within_word	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_within_word = syntax_element_word_boundary + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_word_boundary	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_word_boundary = syntax_element_match + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_word_end	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_word_end = syntax_element_word_start + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::syntax_element_word_start	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_word_start = syntax_element_within_word + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
boost::re_detail::ternary_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char (&ternary_type)[4];$/;"	t	namespace:boost::re_detail
boost::re_detail::test_newline	/usr/include/boost/regex/v4/states.hpp	/^   test_newline = 3$/;"	e	enum:boost::re_detail::__anon16
boost::re_detail::test_not_newline	/usr/include/boost/regex/v4/states.hpp	/^   test_not_newline = 2,$/;"	e	enum:boost::re_detail::__anon16
boost::re_detail::trivial_format_traits	/usr/include/boost/regex/v4/regex_format.hpp	/^struct trivial_format_traits$/;"	s	namespace:boost::re_detail
boost::re_detail::trivial_format_traits::char_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef charT char_type;$/;"	t	struct:boost::re_detail::trivial_format_traits	access:public
boost::re_detail::trivial_format_traits::length	/usr/include/boost/regex/v4/regex_format.hpp	/^   static std::ptrdiff_t length(const charT* p)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(const charT* p)
boost::re_detail::trivial_format_traits::toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   int toi(const charT*& p1, const charT* p2, int radix)const$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(const charT*& p1, const charT* p2, int radix) const
boost::re_detail::trivial_format_traits::tolower	/usr/include/boost/regex/v4/regex_format.hpp	/^   static charT tolower(charT c)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(charT c)
boost::re_detail::trivial_format_traits::toupper	/usr/include/boost/regex/v4/regex_format.hpp	/^   static charT toupper(charT c)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(charT c)
boost::re_detail::trivial_format_traits::value	/usr/include/boost/regex/v4/regex_format.hpp	/^   static int value(const charT c, int radix)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(const charT c, int radix)
boost::re_detail::unary_binary_ternary	/usr/include/boost/regex/v4/regex_format.hpp	/^struct unary_binary_ternary$/;"	s	namespace:boost::re_detail
boost::re_detail::unary_binary_ternary::binary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    typedef binary_type (*binary_fun)(any_type, any_type);$/;"	t	struct:boost::re_detail::unary_binary_ternary	access:public
boost::re_detail::unary_binary_ternary::operator binary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator binary_fun();$/;"	p	struct:boost::re_detail::unary_binary_ternary	access:public	signature:()
boost::re_detail::unary_binary_ternary::operator ternary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator ternary_fun();$/;"	p	struct:boost::re_detail::unary_binary_ternary	access:public	signature:()
boost::re_detail::unary_binary_ternary::operator unary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator unary_fun();$/;"	p	struct:boost::re_detail::unary_binary_ternary	access:public	signature:()
boost::re_detail::unary_binary_ternary::ternary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    typedef ternary_type (*ternary_fun)(any_type, any_type, any_type);$/;"	t	struct:boost::re_detail::unary_binary_ternary	access:public
boost::re_detail::unary_binary_ternary::unary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    typedef unary_type (*unary_fun)(any_type);$/;"	t	struct:boost::re_detail::unary_binary_ternary	access:public
boost::re_detail::unary_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char (&unary_type)[2];$/;"	t	namespace:boost::re_detail
boost::re_detail::unicode_string_out_iterator	/usr/include/boost/regex/icu.hpp	/^class unicode_string_out_iterator$/;"	c	namespace:boost::re_detail
boost::re_detail::unicode_string_out_iterator::difference_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
boost::re_detail::unicode_string_out_iterator::iterator_category	/usr/include/boost/regex/icu.hpp	/^   typedef std::output_iterator_tag iterator_category;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
boost::re_detail::unicode_string_out_iterator::operator *	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator*() { return *this; }$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:()
boost::re_detail::unicode_string_out_iterator::operator ++	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator++() { return *this; }$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:()
boost::re_detail::unicode_string_out_iterator::operator ++	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator++(int) { return *this; }$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:(int)
boost::re_detail::unicode_string_out_iterator::operator =	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator=(UChar v) $/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:(UChar v)
boost::re_detail::unicode_string_out_iterator::out	/usr/include/boost/regex/icu.hpp	/^   U_NAMESPACE_QUALIFIER UnicodeString* out;$/;"	m	class:boost::re_detail::unicode_string_out_iterator	access:private
boost::re_detail::unicode_string_out_iterator::pointer	/usr/include/boost/regex/icu.hpp	/^   typedef value_type* pointer;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
boost::re_detail::unicode_string_out_iterator::reference	/usr/include/boost/regex/icu.hpp	/^   typedef value_type& reference;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
boost::re_detail::unicode_string_out_iterator::unicode_string_out_iterator	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator(U_NAMESPACE_QUALIFIER UnicodeString& s) : out(&s) {}$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:(U_NAMESPACE_QUALIFIER UnicodeString& s)
boost::re_detail::unicode_string_out_iterator::value_type	/usr/include/boost/regex/icu.hpp	/^   typedef UChar value_type;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
boost::re_detail::valid_value	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool valid_value(charT c, int v)$/;"	f	namespace:boost::re_detail	signature:(charT c, int v)
boost::re_detail::valid_value	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool valid_value(charT, int v, const mpl::true_&)$/;"	f	namespace:boost::re_detail	signature:(charT, int v, const mpl::true_&)
boost::re_detail::valid_value	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool valid_value(charT, int, const mpl::false_&)$/;"	f	namespace:boost::re_detail	signature:(charT, int, const mpl::false_&)
boost::re_detail::verify_options	/usr/include/boost/regex/v4/perl_matcher.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL verify_options(boost::regex_constants::syntax_option_type ef, match_flag_type mf);$/;"	p	namespace:boost::re_detail	signature:(boost::regex_constants::syntax_option_type ef, match_flag_type mf)
boost::re_detail::w32_cat_get	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::basic_string<unsigned short> BOOST_REGEX_CALL w32_cat_get(const cat_type& cat, lcid_type, int i, const std::basic_string<unsigned short>& def);$/;"	p	namespace:boost::re_detail	signature:(const cat_type& cat, lcid_type, int i, const std::basic_string<unsigned short>& def)
boost::re_detail::w32_cat_get	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::string BOOST_REGEX_CALL w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::string& def);$/;"	p	namespace:boost::re_detail	signature:(const cat_type& cat, lcid_type state_id, int i, const std::string& def)
boost::re_detail::w32_cat_get	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::wstring BOOST_REGEX_CALL w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::wstring& def);$/;"	p	namespace:boost::re_detail	signature:(const cat_type& cat, lcid_type state_id, int i, const std::wstring& def)
boost::re_detail::w32_cat_open	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL cat_type BOOST_REGEX_CALL w32_cat_open(const std::string& name);$/;"	p	namespace:boost::re_detail	signature:(const std::string& name)
boost::re_detail::w32_get_default_locale	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL lcid_type BOOST_REGEX_CALL w32_get_default_locale();$/;"	p	namespace:boost::re_detail	signature:()
boost::re_detail::w32_is	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is(lcid_type state_id, boost::uint32_t m, unsigned short c);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, boost::uint32_t m, unsigned short c)
boost::re_detail::w32_is	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is(lcid_type, boost::uint32_t mask, char c);$/;"	p	namespace:boost::re_detail	signature:(lcid_type, boost::uint32_t mask, char c)
boost::re_detail::w32_is	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is(lcid_type, boost::uint32_t mask, wchar_t c);$/;"	p	namespace:boost::re_detail	signature:(lcid_type, boost::uint32_t mask, wchar_t c)
boost::re_detail::w32_is_lower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_lower(char, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char, lcid_type)
boost::re_detail::w32_is_lower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_lower(unsigned short ca, lcid_type state_id);$/;"	p	namespace:boost::re_detail	signature:(unsigned short ca, lcid_type state_id)
boost::re_detail::w32_is_lower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_lower(wchar_t, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t, lcid_type)
boost::re_detail::w32_is_upper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_upper(char, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char, lcid_type)
boost::re_detail::w32_is_upper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_upper(unsigned short ca, lcid_type state_id);$/;"	p	namespace:boost::re_detail	signature:(unsigned short ca, lcid_type state_id)
boost::re_detail::w32_is_upper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_upper(wchar_t, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t, lcid_type)
boost::re_detail::w32_regex_traits_base	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^struct w32_regex_traits_base$/;"	s	namespace:boost::re_detail
boost::re_detail::w32_regex_traits_base::imbue	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   lcid_type imbue(lcid_type l);$/;"	p	struct:boost::re_detail::w32_regex_traits_base	access:public	signature:(lcid_type l)
boost::re_detail::w32_regex_traits_base::imbue	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^inline lcid_type w32_regex_traits_base<charT>::imbue(lcid_type l)$/;"	f	class:boost::re_detail::w32_regex_traits_base	signature:(lcid_type l)
boost::re_detail::w32_regex_traits_base::m_locale	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   lcid_type m_locale;$/;"	m	struct:boost::re_detail::w32_regex_traits_base	access:public
boost::re_detail::w32_regex_traits_base::w32_regex_traits_base	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_base(lcid_type l)$/;"	f	struct:boost::re_detail::w32_regex_traits_base	access:public	signature:(lcid_type l)
boost::re_detail::w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class BOOST_REGEX_DECL w32_regex_traits_char_layer<char> : public w32_regex_traits_base<char>$/;"	c	namespace:boost::re_detail	inherits:w32_regex_traits_base
boost::re_detail::w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class w32_regex_traits_char_layer : public w32_regex_traits_base<charT>$/;"	c	namespace:boost::re_detail	inherits:w32_regex_traits_base
boost::re_detail::w32_regex_traits_char_layer::escape_syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(char c) const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(char c) const
boost::re_detail::w32_regex_traits_char_layer::escape_syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(charT c) const
boost::re_detail::w32_regex_traits_char_layer::get_default_message	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type get_default_message(regex_constants::syntax_type);$/;"	p	class:boost::re_detail::w32_regex_traits_char_layer	access:private	signature:(regex_constants::syntax_type)
boost::re_detail::w32_regex_traits_char_layer::get_default_message	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	signature:(regex_constants::syntax_type i)
boost::re_detail::w32_regex_traits_char_layer::init	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::w32_regex_traits_char_layer	access:private	signature:()
boost::re_detail::w32_regex_traits_char_layer::isctype	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   bool isctype(boost::uint32_t mask, char c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(boost::uint32_t mask, char c) const
boost::re_detail::w32_regex_traits_char_layer::isctype	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   bool isctype(boost::uint32_t mask, charT c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(boost::uint32_t mask, charT c) const
boost::re_detail::w32_regex_traits_char_layer::map_iterator_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef typename map_type::const_iterator map_iterator_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::map_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::map<charT, regex_constants::syntax_type> map_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::m_char_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   map_type m_char_map;$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::m_char_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type m_char_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::m_lower_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char m_lower_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::m_type_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   boost::uint16_t m_type_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::string string_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
boost::re_detail::w32_regex_traits_char_layer::syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(char c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(char c) const
boost::re_detail::w32_regex_traits_char_layer::syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(charT c) const
boost::re_detail::w32_regex_traits_char_layer::tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char tolower(char c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(char c) const
boost::re_detail::w32_regex_traits_char_layer::tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT tolower(charT c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(charT c) const
boost::re_detail::w32_regex_traits_char_layer::w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_char_layer(::boost::re_detail::lcid_type l)$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(::boost::re_detail::lcid_type l)
boost::re_detail::w32_regex_traits_char_layer::w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_char_layer(const lcid_type l);$/;"	p	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(const lcid_type l)
boost::re_detail::w32_regex_traits_char_layer::w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^w32_regex_traits_char_layer<charT>::w32_regex_traits_char_layer(::boost::re_detail::lcid_type l) $/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	signature:(::boost::re_detail::lcid_type l)
boost::re_detail::w32_regex_traits_implementation	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class w32_regex_traits_implementation : public w32_regex_traits_char_layer<charT>$/;"	c	namespace:boost::re_detail	inherits:w32_regex_traits_char_layer
boost::re_detail::w32_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_base = 0x3ff);  \/\/ all the masks used by the CT_CTYPE1 group$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_base = 0x3ff)
boost::re_detail::w32_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_horizontal = 0x1000); \/\/ must be C1_DEFINED << 3$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_horizontal = 0x1000)
boost::re_detail::w32_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_unicode = 0x0800); \/\/ must be C1_DEFINED << 2$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_unicode = 0x0800)
boost::re_detail::w32_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_vertical = 0x2000); \/\/ must be C1_DEFINED << 4$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_vertical = 0x2000)
boost::re_detail::w32_regex_traits_implementation::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_word = 0x0400); \/\/ must be C1_DEFINED << 1$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_word = 0x0400)
boost::re_detail::w32_regex_traits_implementation::char_class_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef typename w32_regex_traits<charT>::char_class_type char_class_type;$/;"	t	class:boost::re_detail::w32_regex_traits_implementation	access:public
boost::re_detail::w32_regex_traits_implementation::char_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef charT char_type;$/;"	t	class:boost::re_detail::w32_regex_traits_implementation	access:public
boost::re_detail::w32_regex_traits_implementation::error_string	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(regex_constants::error_type n) const
boost::re_detail::w32_regex_traits_implementation::lookup_classname	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::lookup_classname_imp	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:private	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::lookup_classname_imp	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::lookup_collatename	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::lookup_collatename	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::m_collate_delim	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT                          m_collate_delim;   \/\/ the collation group delimiter$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
boost::re_detail::w32_regex_traits_implementation::m_collate_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   unsigned                       m_collate_type;    \/\/ the form of the collation string$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
boost::re_detail::w32_regex_traits_implementation::m_custom_class_names	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::map<string_type, char_class_type>  m_custom_class_names; \/\/ character class names$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
boost::re_detail::w32_regex_traits_implementation::m_custom_collate_names	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::map<string_type, string_type>      m_custom_collate_names; \/\/ collating element names$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
boost::re_detail::w32_regex_traits_implementation::m_error_strings	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::map<int, std::string>     m_error_strings;   \/\/ error messages indexed by numberic ID$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
boost::re_detail::w32_regex_traits_implementation::string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::w32_regex_traits_implementation	access:public
boost::re_detail::w32_regex_traits_implementation::transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::transform_primary	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::transform_primary	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
boost::re_detail::w32_regex_traits_implementation::w32_regex_traits_implementation	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation(::boost::re_detail::lcid_type l);$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(::boost::re_detail::lcid_type l)
boost::re_detail::w32_regex_traits_implementation::w32_regex_traits_implementation	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^w32_regex_traits_implementation<charT>::w32_regex_traits_implementation(::boost::re_detail::lcid_type l)$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(::boost::re_detail::lcid_type l)
boost::re_detail::w32_tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL w32_tolower(char c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char c, lcid_type)
boost::re_detail::w32_tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL unsigned short BOOST_REGEX_CALL w32_tolower(unsigned short c, lcid_type state_id);$/;"	p	namespace:boost::re_detail	signature:(unsigned short c, lcid_type state_id)
boost::re_detail::w32_tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL w32_tolower(wchar_t c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c, lcid_type)
boost::re_detail::w32_toupper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL w32_toupper(char c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char c, lcid_type)
boost::re_detail::w32_toupper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL w32_toupper(wchar_t c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c, lcid_type)
boost::re_detail::w32_transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::basic_string<unsigned short> BOOST_REGEX_CALL w32_transform(lcid_type state_id, const unsigned short* p1, const unsigned short* p2);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, const unsigned short* p1, const unsigned short* p2)
boost::re_detail::w32_transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::string BOOST_REGEX_CALL w32_transform(lcid_type state_id, const char* p1, const char* p2);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, const char* p1, const char* p2)
boost::re_detail::w32_transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::wstring BOOST_REGEX_CALL w32_transform(lcid_type state_id, const wchar_t* p1, const wchar_t* p2);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, const wchar_t* p1, const wchar_t* p2)
boost::re_detail::_fi_find_data	/usr/include/boost/regex/v4/fileiter.hpp	/^typedef WIN32_FIND_DATAA _fi_find_data;$/;"	t	namespace:boost::re_detail
boost::re_detail::_fi_find_handle	/usr/include/boost/regex/v4/fileiter.hpp	/^typedef HANDLE _fi_find_handle;$/;"	t	namespace:boost::re_detail
boost::re_detail::_narrow_type	/usr/include/boost/regex/v4/states.hpp	/^struct _narrow_type{};$/;"	s	namespace:boost::re_detail
boost::re_detail::_wide_type	/usr/include/boost/regex/v4/states.hpp	/^struct _wide_type{};$/;"	s	namespace:boost::re_detail
boost::scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^class BOOST_REGEX_DECL scoped_static_mutex_lock$/;"	c	namespace:boost
boost::scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^class BOOST_REGEX_DECL scoped_static_mutex_lock;$/;"	m	namespace:boost	typeref:class:boost::BOOST_REGEX_DECL
boost::scoped_static_mutex_lock::lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   void lock();$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:()
boost::scoped_static_mutex_lock::locked	/usr/include/boost/regex/pending/static_mutex.hpp	/^   inline bool locked()const$/;"	f	class:boost::scoped_static_mutex_lock	access:public	signature:() const
boost::scoped_static_mutex_lock::m_have_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   bool m_have_lock;$/;"	m	class:boost::scoped_static_mutex_lock	access:private
boost::scoped_static_mutex_lock::m_mutex	/usr/include/boost/regex/pending/static_mutex.hpp	/^   static_mutex& m_mutex;$/;"	m	class:boost::scoped_static_mutex_lock	access:private
boost::scoped_static_mutex_lock::operator void const*	/usr/include/boost/regex/pending/static_mutex.hpp	/^   inline operator void const*()const$/;"	f	class:boost::scoped_static_mutex_lock	access:public	signature:() const
boost::scoped_static_mutex_lock::scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   scoped_static_mutex_lock(static_mutex& mut, bool lk = true);$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:(static_mutex& mut, bool lk = true)
boost::scoped_static_mutex_lock::unlock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   void unlock();$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:()
boost::scoped_static_mutex_lock::~scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   ~scoped_static_mutex_lock();$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:()
boost::smatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<std::string::const_iterator> smatch;$/;"	t	namespace:boost
boost::spirit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^namespace boost { namespace spirit {$/;"	n	namespace:boost
boost::spirit::regex_p	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^regex_p(CharT const *first)$/;"	f	namespace:boost::spirit	signature:(CharT const *first)
boost::spirit::regex_p	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^regex_p(CharT const *first, CharT const *last)$/;"	f	namespace:boost::spirit	signature:(CharT const *first, CharT const *last)
boost::spirit::rxstrlit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^struct rxstrlit : public parser<rxstrlit<CharT> > {$/;"	s	namespace:boost::spirit	inherits:parser
boost::spirit::rxstrlit::parse	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    parse(ScannerT const& scan) const$/;"	f	struct:boost::spirit::rxstrlit	access:public	signature:(ScannerT const& scan) const
boost::spirit::rxstrlit::rx	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    impl::rx_parser<CharT> rx;   \/\/ contains the boost regular expression parser$/;"	m	struct:boost::spirit::rxstrlit	access:private
boost::spirit::rxstrlit::rxstrlit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    rxstrlit(CharT const *first)$/;"	f	struct:boost::spirit::rxstrlit	access:public	signature:(CharT const *first)
boost::spirit::rxstrlit::rxstrlit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    rxstrlit(CharT const *first, CharT const *last)$/;"	f	struct:boost::spirit::rxstrlit	access:public	signature:(CharT const *first, CharT const *last)
boost::spirit::rxstrlit::self_t	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    typedef rxstrlit self_t;$/;"	t	struct:boost::spirit::rxstrlit	access:public
boost::sregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<std::string::const_iterator> sregex_iterator;$/;"	t	namespace:boost
boost::sregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<std::string::const_iterator> sregex_token_iterator;$/;"	t	namespace:boost
boost::ssub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<std::string::const_iterator> ssub_match;$/;"	t	namespace:boost
boost::static_mutex	/usr/include/boost/regex/pending/static_mutex.hpp	/^class static_mutex$/;"	c	namespace:boost
boost::static_mutex::m_mutex	/usr/include/boost/regex/pending/static_mutex.hpp	/^   pthread_mutex_t m_mutex;$/;"	m	class:boost::static_mutex	access:public
boost::static_mutex::scoped_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   typedef scoped_static_mutex_lock scoped_lock;$/;"	t	class:boost::static_mutex	access:public
boost::sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^struct sub_match : public std::pair<BidiIterator, BidiIterator>$/;"	s	namespace:boost	inherits:std::pair
boost::sub_match::captures	/usr/include/boost/regex/v4/sub_match.hpp	/^   const capture_sequence_type& captures()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::capture_sequence_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef std::vector<sub_match<BidiIterator> > capture_sequence_type;$/;"	t	struct:boost::sub_match	access:public
boost::sub_match::compare	/usr/include/boost/regex/v4/sub_match.hpp	/^   int compare(const std::basic_string<value_type>& s)const$/;"	f	struct:boost::sub_match	access:public	signature:(const std::basic_string<value_type>& s) const
boost::sub_match::compare	/usr/include/boost/regex/v4/sub_match.hpp	/^   int compare(const sub_match& s)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& s) const
boost::sub_match::compare	/usr/include/boost/regex/v4/sub_match.hpp	/^   int compare(const value_type* p)const$/;"	f	struct:boost::sub_match	access:public	signature:(const value_type* p) const
boost::sub_match::const_iterator	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          BidiIterator                                                     const_iterator;$/;"	t	struct:boost::sub_match	access:public
boost::sub_match::difference_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          std::ptrdiff_t                                                   difference_type;$/;"	t	struct:boost::sub_match	access:public
boost::sub_match::difference_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef typename re_detail::regex_iterator_traits<BidiIterator>::difference_type  difference_type;$/;"	t	struct:boost::sub_match	access:public
boost::sub_match::get_captures	/usr/include/boost/regex/v4/sub_match.hpp	/^   capture_sequence_type& get_captures()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::iterator	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          BidiIterator                                                     iterator;$/;"	t	struct:boost::sub_match	access:public
boost::sub_match::iterator_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          BidiIterator                                                     iterator_type;$/;"	t	struct:boost::sub_match	access:public
boost::sub_match::length	/usr/include/boost/regex/v4/sub_match.hpp	/^   difference_type BOOST_REGEX_CALL length()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::matched	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool matched;$/;"	m	struct:boost::sub_match	access:public
boost::sub_match::m_captures	/usr/include/boost/regex/v4/sub_match.hpp	/^   mutable boost::scoped_ptr<capture_sequence_type> m_captures;$/;"	m	struct:boost::sub_match	access:private
boost::sub_match::operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool BOOST_REGEX_CALL operator !=(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
boost::sub_match::operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator<(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
boost::sub_match::operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator<=(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
boost::sub_match::operator =	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match& operator=(const sub_match& that)$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that)
boost::sub_match::operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator==(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
boost::sub_match::operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator>(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
boost::sub_match::operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator>=(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
boost::sub_match::operator int	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator int()const;$/;"	p	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::operator int	/usr/include/boost/regex/v4/sub_match.hpp	/^sub_match<BidiIterator>::operator int()const$/;"	f	class:boost::sub_match	signature:() const
boost::sub_match::operator short	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator short()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::operator std::basic_string<value_type, T, A>	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator std::basic_string<value_type, T, A> ()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::operator std::basic_string<value_type>	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator std::basic_string<value_type> ()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::operator unsigned int	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator unsigned int()const;$/;"	p	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::operator unsigned int	/usr/include/boost/regex/v4/sub_match.hpp	/^sub_match<BidiIterator>::operator unsigned int()const$/;"	f	class:boost::sub_match	signature:() const
boost::sub_match::operator unsigned short	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator unsigned short()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::str	/usr/include/boost/regex/v4/sub_match.hpp	/^   std::basic_string<value_type> str()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
boost::sub_match::sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match() : std::pair<BidiIterator, BidiIterator>(), matched(false) {}$/;"	f	struct:boost::sub_match	access:public	signature:()
boost::sub_match::sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match(BidiIterator i) : std::pair<BidiIterator, BidiIterator>(i, i), matched(false) {}$/;"	f	struct:boost::sub_match	access:public	signature:(BidiIterator i)
boost::sub_match::sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match(const sub_match& that, bool $/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that, bool deep_copy = true )
boost::sub_match::value_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef typename re_detail::regex_iterator_traits<BidiIterator>::value_type       value_type;$/;"	t	struct:boost::sub_match	access:public
boost::swap	/usr/include/boost/regex/v4/basic_regex.hpp	/^void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)$/;"	f	namespace:boost	signature:(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)
boost::swap	/usr/include/boost/regex/v4/match_results.hpp	/^void swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)$/;"	f	namespace:boost	signature:(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)
boost::system	/usr/include/boost/system/cygwin_error.hpp	/^  namespace system$/;"	n	namespace:boost
boost::system	/usr/include/boost/system/error_code.hpp	/^  namespace system$/;"	n	namespace:boost
boost::system	/usr/include/boost/system/linux_error.hpp	/^  namespace system$/;"	n	namespace:boost
boost::system	/usr/include/boost/system/system_error.hpp	/^  namespace system$/;"	n	namespace:boost
boost::system	/usr/include/boost/system/windows_error.hpp	/^  namespace system$/;"	n	namespace:boost
boost::system::cygwin_error	/usr/include/boost/system/cygwin_error.hpp	/^    namespace cygwin_error$/;"	n	namespace:boost::system
boost::system::cygwin_error	/usr/include/boost/system/cygwin_error.hpp	/^   namespace cygwin_error$/;"	n	namespace:boost::system
boost::system::cygwin_error::cygwin_errno	/usr/include/boost/system/cygwin_error.hpp	/^      enum cygwin_errno$/;"	g	namespace:boost::system::cygwin_error
boost::system::cygwin_error::make_error_code	/usr/include/boost/system/cygwin_error.hpp	/^      inline error_code make_error_code( cygwin_errno e )$/;"	f	namespace:boost::system::cygwin_error	signature:( cygwin_errno e )
boost::system::cygwin_error::no_net	/usr/include/boost/system/cygwin_error.hpp	/^        no_net = ENONET,$/;"	e	enum:boost::system::cygwin_error::cygwin_errno
boost::system::cygwin_error::no_package	/usr/include/boost/system/cygwin_error.hpp	/^        no_package = ENOPKG,$/;"	e	enum:boost::system::cygwin_error::cygwin_errno
boost::system::cygwin_error::no_share	/usr/include/boost/system/cygwin_error.hpp	/^        no_share = ENOSHARE$/;"	e	enum:boost::system::cygwin_error::cygwin_errno
boost::system::errc	/usr/include/boost/system/error_code.hpp	/^    namespace errc$/;"	n	namespace:boost::system
boost::system::errc::address_family_not_supported	/usr/include/boost/system/error_code.hpp	/^        address_family_not_supported = EAFNOSUPPORT,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::address_in_use	/usr/include/boost/system/error_code.hpp	/^        address_in_use = EADDRINUSE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::address_not_available	/usr/include/boost/system/error_code.hpp	/^        address_not_available = EADDRNOTAVAIL,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::already_connected	/usr/include/boost/system/error_code.hpp	/^        already_connected = EISCONN,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::argument_list_too_long	/usr/include/boost/system/error_code.hpp	/^        argument_list_too_long = E2BIG,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::argument_out_of_domain	/usr/include/boost/system/error_code.hpp	/^        argument_out_of_domain = EDOM,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::bad_address	/usr/include/boost/system/error_code.hpp	/^        bad_address = EFAULT,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::bad_file_descriptor	/usr/include/boost/system/error_code.hpp	/^        bad_file_descriptor = EBADF,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::bad_message	/usr/include/boost/system/error_code.hpp	/^        bad_message = EBADMSG,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::broken_pipe	/usr/include/boost/system/error_code.hpp	/^        broken_pipe = EPIPE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::connection_aborted	/usr/include/boost/system/error_code.hpp	/^        connection_aborted = ECONNABORTED,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::connection_already_in_progress	/usr/include/boost/system/error_code.hpp	/^        connection_already_in_progress = EALREADY,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::connection_refused	/usr/include/boost/system/error_code.hpp	/^        connection_refused = ECONNREFUSED,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::connection_reset	/usr/include/boost/system/error_code.hpp	/^        connection_reset = ECONNRESET,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::cross_device_link	/usr/include/boost/system/error_code.hpp	/^        cross_device_link = EXDEV,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::destination_address_required	/usr/include/boost/system/error_code.hpp	/^        destination_address_required = EDESTADDRREQ,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::device_or_resource_busy	/usr/include/boost/system/error_code.hpp	/^        device_or_resource_busy = EBUSY,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::directory_not_empty	/usr/include/boost/system/error_code.hpp	/^        directory_not_empty = ENOTEMPTY,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::errc_t	/usr/include/boost/system/error_code.hpp	/^      enum errc_t$/;"	g	namespace:boost::system::errc
boost::system::errc::executable_format_error	/usr/include/boost/system/error_code.hpp	/^        executable_format_error = ENOEXEC,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::filename_too_long	/usr/include/boost/system/error_code.hpp	/^        filename_too_long = ENAMETOOLONG,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::file_exists	/usr/include/boost/system/error_code.hpp	/^        file_exists = EEXIST,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::file_too_large	/usr/include/boost/system/error_code.hpp	/^        file_too_large = EFBIG,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::function_not_supported	/usr/include/boost/system/error_code.hpp	/^        function_not_supported = ENOSYS,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::host_unreachable	/usr/include/boost/system/error_code.hpp	/^        host_unreachable = EHOSTUNREACH,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::identifier_removed	/usr/include/boost/system/error_code.hpp	/^        identifier_removed = EIDRM,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::illegal_byte_sequence	/usr/include/boost/system/error_code.hpp	/^        illegal_byte_sequence = EILSEQ,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::inappropriate_io_control_operation	/usr/include/boost/system/error_code.hpp	/^        inappropriate_io_control_operation = ENOTTY,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::interrupted	/usr/include/boost/system/error_code.hpp	/^        interrupted = EINTR,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::invalid_argument	/usr/include/boost/system/error_code.hpp	/^        invalid_argument = EINVAL,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::invalid_seek	/usr/include/boost/system/error_code.hpp	/^        invalid_seek = ESPIPE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::io_error	/usr/include/boost/system/error_code.hpp	/^        io_error = EIO,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::is_a_directory	/usr/include/boost/system/error_code.hpp	/^        is_a_directory = EISDIR,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::make_error_code	/usr/include/boost/system/error_code.hpp	/^      inline error_code make_error_code( errc_t e )$/;"	f	namespace:boost::system::errc	signature:( errc_t e )
boost::system::errc::make_error_condition	/usr/include/boost/system/error_code.hpp	/^      inline error_condition make_error_condition( errc_t e )$/;"	f	namespace:boost::system::errc	signature:( errc_t e )
boost::system::errc::message_size	/usr/include/boost/system/error_code.hpp	/^        message_size = EMSGSIZE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::network_down	/usr/include/boost/system/error_code.hpp	/^        network_down = ENETDOWN,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::network_reset	/usr/include/boost/system/error_code.hpp	/^        network_reset = ENETRESET,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::network_unreachable	/usr/include/boost/system/error_code.hpp	/^        network_unreachable = ENETUNREACH,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::not_a_directory	/usr/include/boost/system/error_code.hpp	/^        not_a_directory = ENOTDIR,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::not_a_socket	/usr/include/boost/system/error_code.hpp	/^        not_a_socket = ENOTSOCK,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::not_a_stream	/usr/include/boost/system/error_code.hpp	/^        not_a_stream = ENOSTR,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::not_connected	/usr/include/boost/system/error_code.hpp	/^        not_connected = ENOTCONN,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::not_enough_memory	/usr/include/boost/system/error_code.hpp	/^        not_enough_memory = ENOMEM,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::not_supported	/usr/include/boost/system/error_code.hpp	/^        not_supported = ENOTSUP,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_buffer_space	/usr/include/boost/system/error_code.hpp	/^        no_buffer_space = ENOBUFS,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_child_process	/usr/include/boost/system/error_code.hpp	/^        no_child_process = ECHILD,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_link	/usr/include/boost/system/error_code.hpp	/^        no_link = ENOLINK,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_lock_available	/usr/include/boost/system/error_code.hpp	/^        no_lock_available = ENOLCK,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_message	/usr/include/boost/system/error_code.hpp	/^        no_message = ENOMSG,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_message_available	/usr/include/boost/system/error_code.hpp	/^        no_message_available = ENODATA,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_protocol_option	/usr/include/boost/system/error_code.hpp	/^        no_protocol_option = ENOPROTOOPT,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_space_on_device	/usr/include/boost/system/error_code.hpp	/^        no_space_on_device = ENOSPC,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_stream_resources	/usr/include/boost/system/error_code.hpp	/^        no_stream_resources = ENOSR,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_such_device	/usr/include/boost/system/error_code.hpp	/^        no_such_device = ENODEV,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_such_device_or_address	/usr/include/boost/system/error_code.hpp	/^        no_such_device_or_address = ENXIO,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_such_file_or_directory	/usr/include/boost/system/error_code.hpp	/^        no_such_file_or_directory = ENOENT,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::no_such_process	/usr/include/boost/system/error_code.hpp	/^        no_such_process = ESRCH,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::operation_canceled	/usr/include/boost/system/error_code.hpp	/^        operation_canceled = ECANCELED,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::operation_in_progress	/usr/include/boost/system/error_code.hpp	/^        operation_in_progress = EINPROGRESS,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::operation_not_permitted	/usr/include/boost/system/error_code.hpp	/^        operation_not_permitted = EPERM,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::operation_not_supported	/usr/include/boost/system/error_code.hpp	/^        operation_not_supported = EOPNOTSUPP,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::operation_would_block	/usr/include/boost/system/error_code.hpp	/^        operation_would_block = EWOULDBLOCK,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::owner_dead	/usr/include/boost/system/error_code.hpp	/^        owner_dead = EOWNERDEAD,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::permission_denied	/usr/include/boost/system/error_code.hpp	/^        permission_denied = EACCES,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::protocol_error	/usr/include/boost/system/error_code.hpp	/^        protocol_error = EPROTO,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::protocol_not_supported	/usr/include/boost/system/error_code.hpp	/^        protocol_not_supported = EPROTONOSUPPORT,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::read_only_file_system	/usr/include/boost/system/error_code.hpp	/^        read_only_file_system = EROFS,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::resource_deadlock_would_occur	/usr/include/boost/system/error_code.hpp	/^        resource_deadlock_would_occur = EDEADLK,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::resource_unavailable_try_again	/usr/include/boost/system/error_code.hpp	/^        resource_unavailable_try_again = EAGAIN,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::result_out_of_range	/usr/include/boost/system/error_code.hpp	/^        result_out_of_range = ERANGE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::state_not_recoverable	/usr/include/boost/system/error_code.hpp	/^        state_not_recoverable = ENOTRECOVERABLE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::stream_timeout	/usr/include/boost/system/error_code.hpp	/^        stream_timeout = ETIME,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::success	/usr/include/boost/system/error_code.hpp	/^        success = 0,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::text_file_busy	/usr/include/boost/system/error_code.hpp	/^        text_file_busy = ETXTBSY,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::timed_out	/usr/include/boost/system/error_code.hpp	/^        timed_out = ETIMEDOUT,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::too_many_files_open	/usr/include/boost/system/error_code.hpp	/^        too_many_files_open = EMFILE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::too_many_files_open_in_system	/usr/include/boost/system/error_code.hpp	/^        too_many_files_open_in_system = ENFILE,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::too_many_links	/usr/include/boost/system/error_code.hpp	/^        too_many_links = EMLINK,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::too_many_symbolic_link_levels	/usr/include/boost/system/error_code.hpp	/^        too_many_symbolic_link_levels = ELOOP,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::value_too_large	/usr/include/boost/system/error_code.hpp	/^        value_too_large = EOVERFLOW,$/;"	e	enum:boost::system::errc::errc_t
boost::system::errc::wrong_protocol_type	/usr/include/boost/system/error_code.hpp	/^        wrong_protocol_type = EPROTOTYPE$/;"	e	enum:boost::system::errc::errc_t
boost::system::errno_ecat	/usr/include/boost/system/error_code.hpp	/^    static const error_category &  errno_ecat     = generic_category();$/;"	m	namespace:boost::system
boost::system::error_category	/usr/include/boost/system/error_code.hpp	/^    class error_category : public noncopyable$/;"	c	namespace:boost::system	inherits:noncopyable
boost::system::error_category::default_error_condition	/usr/include/boost/system/error_code.hpp	/^      virtual error_condition  default_error_condition( int ev ) const;$/;"	p	class:boost::system::error_category	access:public	signature:( int ev ) const
boost::system::error_category::default_error_condition	/usr/include/boost/system/error_code.hpp	/^    inline error_condition error_category::default_error_condition( int ev ) const$/;"	f	class:boost::system::error_category	signature:( int ev ) const
boost::system::error_category::equivalent	/usr/include/boost/system/error_code.hpp	/^      virtual bool             equivalent( const error_code & code,$/;"	p	class:boost::system::error_category	access:public	signature:( const error_code & code, int condition ) const
boost::system::error_category::equivalent	/usr/include/boost/system/error_code.hpp	/^      virtual bool             equivalent( int code, $/;"	p	class:boost::system::error_category	access:public	signature:( int code, const error_condition & condition ) const
boost::system::error_category::equivalent	/usr/include/boost/system/error_code.hpp	/^    inline bool error_category::equivalent( const error_code & code,$/;"	f	class:boost::system::error_category	signature:( const error_code & code, int condition ) const
boost::system::error_category::equivalent	/usr/include/boost/system/error_code.hpp	/^    inline bool error_category::equivalent( int code,$/;"	f	class:boost::system::error_category	signature:( int code, const error_condition & condition ) const
boost::system::error_category::message	/usr/include/boost/system/error_code.hpp	/^      virtual std::string      message( int ev ) const = 0;$/;"	p	class:boost::system::error_category	access:public	signature:( int ev ) const
boost::system::error_category::name	/usr/include/boost/system/error_code.hpp	/^      virtual const char *     name() const = 0;$/;"	p	class:boost::system::error_category	access:public	signature:() const
boost::system::error_category::operator !=	/usr/include/boost/system/error_code.hpp	/^      bool operator!=(const error_category & rhs) const { return this != &rhs; }$/;"	f	class:boost::system::error_category	access:public	signature:(const error_category & rhs) const
boost::system::error_category::operator <	/usr/include/boost/system/error_code.hpp	/^      bool operator<( const error_category & rhs ) const$/;"	f	class:boost::system::error_category	access:public	signature:( const error_category & rhs ) const
boost::system::error_category::operator ==	/usr/include/boost/system/error_code.hpp	/^      bool operator==(const error_category & rhs) const { return this == &rhs; }$/;"	f	class:boost::system::error_category	access:public	signature:(const error_category & rhs) const
boost::system::error_category::~error_category	/usr/include/boost/system/error_code.hpp	/^      virtual ~error_category(){}$/;"	f	class:boost::system::error_category	access:public	signature:()
boost::system::error_code	/usr/include/boost/system/error_code.hpp	/^    class error_code$/;"	c	namespace:boost::system
boost::system::error_code::assign	/usr/include/boost/system/error_code.hpp	/^      void assign( int val, const error_category & cat )$/;"	f	class:boost::system::error_code	access:public	signature:( int val, const error_category & cat )
boost::system::error_code::category	/usr/include/boost/system/error_code.hpp	/^      const error_category &  category() const { return *m_cat; }$/;"	f	class:boost::system::error_code	access:public	signature:() const
boost::system::error_code::clear	/usr/include/boost/system/error_code.hpp	/^      void clear()$/;"	f	class:boost::system::error_code	access:public	signature:()
boost::system::error_code::default_error_condition	/usr/include/boost/system/error_code.hpp	/^      error_condition         default_error_condition() const  { return m_cat->default_error_condition(value()); }$/;"	f	class:boost::system::error_code	access:public	signature:() const
boost::system::error_code::error_code	/usr/include/boost/system/error_code.hpp	/^        error_code(ErrorCodeEnum e,$/;"	f	class:boost::system::error_code	access:public	signature:(ErrorCodeEnum e, typename boost::enable_if<is_error_code_enum<ErrorCodeEnum> >::type* = 0)
boost::system::error_code::error_code	/usr/include/boost/system/error_code.hpp	/^      error_code( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}$/;"	f	class:boost::system::error_code	access:public	signature:( int val, const error_category & cat )
boost::system::error_code::error_code	/usr/include/boost/system/error_code.hpp	/^      error_code() : m_val(0), m_cat(&system_category()) {}$/;"	f	class:boost::system::error_code	access:public	signature:()
boost::system::error_code::message	/usr/include/boost/system/error_code.hpp	/^      std::string             message() const  { return m_cat->message(value()); }$/;"	f	class:boost::system::error_code	access:public	signature:() const
boost::system::error_code::m_cat	/usr/include/boost/system/error_code.hpp	/^      const error_category *  m_cat;$/;"	m	class:boost::system::error_code	access:private
boost::system::error_code::m_val	/usr/include/boost/system/error_code.hpp	/^      int                     m_val;$/;"	m	class:boost::system::error_code	access:private
boost::system::error_code::operator !	/usr/include/boost/system/error_code.hpp	/^      bool operator!() const  \/\/ true if no error$/;"	f	class:boost::system::error_code	access:public	signature:() const
boost::system::error_code::operator <	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator<( const error_code & lhs,$/;"	f	class:boost::system::error_code	access:friend	signature:( const error_code & lhs, const error_code & rhs )
boost::system::error_code::operator =	/usr/include/boost/system/error_code.hpp	/^          operator=( ErrorCodeEnum val )$/;"	f	class:boost::system::error_code	access:public	signature:( ErrorCodeEnum val )
boost::system::error_code::operator ==	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator==( const error_code & lhs,$/;"	f	class:boost::system::error_code	access:friend	signature:( const error_code & lhs, const error_code & rhs )
boost::system::error_code::operator unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      operator unspecified_bool_type() const  \/\/ true if error$/;"	f	class:boost::system::error_code	access:public	signature:() const
boost::system::error_code::unspecified_bool_true	/usr/include/boost/system/error_code.hpp	/^      static void unspecified_bool_true() {}$/;"	f	class:boost::system::error_code	access:public	signature:()
boost::system::error_code::unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      typedef void (*unspecified_bool_type)();$/;"	t	class:boost::system::error_code	access:public
boost::system::error_code::value	/usr/include/boost/system/error_code.hpp	/^      int                     value() const    { return m_val; }$/;"	f	class:boost::system::error_code	access:public	signature:() const
boost::system::error_condition	/usr/include/boost/system/error_code.hpp	/^    class error_condition$/;"	c	namespace:boost::system
boost::system::error_condition::assign	/usr/include/boost/system/error_code.hpp	/^      void assign( int val, const error_category & cat )$/;"	f	class:boost::system::error_condition	access:public	signature:( int val, const error_category & cat )
boost::system::error_condition::category	/usr/include/boost/system/error_code.hpp	/^      const error_category &  category() const { return *m_cat; }$/;"	f	class:boost::system::error_condition	access:public	signature:() const
boost::system::error_condition::clear	/usr/include/boost/system/error_code.hpp	/^      void clear()$/;"	f	class:boost::system::error_condition	access:public	signature:()
boost::system::error_condition::error_condition	/usr/include/boost/system/error_code.hpp	/^        error_condition(ErrorConditionEnum e,$/;"	f	class:boost::system::error_condition	access:public	signature:(ErrorConditionEnum e, typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum> >::type* = 0)
boost::system::error_condition::error_condition	/usr/include/boost/system/error_code.hpp	/^      error_condition( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}$/;"	f	class:boost::system::error_condition	access:public	signature:( int val, const error_category & cat )
boost::system::error_condition::error_condition	/usr/include/boost/system/error_code.hpp	/^      error_condition() : m_val(0), m_cat(&generic_category()) {}$/;"	f	class:boost::system::error_condition	access:public	signature:()
boost::system::error_condition::message	/usr/include/boost/system/error_code.hpp	/^      std::string             message() const  { return m_cat->message(value()); }$/;"	f	class:boost::system::error_condition	access:public	signature:() const
boost::system::error_condition::m_cat	/usr/include/boost/system/error_code.hpp	/^      const error_category *  m_cat;$/;"	m	class:boost::system::error_condition	access:private
boost::system::error_condition::m_val	/usr/include/boost/system/error_code.hpp	/^      int                     m_val;$/;"	m	class:boost::system::error_condition	access:private
boost::system::error_condition::operator !	/usr/include/boost/system/error_code.hpp	/^      bool operator!() const  \/\/ true if no error$/;"	f	class:boost::system::error_condition	access:public	signature:() const
boost::system::error_condition::operator <	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator<( const error_condition & lhs,$/;"	f	class:boost::system::error_condition	access:friend	signature:( const error_condition & lhs, const error_condition & rhs )
boost::system::error_condition::operator =	/usr/include/boost/system/error_code.hpp	/^          operator=( ErrorConditionEnum val )$/;"	f	class:boost::system::error_condition	access:public	signature:( ErrorConditionEnum val )
boost::system::error_condition::operator ==	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator==( const error_condition & lhs,$/;"	f	class:boost::system::error_condition	access:friend	signature:( const error_condition & lhs, const error_condition & rhs )
boost::system::error_condition::operator unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      operator unspecified_bool_type() const  \/\/ true if error$/;"	f	class:boost::system::error_condition	access:public	signature:() const
boost::system::error_condition::unspecified_bool_true	/usr/include/boost/system/error_code.hpp	/^      static void unspecified_bool_true() {}$/;"	f	class:boost::system::error_condition	access:public	signature:()
boost::system::error_condition::unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      typedef void (*unspecified_bool_type)();$/;"	t	class:boost::system::error_condition	access:public
boost::system::error_condition::value	/usr/include/boost/system/error_code.hpp	/^      int                     value() const    { return m_val; }$/;"	f	class:boost::system::error_condition	access:public	signature:() const
boost::system::generic_category	/usr/include/boost/system/error_code.hpp	/^    BOOST_SYSTEM_DECL const error_category &  generic_category();$/;"	p	namespace:boost::system	signature:()
boost::system::get_generic_category	/usr/include/boost/system/error_code.hpp	/^    inline const error_category &  get_generic_category() { return generic_category(); }$/;"	f	namespace:boost::system	signature:()
boost::system::get_posix_category	/usr/include/boost/system/error_code.hpp	/^    inline const error_category &  get_posix_category() { return generic_category(); }$/;"	f	namespace:boost::system	signature:()
boost::system::get_system_category	/usr/include/boost/system/error_code.hpp	/^    inline const error_category &  get_system_category() { return system_category(); }$/;"	f	namespace:boost::system	signature:()
boost::system::hash_value	/usr/include/boost/system/error_code.hpp	/^    inline std::size_t hash_value( const error_code & ec )$/;"	f	namespace:boost::system	signature:( const error_code & ec )
boost::system::is_error_code_enum	/usr/include/boost/system/cygwin_error.hpp	/^    template<> struct is_error_code_enum<cygwin_error::cygwin_errno>$/;"	s	namespace:boost::system
boost::system::is_error_code_enum	/usr/include/boost/system/error_code.hpp	/^    struct is_error_code_enum { static const bool value = false; };$/;"	s	namespace:boost::system
boost::system::is_error_code_enum	/usr/include/boost/system/linux_error.hpp	/^    template<> struct is_error_code_enum<linux_error::linux_errno>$/;"	s	namespace:boost::system
boost::system::is_error_code_enum	/usr/include/boost/system/windows_error.hpp	/^    template<> struct is_error_code_enum<windows_error::windows_error_code>$/;"	s	namespace:boost::system
boost::system::is_error_code_enum::value	/usr/include/boost/system/cygwin_error.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
boost::system::is_error_code_enum::value	/usr/include/boost/system/error_code.hpp	/^    struct is_error_code_enum { static const bool value = false; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
boost::system::is_error_code_enum::value	/usr/include/boost/system/linux_error.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
boost::system::is_error_code_enum::value	/usr/include/boost/system/windows_error.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
boost::system::is_error_condition_enum	/usr/include/boost/system/error_code.hpp	/^    struct is_error_condition_enum { static const bool value = false; };$/;"	s	namespace:boost::system
boost::system::is_error_condition_enum	/usr/include/boost/system/error_code.hpp	/^    template<> struct is_error_condition_enum<errc::errc_t>$/;"	s	namespace:boost::system
boost::system::is_error_condition_enum::value	/usr/include/boost/system/error_code.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_condition_enum	access:public
boost::system::is_error_condition_enum::value	/usr/include/boost/system/error_code.hpp	/^    struct is_error_condition_enum { static const bool value = false; };$/;"	m	struct:boost::system::is_error_condition_enum	access:public
boost::system::linux_error	/usr/include/boost/system/linux_error.hpp	/^    namespace linux_error$/;"	n	namespace:boost::system
boost::system::linux_error::advertise_error	/usr/include/boost/system/linux_error.hpp	/^        advertise_error = EADV,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::bad_exchange	/usr/include/boost/system/linux_error.hpp	/^        bad_exchange = EBADE,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::bad_file_number	/usr/include/boost/system/linux_error.hpp	/^        bad_file_number = EBADFD,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::bad_font_format	/usr/include/boost/system/linux_error.hpp	/^        bad_font_format = EBFONT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::bad_request_code	/usr/include/boost/system/linux_error.hpp	/^        bad_request_code = EBADRQC,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::bad_request_descriptor	/usr/include/boost/system/linux_error.hpp	/^        bad_request_descriptor = EBADR,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::bad_slot	/usr/include/boost/system/linux_error.hpp	/^        bad_slot = EBADSLT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::channel_range	/usr/include/boost/system/linux_error.hpp	/^        channel_range = ECHRNG,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::communication_error	/usr/include/boost/system/linux_error.hpp	/^        communication_error = ECOMM,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::dot_dot_error	/usr/include/boost/system/linux_error.hpp	/^        dot_dot_error = EDOTDOT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::exchange_full	/usr/include/boost/system/linux_error.hpp	/^        exchange_full = EXFULL,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::host_down	/usr/include/boost/system/linux_error.hpp	/^        host_down = EHOSTDOWN,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::is_named_file_type	/usr/include/boost/system/linux_error.hpp	/^        is_named_file_type= EISNAM,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::key_expired	/usr/include/boost/system/linux_error.hpp	/^        key_expired = EKEYEXPIRED,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::key_rejected	/usr/include/boost/system/linux_error.hpp	/^        key_rejected = EKEYREJECTED,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::key_revoked	/usr/include/boost/system/linux_error.hpp	/^        key_revoked = EKEYREVOKED,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::level2_halt	/usr/include/boost/system/linux_error.hpp	/^        level2_halt= EL2HLT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::level2_no_syncronized	/usr/include/boost/system/linux_error.hpp	/^        level2_no_syncronized= EL2NSYNC,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::level3_halt	/usr/include/boost/system/linux_error.hpp	/^        level3_halt = EL3HLT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::level3_reset	/usr/include/boost/system/linux_error.hpp	/^        level3_reset = EL3RST,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::link_range	/usr/include/boost/system/linux_error.hpp	/^        link_range = ELNRNG,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::linux_errno	/usr/include/boost/system/linux_error.hpp	/^      enum linux_errno$/;"	g	namespace:boost::system::linux_error
boost::system::linux_error::make_error_code	/usr/include/boost/system/linux_error.hpp	/^      inline error_code make_error_code( linux_errno e )$/;"	f	namespace:boost::system::linux_error	signature:( linux_errno e )
boost::system::linux_error::medium_type	/usr/include/boost/system/linux_error.hpp	/^        medium_type = EMEDIUMTYPE,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::not_avail	/usr/include/boost/system/linux_error.hpp	/^        not_avail = ENAVAIL,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::not_named_file_type	/usr/include/boost/system/linux_error.hpp	/^        not_named_file_type= ENOTNAM,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::not_recoverable	/usr/include/boost/system/linux_error.hpp	/^        not_recoverable = ENOTRECOVERABLE,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::not_unique	/usr/include/boost/system/linux_error.hpp	/^        not_unique = ENOTUNIQ,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::no_anode	/usr/include/boost/system/linux_error.hpp	/^        no_anode= ENOANO,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::no_block_device	/usr/include/boost/system/linux_error.hpp	/^        no_block_device = ENOTBLK,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::no_csi	/usr/include/boost/system/linux_error.hpp	/^        no_csi = ENOCSI,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::no_key	/usr/include/boost/system/linux_error.hpp	/^        no_key = ENOKEY,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::no_medium	/usr/include/boost/system/linux_error.hpp	/^        no_medium = ENOMEDIUM,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::no_network	/usr/include/boost/system/linux_error.hpp	/^        no_network = ENONET,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::no_package	/usr/include/boost/system/linux_error.hpp	/^        no_package = ENOPKG,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::owner_dead	/usr/include/boost/system/linux_error.hpp	/^        owner_dead = EOWNERDEAD,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::protocol_no_supported	/usr/include/boost/system/linux_error.hpp	/^        protocol_no_supported = EPFNOSUPPORT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::remote_address_changed	/usr/include/boost/system/linux_error.hpp	/^        remote_address_changed = EREMCHG,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::remote_io_error	/usr/include/boost/system/linux_error.hpp	/^        remote_io_error = EREMOTEIO,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::remote_object	/usr/include/boost/system/linux_error.hpp	/^        remote_object = EREMOTE,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::restart_needed	/usr/include/boost/system/linux_error.hpp	/^        restart_needed = ERESTART,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::shared_library_access	/usr/include/boost/system/linux_error.hpp	/^        shared_library_access = ELIBACC,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::shared_library_bad	/usr/include/boost/system/linux_error.hpp	/^        shared_library_bad = ELIBBAD,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::shared_library_execute	/usr/include/boost/system/linux_error.hpp	/^        shared_library_execute = ELIBEXEC,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::shared_library_max_	/usr/include/boost/system/linux_error.hpp	/^        shared_library_max_ = ELIBMAX,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::shared_library_section	/usr/include/boost/system/linux_error.hpp	/^        shared_library_section= ELIBSCN,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::shutdown	/usr/include/boost/system/linux_error.hpp	/^        shutdown = ESHUTDOWN,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::socket_type_not_supported	/usr/include/boost/system/linux_error.hpp	/^        socket_type_not_supported = ESOCKTNOSUPPORT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::srmount_error	/usr/include/boost/system/linux_error.hpp	/^        srmount_error = ESRMNT,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::stream_pipe_error	/usr/include/boost/system/linux_error.hpp	/^        stream_pipe_error = ESTRPIPE,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::too_many_references	/usr/include/boost/system/linux_error.hpp	/^        too_many_references = ETOOMANYREFS,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::too_many_users	/usr/include/boost/system/linux_error.hpp	/^        too_many_users = EUSERS,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::unattached	/usr/include/boost/system/linux_error.hpp	/^        unattached = EUNATCH,$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::linux_error::unclean	/usr/include/boost/system/linux_error.hpp	/^        unclean = EUCLEAN$/;"	e	enum:boost::system::linux_error::linux_errno
boost::system::native_ecat	/usr/include/boost/system/error_code.hpp	/^    static const error_category &  native_ecat    = system_category();$/;"	m	namespace:boost::system
boost::system::operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_code & lhs,$/;"	f	namespace:boost::system	signature:( const error_code & lhs, const error_code & rhs )
boost::system::operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_code & lhs,$/;"	f	namespace:boost::system	signature:( const error_code & lhs, const error_condition & rhs )
boost::system::operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_condition & lhs,$/;"	f	namespace:boost::system	signature:( const error_condition & lhs, const error_code & rhs )
boost::system::operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_condition & lhs,$/;"	f	namespace:boost::system	signature:( const error_condition & lhs, const error_condition & rhs )
boost::system::operator <<	/usr/include/boost/system/error_code.hpp	/^      operator<< (std::basic_ostream<charT,traits>& os, error_code ec)$/;"	f	namespace:boost::system	signature:(std::basic_ostream<charT,traits>& os, error_code ec)
boost::system::operator ==	/usr/include/boost/system/error_code.hpp	/^    inline bool operator==( const error_code & code,$/;"	f	namespace:boost::system	signature:( const error_code & code, const error_condition & condition )
boost::system::operator ==	/usr/include/boost/system/error_code.hpp	/^    inline bool operator==( const error_condition & condition,$/;"	f	namespace:boost::system	signature:( const error_condition & condition, const error_code & code )
boost::system::posix_category	/usr/include/boost/system/error_code.hpp	/^    static const error_category &  posix_category = generic_category();$/;"	m	namespace:boost::system
boost::system::system_category	/usr/include/boost/system/error_code.hpp	/^    BOOST_SYSTEM_DECL const error_category &  system_category();$/;"	p	namespace:boost::system	signature:()
boost::system::system_error	/usr/include/boost/system/system_error.hpp	/^    class BOOST_SYMBOL_VISIBLE system_error : public std::runtime_error$/;"	c	namespace:boost::system	inherits:std::runtime_error
boost::system::system_error::code	/usr/include/boost/system/system_error.hpp	/^      const error_code &  code() const throw() { return m_error_code; }$/;"	f	class:boost::system::system_error	access:public	signature:() const
boost::system::system_error::m_error_code	/usr/include/boost/system/system_error.hpp	/^      error_code           m_error_code;$/;"	m	class:boost::system::system_error	access:private
boost::system::system_error::m_what	/usr/include/boost/system/system_error.hpp	/^      mutable std::string  m_what;$/;"	m	class:boost::system::system_error	access:private
boost::system::system_error::system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( error_code ec )$/;"	f	class:boost::system::system_error	access:public	signature:( error_code ec )
boost::system::system_error::system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( error_code ec, const char* what_arg )$/;"	f	class:boost::system::system_error	access:public	signature:( error_code ec, const char* what_arg )
boost::system::system_error::system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( error_code ec, const std::string & what_arg )$/;"	f	class:boost::system::system_error	access:public	signature:( error_code ec, const std::string & what_arg )
boost::system::system_error::system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( int ev, const error_category & ecat )$/;"	f	class:boost::system::system_error	access:public	signature:( int ev, const error_category & ecat )
boost::system::system_error::system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( int ev, const error_category & ecat,$/;"	f	class:boost::system::system_error	access:public	signature:( int ev, const error_category & ecat, const char * what_arg )
boost::system::system_error::system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( int ev, const error_category & ecat,$/;"	f	class:boost::system::system_error	access:public	signature:( int ev, const error_category & ecat, const std::string & what_arg )
boost::system::system_error::what	/usr/include/boost/system/system_error.hpp	/^      const char *        what() const throw();$/;"	p	class:boost::system::system_error	access:public	signature:() const
boost::system::system_error::what	/usr/include/boost/system/system_error.hpp	/^    inline const char * system_error::what() const throw()$/;"	f	class:boost::system::system_error	signature:() const
boost::system::system_error::~system_error	/usr/include/boost/system/system_error.hpp	/^      virtual ~system_error() throw() {}$/;"	f	class:boost::system::system_error	access:public	signature:()
boost::system::windows_error	/usr/include/boost/system/windows_error.hpp	/^    namespace windows_error$/;"	n	namespace:boost::system
boost::system::windows_error::access_denied	/usr/include/boost/system/windows_error.hpp	/^        access_denied = ERROR_ACCESS_DENIED,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::already_exists	/usr/include/boost/system/windows_error.hpp	/^        already_exists = ERROR_ALREADY_EXISTS$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::arena_trashed	/usr/include/boost/system/windows_error.hpp	/^        arena_trashed = ERROR_ARENA_TRASHED,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::bad_command	/usr/include/boost/system/windows_error.hpp	/^        bad_command = ERROR_BAD_COMMAND,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::bad_environment	/usr/include/boost/system/windows_error.hpp	/^        bad_environment = ERROR_BAD_ENVIRONMENT,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::bad_format	/usr/include/boost/system/windows_error.hpp	/^        bad_format = ERROR_BAD_FORMAT,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::bad_length	/usr/include/boost/system/windows_error.hpp	/^        bad_length = ERROR_BAD_LENGTH,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::bad_net_path	/usr/include/boost/system/windows_error.hpp	/^        bad_net_path = ERROR_BAD_NETPATH,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::bad_unit	/usr/include/boost/system/windows_error.hpp	/^        bad_unit = ERROR_BAD_UNIT,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::broken_pipe	/usr/include/boost/system/windows_error.hpp	/^        broken_pipe = ERROR_BROKEN_PIPE,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::buffer_overflow	/usr/include/boost/system/windows_error.hpp	/^        buffer_overflow = ERROR_BUFFER_OVERFLOW,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::busy	/usr/include/boost/system/windows_error.hpp	/^        busy = ERROR_BUSY,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::cancel_violation	/usr/include/boost/system/windows_error.hpp	/^        cancel_violation = ERROR_CANCEL_VIOLATION,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::cannot_make	/usr/include/boost/system/windows_error.hpp	/^        cannot_make = ERROR_CANNOT_MAKE,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::crc	/usr/include/boost/system/windows_error.hpp	/^        crc = ERROR_CRC,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::current_directory	/usr/include/boost/system/windows_error.hpp	/^        current_directory = ERROR_CURRENT_DIRECTORY,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::disk_full	/usr/include/boost/system/windows_error.hpp	/^        disk_full= ERROR_DISK_FULL,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::dup_name	/usr/include/boost/system/windows_error.hpp	/^        dup_name = ERROR_DUP_NAME,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::file_exists	/usr/include/boost/system/windows_error.hpp	/^        file_exists = ERROR_FILE_EXISTS,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::file_not_found	/usr/include/boost/system/windows_error.hpp	/^        file_not_found = ERROR_FILE_NOT_FOUND,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::gen_failure	/usr/include/boost/system/windows_error.hpp	/^        gen_failure = ERROR_GEN_FAILURE,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::handle_disk_full	/usr/include/boost/system/windows_error.hpp	/^        handle_disk_full= ERROR_HANDLE_DISK_FULL,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::handle_eof	/usr/include/boost/system/windows_error.hpp	/^        handle_eof = ERROR_HANDLE_EOF,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::invalid_access	/usr/include/boost/system/windows_error.hpp	/^        invalid_access = ERROR_INVALID_ACCESS,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::invalid_block	/usr/include/boost/system/windows_error.hpp	/^        invalid_block = ERROR_INVALID_BLOCK,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::invalid_drive	/usr/include/boost/system/windows_error.hpp	/^        invalid_drive = ERROR_INVALID_DRIVE,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::invalid_function	/usr/include/boost/system/windows_error.hpp	/^        invalid_function = ERROR_INVALID_FUNCTION,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::invalid_handle	/usr/include/boost/system/windows_error.hpp	/^        invalid_handle = ERROR_INVALID_HANDLE,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::lock_failed	/usr/include/boost/system/windows_error.hpp	/^        lock_failed = ERROR_LOCK_FAILED,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::lock_violation	/usr/include/boost/system/windows_error.hpp	/^        lock_violation = ERROR_LOCK_VIOLATION,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::make_error_code	/usr/include/boost/system/windows_error.hpp	/^      inline error_code make_error_code( windows_error_code e )$/;"	f	namespace:boost::system::windows_error	signature:( windows_error_code e )
boost::system::windows_error::network_busy	/usr/include/boost/system/windows_error.hpp	/^        network_busy = ERROR_NETWORK_BUSY,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::not_dos_disk	/usr/include/boost/system/windows_error.hpp	/^        not_dos_disk = ERROR_NOT_DOS_DISK,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::not_enough_memory	/usr/include/boost/system/windows_error.hpp	/^        not_enough_memory = ERROR_NOT_ENOUGH_MEMORY,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::not_ready	/usr/include/boost/system/windows_error.hpp	/^        not_ready = ERROR_NOT_READY,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::not_same_device	/usr/include/boost/system/windows_error.hpp	/^        not_same_device = ERROR_NOT_SAME_DEVICE,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::no_more_files	/usr/include/boost/system/windows_error.hpp	/^        no_more_files = ERROR_NO_MORE_FILES,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::open_failed	/usr/include/boost/system/windows_error.hpp	/^        open_failed = ERROR_OPEN_FAILED,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::outofmemory	/usr/include/boost/system/windows_error.hpp	/^        outofmemory = ERROR_OUTOFMEMORY,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::out_of_paper	/usr/include/boost/system/windows_error.hpp	/^        out_of_paper = ERROR_OUT_OF_PAPER,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::path_not_found	/usr/include/boost/system/windows_error.hpp	/^        path_not_found = ERROR_PATH_NOT_FOUND,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::read_fault	/usr/include/boost/system/windows_error.hpp	/^        read_fault = ERROR_READ_FAULT,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::rem_not_list	/usr/include/boost/system/windows_error.hpp	/^        rem_not_list = ERROR_REM_NOT_LIST,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::sector_not_found	/usr/include/boost/system/windows_error.hpp	/^        sector_not_found = ERROR_SECTOR_NOT_FOUND,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::seek	/usr/include/boost/system/windows_error.hpp	/^        seek = ERROR_SEEK,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::sharing_buffer_exceeded	/usr/include/boost/system/windows_error.hpp	/^        sharing_buffer_exceeded = ERROR_SHARING_BUFFER_EXCEEDED,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::sharing_violation	/usr/include/boost/system/windows_error.hpp	/^        sharing_violation = ERROR_SHARING_VIOLATION,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::success	/usr/include/boost/system/windows_error.hpp	/^        success = 0,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::too_many_open_files	/usr/include/boost/system/windows_error.hpp	/^        too_many_open_files = ERROR_TOO_MANY_OPEN_FILES,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::windows_error_code	/usr/include/boost/system/windows_error.hpp	/^      enum windows_error_code$/;"	g	namespace:boost::system::windows_error
boost::system::windows_error::write_fault	/usr/include/boost/system/windows_error.hpp	/^        write_fault = ERROR_WRITE_FAULT,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::write_protect	/usr/include/boost/system/windows_error.hpp	/^        write_protect = ERROR_WRITE_PROTECT,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::system::windows_error::wrong_disk	/usr/include/boost/system/windows_error.hpp	/^        wrong_disk = ERROR_WRONG_DISK,$/;"	e	enum:boost::system::windows_error::windows_error_code
boost::throws	/usr/include/boost/system/error_code.hpp	/^  inline system::error_code & throws()$/;"	f	namespace:boost	signature:()
boost::tmatch	/usr/include/boost/regex/mfc.hpp	/^typedef match_results<TCHAR const*> tmatch;$/;"	t	namespace:boost
boost::tregex	/usr/include/boost/regex/mfc.hpp	/^typedef basic_regex<TCHAR> tregex;$/;"	t	namespace:boost
boost::tregex_iterator	/usr/include/boost/regex/mfc.hpp	/^typedef regex_iterator<TCHAR const*> tregex_iterator;$/;"	t	namespace:boost
boost::tregex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^typedef regex_token_iterator<TCHAR const*> tregex_token_iterator;$/;"	t	namespace:boost
boost::u16match	/usr/include/boost/regex/icu.hpp	/^typedef match_results<const ::UChar*> u16match;$/;"	t	namespace:boost
boost::u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u16_to_u32_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
boost::u16_to_u32_iterator::base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:() const
boost::u16_to_u32_iterator::base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u16_to_u32_iterator<BaseIterator, U32Type>, U32Type, std::bidirectional_iterator_tag, const U32Type> base_type;$/;"	t	class:boost::u16_to_u32_iterator	access:private
boost::u16_to_u32_iterator::base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u16_to_u32_iterator	access:private
boost::u16_to_u32_iterator::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_CONSTANT(U32Type, pending_read = 0xffffffffu);$/;"	p	class:boost::u16_to_u32_iterator	access:private	signature:(U32Type, pending_read = 0xffffffffu)
boost::u16_to_u32_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 16);$/;"	m	class:boost::u16_to_u32_iterator	access:private
boost::u16_to_u32_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U32Type)*CHAR_BIT == 32);$/;"	m	class:boost::u16_to_u32_iterator	access:private
boost::u16_to_u32_iterator::decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:()
boost::u16_to_u32_iterator::dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:() const
boost::u16_to_u32_iterator::equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u16_to_u32_iterator& that)const$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:(const u16_to_u32_iterator& that) const
boost::u16_to_u32_iterator::extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u16_to_u32_iterator	access:private	signature:() const
boost::u16_to_u32_iterator::increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:()
boost::u16_to_u32_iterator::invalid_code_point	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   static void invalid_code_point(::boost::uint16_t val)$/;"	f	class:boost::u16_to_u32_iterator	access:private	signature:(::boost::uint16_t val)
boost::u16_to_u32_iterator::m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u16_to_u32_iterator	access:private
boost::u16_to_u32_iterator::m_value	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U32Type m_value;$/;"	m	class:boost::u16_to_u32_iterator	access:private
boost::u16_to_u32_iterator::u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u16_to_u32_iterator() : m_position()$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:()
boost::u16_to_u32_iterator::u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u16_to_u32_iterator(BaseIterator b) : m_position(b)$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:(BaseIterator b)
boost::u16_to_u32_iterator::u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u16_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:(BaseIterator b, BaseIterator start, BaseIterator end)
boost::u32match	/usr/include/boost/regex/icu.hpp	/^typedef match_results<const ::UChar32*> u32match;$/;"	t	namespace:boost
boost::u32regex	/usr/include/boost/regex/icu.hpp	/^typedef basic_regex< ::UChar32, icu_regex_traits> u32regex;$/;"	t	namespace:boost
boost::u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^class u32regex_iterator $/;"	c	namespace:boost	inherits:std::iterator
boost::u32regex_iterator::cow	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   void cow()$/;"	f	class:boost::u32regex_iterator	access:private	signature:()
boost::u32regex_iterator::difference_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::u32regex_iterator	access:public
boost::u32regex_iterator::impl	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef u32regex_iterator_implementation<BidirectionalIterator> impl;$/;"	t	class:boost::u32regex_iterator	access:private
boost::u32regex_iterator::iterator_category	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::u32regex_iterator	access:public
boost::u32regex_iterator::operator !=	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool operator!=(const u32regex_iterator& that)const$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that) const
boost::u32regex_iterator::operator *	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::u32regex_iterator	access:public	signature:() const
boost::u32regex_iterator::operator ++	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator operator++(int)$/;"	f	class:boost::u32regex_iterator	access:public	signature:(int)
boost::u32regex_iterator::operator ++	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator& operator++()$/;"	f	class:boost::u32regex_iterator	access:public	signature:()
boost::u32regex_iterator::operator ->	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::u32regex_iterator	access:public	signature:() const
boost::u32regex_iterator::operator =	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator& operator=(const u32regex_iterator& that)$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that)
boost::u32regex_iterator::operator ==	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool operator==(const u32regex_iterator& that)const$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that) const
boost::u32regex_iterator::pdata	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::u32regex_iterator	access:private
boost::u32regex_iterator::pimpl	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::u32regex_iterator	access:private
boost::u32regex_iterator::pointer	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::u32regex_iterator	access:public
boost::u32regex_iterator::reference	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::u32regex_iterator	access:public
boost::u32regex_iterator::regex_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          u32regex                                                regex_type;$/;"	t	class:boost::u32regex_iterator	access:public
boost::u32regex_iterator::u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator(){}$/;"	f	class:boost::u32regex_iterator	access:public	signature:()
boost::u32regex_iterator::u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator(BidirectionalIterator a, BidirectionalIterator b, $/;"	f	class:boost::u32regex_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, match_flag_type m = match_default)
boost::u32regex_iterator::u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator(const u32regex_iterator& that)$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that)
boost::u32regex_iterator::value_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          match_results<BidirectionalIterator>                    value_type;$/;"	t	class:boost::u32regex_iterator	access:public
boost::u32regex_iterator_implementation	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^class u32regex_iterator_implementation $/;"	c	namespace:boost
boost::u32regex_iterator_implementation::base	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   BidirectionalIterator                base;  \/\/ start of sequence$/;"	m	class:boost::u32regex_iterator_implementation	access:private
boost::u32regex_iterator_implementation::compare	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool compare(const u32regex_iterator_implementation& that)$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:(const u32regex_iterator_implementation& that)
boost::u32regex_iterator_implementation::end	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   BidirectionalIterator                end;   \/\/ end of sequence$/;"	m	class:boost::u32regex_iterator_implementation	access:private
boost::u32regex_iterator_implementation::flags	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   match_flag_type                      flags; \/\/ flags for matching$/;"	m	class:boost::u32regex_iterator_implementation	access:private
boost::u32regex_iterator_implementation::get	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const match_results<BidirectionalIterator>& get()$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:()
boost::u32regex_iterator_implementation::init	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:(BidirectionalIterator first)
boost::u32regex_iterator_implementation::next	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool next()$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:()
boost::u32regex_iterator_implementation::operator =	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator_implementation& operator=(const u32regex_iterator_implementation&);$/;"	p	class:boost::u32regex_iterator_implementation	access:private	signature:(const u32regex_iterator_implementation&)
boost::u32regex_iterator_implementation::re	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const regex_type                     re;   \/\/ the expression$/;"	m	class:boost::u32regex_iterator_implementation	access:private
boost::u32regex_iterator_implementation::regex_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef u32regex regex_type;$/;"	t	class:boost::u32regex_iterator_implementation	access:private
boost::u32regex_iterator_implementation::u32regex_iterator_implementation	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator_implementation(const regex_type* p, BidirectionalIterator last, match_flag_type f)$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, match_flag_type f)
boost::u32regex_iterator_implementation::what	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   match_results<BidirectionalIterator> what;  \/\/ current match$/;"	m	class:boost::u32regex_iterator_implementation	access:private
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const char* p, $/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const char* p, $/;"	f	namespace:boost	signature:(const char* p, match_results<const char*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, match_results<std::string::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, match_results<std::wstring::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, match_results<const unsigned char*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, match_results<const wchar_t*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator u32regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last, const u32regex& e, const charT* fmt, match_flag_type flags = match_default)
boost::u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator u32regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const u32regex& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
boost::u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator u32regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const u32regex& e, const U_NAMESPACE_QUALIFIER UnicodeString& fmt, match_flag_type flags = match_default)
boost::u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline U_NAMESPACE_QUALIFIER UnicodeString u32regex_replace(const U_NAMESPACE_QUALIFIER UnicodeString& s,$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const UChar* fmt, match_flag_type flags = match_default)
boost::u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline U_NAMESPACE_QUALIFIER UnicodeString u32regex_replace(const U_NAMESPACE_QUALIFIER UnicodeString& s,$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const U_NAMESPACE_QUALIFIER UnicodeString& fmt, match_flag_type flags = match_default)
boost::u32regex_replace	/usr/include/boost/regex/icu.hpp	/^std::basic_string<charT> u32regex_replace(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const u32regex& e, const charT* fmt, match_flag_type flags = match_default)
boost::u32regex_replace	/usr/include/boost/regex/icu.hpp	/^std::basic_string<charT> u32regex_replace(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const u32regex& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const char* p, $/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const char* p, $/;"	f	namespace:boost	signature:(const char* p, match_results<const char*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, match_results<std::string::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, match_results<std::wstring::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, match_results<const unsigned char*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, match_results<const wchar_t*>& m, const u32regex& e, match_flag_type flags = match_default)
boost::u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^class u32regex_token_iterator $/;"	c	namespace:boost	inherits:std::iterator
boost::u32regex_token_iterator::cow	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   void cow()$/;"	f	class:boost::u32regex_token_iterator	access:private	signature:()
boost::u32regex_token_iterator::difference_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::u32regex_token_iterator	access:public
boost::u32regex_token_iterator::impl	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef u32regex_token_iterator_implementation<BidirectionalIterator> impl;$/;"	t	class:boost::u32regex_token_iterator	access:private
boost::u32regex_token_iterator::iterator_category	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::u32regex_token_iterator	access:public
boost::u32regex_token_iterator::operator !=	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool operator!=(const u32regex_token_iterator& that)const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that) const
boost::u32regex_token_iterator::operator *	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:() const
boost::u32regex_token_iterator::operator ++	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator operator++(int)$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(int)
boost::u32regex_token_iterator::operator ++	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator& operator++()$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:()
boost::u32regex_token_iterator::operator ->	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:() const
boost::u32regex_token_iterator::operator =	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator& operator=(const u32regex_token_iterator& that)$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that)
boost::u32regex_token_iterator::operator ==	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool operator==(const u32regex_token_iterator& that)const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that) const
boost::u32regex_token_iterator::pdata	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::u32regex_token_iterator	access:private
boost::u32regex_token_iterator::pimpl	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::u32regex_token_iterator	access:private
boost::u32regex_token_iterator::pointer	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::u32regex_token_iterator	access:public
boost::u32regex_token_iterator::reference	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::u32regex_token_iterator	access:public
boost::u32regex_token_iterator::regex_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          u32regex                                                regex_type;$/;"	t	class:boost::u32regex_token_iterator	access:public
boost::u32regex_token_iterator::u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(){}$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:()
boost::u32regex_token_iterator::u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const std::vector<int>& submatches, match_flag_type m = match_default)
boost::u32regex_token_iterator::u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, int submatch = 0, match_flag_type m = match_default)
boost::u32regex_token_iterator::u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const int (&submatches)[N], match_flag_type m = match_default)
boost::u32regex_token_iterator::u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const T& submatches, match_flag_type m = match_default)
boost::u32regex_token_iterator::u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(const u32regex_token_iterator& that)$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that)
boost::u32regex_token_iterator::value_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          sub_match<BidirectionalIterator>                        value_type;$/;"	t	class:boost::u32regex_token_iterator	access:public
boost::u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^class u32regex_token_iterator_implementation $/;"	c	namespace:boost
boost::u32regex_token_iterator_implementation::base	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   BidirectionalIterator                base;   \/\/ start of search area$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::compare	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool compare(const u32regex_token_iterator_implementation& that)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const u32regex_token_iterator_implementation& that)
boost::u32regex_token_iterator_implementation::end	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   BidirectionalIterator                end;    \/\/ end of search area$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::flags	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   match_flag_type                      flags;  \/\/ match flags$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::get	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const value_type& get()$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:()
boost::u32regex_token_iterator_implementation::init	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(BidirectionalIterator first)
boost::u32regex_token_iterator_implementation::N	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   int                                  N;      \/\/ the current sub-expression being enumerated$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::next	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool next()$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:()
boost::u32regex_token_iterator_implementation::operator =	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation& operator=(const u32regex_token_iterator_implementation&);$/;"	p	class:boost::u32regex_token_iterator_implementation	access:private	signature:(const u32regex_token_iterator_implementation&)
boost::u32regex_token_iterator_implementation::re	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const regex_type                     re;     \/\/ the expression$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::regex_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef u32regex                              regex_type;$/;"	t	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::result	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   value_type                           result; \/\/ the current string result$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::subs	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   std::vector<int>                     subs;   \/\/ the sub-expressions to enumerate$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)
boost::u32regex_token_iterator_implementation::u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)
boost::u32regex_token_iterator_implementation::u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)
boost::u32regex_token_iterator_implementation::u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
boost::u32regex_token_iterator_implementation::value_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef sub_match<BidirectionalIterator>      value_type;$/;"	t	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32regex_token_iterator_implementation::what	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   match_results<BidirectionalIterator> what;   \/\/ current match$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
boost::u32_to_u16_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u32_to_u16_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
boost::u32_to_u16_iterator::base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:() const
boost::u32_to_u16_iterator::base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u32_to_u16_iterator<BaseIterator, U16Type>, U16Type, std::bidirectional_iterator_tag, const U16Type> base_type;$/;"	t	class:boost::u32_to_u16_iterator	access:private
boost::u32_to_u16_iterator::base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u32_to_u16_iterator	access:private
boost::u32_to_u16_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 32);$/;"	m	class:boost::u32_to_u16_iterator	access:private
boost::u32_to_u16_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U16Type)*CHAR_BIT == 16);$/;"	m	class:boost::u32_to_u16_iterator	access:private
boost::u32_to_u16_iterator::decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:()
boost::u32_to_u16_iterator::dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:() const
boost::u32_to_u16_iterator::equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u32_to_u16_iterator& that)const$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:(const u32_to_u16_iterator& that) const
boost::u32_to_u16_iterator::extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u32_to_u16_iterator	access:private	signature:() const
boost::u32_to_u16_iterator::increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:()
boost::u32_to_u16_iterator::m_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable unsigned m_current;$/;"	m	class:boost::u32_to_u16_iterator	access:private
boost::u32_to_u16_iterator::m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u32_to_u16_iterator	access:private
boost::u32_to_u16_iterator::m_values	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U16Type m_values[3];$/;"	m	class:boost::u32_to_u16_iterator	access:private
boost::u32_to_u16_iterator::u32_to_u16_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u16_iterator() : m_position(), m_current(0)$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:()
boost::u32_to_u16_iterator::u32_to_u16_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u16_iterator(BaseIterator b) : m_position(b), m_current(2)$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:(BaseIterator b)
boost::u32_to_u8_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u32_to_u8_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
boost::u32_to_u8_iterator::base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:() const
boost::u32_to_u8_iterator::base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u32_to_u8_iterator<BaseIterator, U8Type>, U8Type, std::bidirectional_iterator_tag, const U8Type> base_type;$/;"	t	class:boost::u32_to_u8_iterator	access:private
boost::u32_to_u8_iterator::base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u32_to_u8_iterator	access:private
boost::u32_to_u8_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 32);$/;"	m	class:boost::u32_to_u8_iterator	access:private
boost::u32_to_u8_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U8Type)*CHAR_BIT == 8);$/;"	m	class:boost::u32_to_u8_iterator	access:private
boost::u32_to_u8_iterator::decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:()
boost::u32_to_u8_iterator::dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:() const
boost::u32_to_u8_iterator::equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u32_to_u8_iterator& that)const$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:(const u32_to_u8_iterator& that) const
boost::u32_to_u8_iterator::extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u32_to_u8_iterator	access:private	signature:() const
boost::u32_to_u8_iterator::increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:()
boost::u32_to_u8_iterator::m_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable unsigned m_current;$/;"	m	class:boost::u32_to_u8_iterator	access:private
boost::u32_to_u8_iterator::m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u32_to_u8_iterator	access:private
boost::u32_to_u8_iterator::m_values	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U8Type m_values[5];$/;"	m	class:boost::u32_to_u8_iterator	access:private
boost::u32_to_u8_iterator::u32_to_u8_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u8_iterator() : m_position(), m_current(0)$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:()
boost::u32_to_u8_iterator::u32_to_u8_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u8_iterator(BaseIterator b) : m_position(b), m_current(4)$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:(BaseIterator b)
boost::u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u8_to_u32_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
boost::u8_to_u32_iterator::base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:() const
boost::u8_to_u32_iterator::base_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::iterator_facade<u8_to_u32_iterator<BaseIterator, U32Type>, U32Type, std::bidirectional_iterator_tag, const U32Type> base_type;$/;"	t	class:boost::u8_to_u32_iterator	access:private
boost::u8_to_u32_iterator::base_value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;$/;"	t	class:boost::u8_to_u32_iterator	access:private
boost::u8_to_u32_iterator::BOOST_STATIC_CONSTANT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_CONSTANT(U32Type, pending_read = 0xffffffffu);$/;"	p	class:boost::u8_to_u32_iterator	access:private	signature:(U32Type, pending_read = 0xffffffffu)
boost::u8_to_u32_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 8);$/;"	m	class:boost::u8_to_u32_iterator	access:private
boost::u8_to_u32_iterator::CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U32Type)*CHAR_BIT == 32);$/;"	m	class:boost::u8_to_u32_iterator	access:private
boost::u8_to_u32_iterator::decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:()
boost::u8_to_u32_iterator::dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:() const
boost::u8_to_u32_iterator::equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u8_to_u32_iterator& that)const$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:(const u8_to_u32_iterator& that) const
boost::u8_to_u32_iterator::extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u8_to_u32_iterator	access:private	signature:() const
boost::u8_to_u32_iterator::increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:()
boost::u8_to_u32_iterator::invalid_sequence	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   static void invalid_sequence()$/;"	f	class:boost::u8_to_u32_iterator	access:private	signature:()
boost::u8_to_u32_iterator::m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u8_to_u32_iterator	access:private
boost::u8_to_u32_iterator::m_value	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U32Type m_value;$/;"	m	class:boost::u8_to_u32_iterator	access:private
boost::u8_to_u32_iterator::u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u8_to_u32_iterator() : m_position()$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:()
boost::u8_to_u32_iterator::u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u8_to_u32_iterator(BaseIterator b) : m_position(b)$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:(BaseIterator b)
boost::u8_to_u32_iterator::u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u8_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:(BaseIterator b, BaseIterator start, BaseIterator end)
boost::units	/usr/include/boost/units/get_system.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/heterogeneous_system.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/homogeneous_system.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/is_quantity_of_system.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/is_unit_of_system.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/make_system.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/abstract.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/angle/degrees.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/angle/gradians.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/angle/revolutions.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/area.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/base.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/current.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/dimensionless.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/energy.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/force.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/frequency.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/io.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/length.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/mass.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/mass_density.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/momentum.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/power.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/pressure.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/time.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/velocity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/volume.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/detail/constants.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/acceleration.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/action.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/activity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/amount.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/angular_acceleration.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/angular_momentum.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/area.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/base.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/capacitance.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/conductance.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/conductivity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/current.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/dimensionless.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/electric_charge.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/electric_potential.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/energy.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/force.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/frequency.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/illuminance.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/impedance.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/inductance.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/io.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/length.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/mass.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/mass_density.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/momentum.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/permeability.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/permittivity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/plane_angle.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/power.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/prefixes.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/pressure.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/reluctance.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/resistance.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/resistivity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/solid_angle.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/surface_density.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/surface_tension.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/temperature.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/time.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/torque.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/velocity.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/volume.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/si/wavenumber.hpp	/^namespace units { $/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/temperature/celsius.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^namespace units {$/;"	n	namespace:boost
boost::units::abstract	/usr/include/boost/units/systems/abstract.hpp	/^namespace abstract {$/;"	n	namespace:boost::units
boost::units::abstract::amount	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<amount_dimension,system>                amount;                 \/\/\/< abstract unit of amount$/;"	t	namespace:boost::units::abstract
boost::units::abstract::amount_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct amount_unit_tag : base_unit<amount_unit_tag, amount_dimension, -25> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::current	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<current_dimension,system>               current;                \/\/\/< abstract unit of current$/;"	t	namespace:boost::units::abstract
boost::units::abstract::current_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct current_unit_tag : base_unit<current_unit_tag, current_dimension, -27> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::length	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<length_dimension,system>                length;                 \/\/\/< abstract unit of length$/;"	t	namespace:boost::units::abstract
boost::units::abstract::length_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct length_unit_tag : base_unit<length_unit_tag, length_dimension, -30> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::luminous_intensity	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<luminous_intensity_dimension,system>    luminous_intensity;     \/\/\/< abstract unit of luminous intensity$/;"	t	namespace:boost::units::abstract
boost::units::abstract::luminous_intensity_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct luminous_intensity_unit_tag : base_unit<luminous_intensity_unit_tag, luminous_intensity_dimension, -24> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::mass	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<mass_dimension,system>                  mass;                   \/\/\/< abstract unit of mass$/;"	t	namespace:boost::units::abstract
boost::units::abstract::mass_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct mass_unit_tag : base_unit<mass_unit_tag, mass_dimension, -29> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::plane_angle	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<plane_angle_dimension,system>           plane_angle;            \/\/\/< abstract unit of plane angle$/;"	t	namespace:boost::units::abstract
boost::units::abstract::plane_angle_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct plane_angle_unit_tag : base_unit<plane_angle_unit_tag, plane_angle_dimension, -23> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::solid_angle	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<solid_angle_dimension,system>           solid_angle;            \/\/\/< abstract unit of solid angle$/;"	t	namespace:boost::units::abstract
boost::units::abstract::solid_angle_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct solid_angle_unit_tag : base_unit<solid_angle_unit_tag, solid_angle_dimension, -22> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::system	/usr/include/boost/units/systems/abstract.hpp	/^>::type system;$/;"	t	namespace:boost::units::abstract
boost::units::abstract::temperature	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<temperature_dimension,system>           temperature;            \/\/\/< abstract unit of temperature$/;"	t	namespace:boost::units::abstract
boost::units::abstract::temperature_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct temperature_unit_tag : base_unit<temperature_unit_tag, temperature_dimension, -26> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::abstract::time	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<time_dimension,system>                  time;                   \/\/\/< abstract unit of time$/;"	t	namespace:boost::units::abstract
boost::units::abstract::time_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct time_unit_tag : base_unit<time_unit_tag, time_dimension, -28> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::amount_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::current_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::length_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::luminous_intensity_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::mass_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::plane_angle_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::solid_angle_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::temperature_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info	/usr/include/boost/units/systems/abstract.hpp	/^struct base_unit_info<abstract::time_unit_tag> $/;"	s	namespace:boost::units
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Amount]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Electric Current]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Length]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Luminous Intensity]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Mass]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Plane Angle]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Solid Angle]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Temperature]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Time]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[I]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[J]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[L]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[M]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[N]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[QP]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[QS]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[Theta]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::base_unit_info::symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[T]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
boost::units::celsius	/usr/include/boost/units/systems/temperature/celsius.hpp	/^namespace celsius {$/;"	n	namespace:boost::units
boost::units::celsius::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/celsius.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degree,temperature);$/;"	p	namespace:boost::units::celsius	signature:(degree,temperature)
boost::units::celsius::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/celsius.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degrees,temperature);$/;"	p	namespace:boost::units::celsius	signature:(degrees,temperature)
boost::units::celsius::system	/usr/include/boost/units/systems/temperature/celsius.hpp	/^typedef make_system<boost::units::temperature::celsius_base_unit>::type system;$/;"	t	namespace:boost::units::celsius
boost::units::celsius::temperature	/usr/include/boost/units/systems/temperature/celsius.hpp	/^typedef unit<temperature_dimension,system>   temperature;$/;"	t	namespace:boost::units::celsius
boost::units::cgs	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/area.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/base.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/current.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/dimensionless.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/energy.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/force.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/frequency.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/length.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/mass.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/mass_density.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/momentum.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/power.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/pressure.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/time.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/velocity.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/volume.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
boost::units::cgs::acceleration	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^typedef unit<acceleration_dimension,cgs::system>     acceleration;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::area	/usr/include/boost/units/systems/cgs/area.hpp	/^typedef unit<area_dimension,cgs::system>     area;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gal,acceleration);  $/;"	p	namespace:boost::units::cgs	signature:(gal,acceleration)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gals,acceleration); $/;"	p	namespace:boost::units::cgs	signature:(gals,acceleration)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimeter,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimeter,area)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimeters,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimeters,area)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimetre,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimetre,area)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimetres,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimetres,area)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(biot,current);$/;"	p	namespace:boost::units::cgs	signature:(biot,current)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(biots,current);$/;"	p	namespace:boost::units::cgs	signature:(biots,current)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/dimensionless.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cgs_dimensionless,dimensionless);$/;"	p	namespace:boost::units::cgs	signature:(cgs_dimensionless,dimensionless)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(poise,dynamic_viscosity);    $/;"	p	namespace:boost::units::cgs	signature:(poise,dynamic_viscosity)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(erg,energy);$/;"	p	namespace:boost::units::cgs	signature:(erg,energy)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ergs,energy);$/;"	p	namespace:boost::units::cgs	signature:(ergs,energy)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(dyne,force);$/;"	p	namespace:boost::units::cgs	signature:(dyne,force)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(dynes,force);$/;"	p	namespace:boost::units::cgs	signature:(dynes,force)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(stoke,kinematic_viscosity);           $/;"	p	namespace:boost::units::cgs	signature:(stoke,kinematic_viscosity)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(stokes,kinematic_viscosity);    $/;"	p	namespace:boost::units::cgs	signature:(stokes,kinematic_viscosity)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeter,length); $/;"	p	namespace:boost::units::cgs	signature:(centimeter,length)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeters,length);    $/;"	p	namespace:boost::units::cgs	signature:(centimeters,length)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetre,length); $/;"	p	namespace:boost::units::cgs	signature:(centimetre,length)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetres,length);    $/;"	p	namespace:boost::units::cgs	signature:(centimetres,length)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gram,mass); $/;"	p	namespace:boost::units::cgs	signature:(gram,mass)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gramme,mass);   $/;"	p	namespace:boost::units::cgs	signature:(gramme,mass)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(grammes,mass);  $/;"	p	namespace:boost::units::cgs	signature:(grammes,mass)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(grams,mass);    $/;"	p	namespace:boost::units::cgs	signature:(grams,mass)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(barye,pressure);    $/;"	p	namespace:boost::units::cgs	signature:(barye,pressure)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(baryes,pressure);   $/;"	p	namespace:boost::units::cgs	signature:(baryes,pressure)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(second,time);   $/;"	p	namespace:boost::units::cgs	signature:(second,time)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(seconds,time);  $/;"	p	namespace:boost::units::cgs	signature:(seconds,time)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeters_per_second,velocity);   $/;"	p	namespace:boost::units::cgs	signature:(centimeters_per_second,velocity)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeter_per_second,velocity);    $/;"	p	namespace:boost::units::cgs	signature:(centimeter_per_second,velocity)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetres_per_second,velocity);   $/;"	p	namespace:boost::units::cgs	signature:(centimetres_per_second,velocity)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetre_per_second,velocity);    $/;"	p	namespace:boost::units::cgs	signature:(centimetre_per_second,velocity)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimeter,volume);   $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimeter,volume)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimeters,volume);  $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimeters,volume)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimetre,volume);   $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimetre,volume)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimetres,volume);  $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimetres,volume)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kayser,wavenumber); $/;"	p	namespace:boost::units::cgs	signature:(kayser,wavenumber)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kaysers,wavenumber);    $/;"	p	namespace:boost::units::cgs	signature:(kaysers,wavenumber)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimeter,wavenumber);  $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimeter,wavenumber)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimeters,wavenumber); $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimeters,wavenumber)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimetre,wavenumber);  $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimetre,wavenumber)
boost::units::cgs::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimetres,wavenumber); $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimetres,wavenumber)
boost::units::cgs::current	/usr/include/boost/units/systems/cgs/current.hpp	/^typedef unit<current_dimension,cgs::system>   current;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::dimensionless	/usr/include/boost/units/systems/cgs/base.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::dynamic_viscosity	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^typedef unit<dynamic_viscosity_dimension,cgs::system>     dynamic_viscosity;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::energy	/usr/include/boost/units/systems/cgs/energy.hpp	/^typedef unit<energy_dimension,cgs::system>   energy;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::force	/usr/include/boost/units/systems/cgs/force.hpp	/^typedef unit<force_dimension,cgs::system>        force;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::frequency	/usr/include/boost/units/systems/cgs/frequency.hpp	/^typedef unit<frequency_dimension,cgs::system>        frequency;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::kinematic_viscosity	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^typedef unit<kinematic_viscosity_dimension,cgs::system>     kinematic_viscosity;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::length	/usr/include/boost/units/systems/cgs/length.hpp	/^typedef unit<length_dimension,cgs::system>   length;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::mass	/usr/include/boost/units/systems/cgs/mass.hpp	/^typedef unit<mass_dimension,cgs::system>     mass;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::mass_density	/usr/include/boost/units/systems/cgs/mass_density.hpp	/^typedef unit<mass_density_dimension,cgs::system>     mass_density;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::momentum	/usr/include/boost/units/systems/cgs/momentum.hpp	/^typedef unit<momentum_dimension,cgs::system>     momentum;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::power	/usr/include/boost/units/systems/cgs/power.hpp	/^typedef unit<power_dimension,cgs::system>    power;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::pressure	/usr/include/boost/units/systems/cgs/pressure.hpp	/^typedef unit<pressure_dimension,cgs::system>     pressure;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::system	/usr/include/boost/units/systems/cgs/base.hpp	/^                    biot_base_unit>::type system;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::time	/usr/include/boost/units/systems/cgs/time.hpp	/^typedef unit<time_dimension,cgs::system>     time;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::velocity	/usr/include/boost/units/systems/cgs/velocity.hpp	/^typedef unit<velocity_dimension,cgs::system>     velocity;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::volume	/usr/include/boost/units/systems/cgs/volume.hpp	/^typedef unit<volume_dimension,cgs::system>   volume;$/;"	t	namespace:boost::units::cgs
boost::units::cgs::wavenumber	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^typedef unit<wavenumber_dimension,cgs::system>   wavenumber;$/;"	t	namespace:boost::units::cgs
boost::units::constant	/usr/include/boost/units/systems/detail/constants.hpp	/^struct constant $/;"	s	namespace:boost::units
boost::units::constant::lower_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type lower_bound() const { return Base().lower_bound(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
boost::units::constant::operator value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    operator value_type() const    { return Base().value(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
boost::units::constant::uncertainty	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type uncertainty() const { return Base().uncertainty(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
boost::units::constant::upper_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type upper_bound() const { return Base().upper_bound(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
boost::units::constant::value	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type value() const       { return Base().value(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
boost::units::constant::value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef typename Base::value_type value_type; $/;"	t	struct:boost::units::constant	access:public
boost::units::degree	/usr/include/boost/units/systems/angle/degrees.hpp	/^namespace degree {$/;"	n	namespace:boost::units
boost::units::degree::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/degrees.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degree,plane_angle);$/;"	p	namespace:boost::units::degree	signature:(degree,plane_angle)
boost::units::degree::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/degrees.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degrees,plane_angle);$/;"	p	namespace:boost::units::degree	signature:(degrees,plane_angle)
boost::units::degree::dimensionless	/usr/include/boost/units/systems/angle/degrees.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::degree
boost::units::degree::plane_angle	/usr/include/boost/units/systems/angle/degrees.hpp	/^typedef unit<plane_angle_dimension,system>      plane_angle;           \/\/\/< angle degree unit constant$/;"	t	namespace:boost::units::degree
boost::units::degree::system	/usr/include/boost/units/systems/angle/degrees.hpp	/^typedef make_system<boost::units::angle::degree_base_unit>::type system;$/;"	t	namespace:boost::units::degree
boost::units::detail	/usr/include/boost/units/heterogeneous_system.hpp	/^namespace detail {$/;"	n	namespace:boost::units
boost::units::detail	/usr/include/boost/units/homogeneous_system.hpp	/^namespace detail {$/;"	n	namespace:boost::units
boost::units::detail	/usr/include/boost/units/make_system.hpp	/^namespace detail {$/;"	n	namespace:boost::units
boost::units::detail::check_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct check_system : mpl::false_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::false_
boost::units::detail::check_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct check_system<heterogeneous_system<heterogeneous_system_impl<System, Dimension, Scale> >, Dimension> : mpl::true_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::true_
boost::units::detail::check_system	/usr/include/boost/units/homogeneous_system.hpp	/^struct check_system<homogeneous_system<L>, Dimensions> : mpl::true_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::true_
boost::units::detail::check_system	/usr/include/boost/units/homogeneous_system.hpp	/^struct check_system<homogeneous_system<L>, Dimensions> :$/;"	s	namespace:boost::units::detail	inherits:boost::mpl::not_
boost::units::detail::divide_systems	/usr/include/boost/units/heterogeneous_system.hpp	/^struct divide_systems$/;"	s	namespace:boost::units::detail
boost::units::detail::divide_systems::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::detail::divide_systems	access:public
boost::units::detail::get_scale_list_of_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list_of_heterogeneous_system_impl$/;"	s	namespace:boost::units::detail
boost::units::detail::get_scale_list_of_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list_of_heterogeneous_system_impl<0>$/;"	s	namespace:boost::units::detail
boost::units::detail::get_scale_list_of_heterogeneous_system_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::units::detail::get_scale_list_of_heterogeneous_system_impl	access:public
boost::units::detail::get_scale_list_of_heterogeneous_system_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        >::type type;$/;"	t	struct:boost::units::detail::get_scale_list_of_heterogeneous_system_impl::apply	access:public
boost::units::detail::get_scale_list_of_heterogeneous_system_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef dimensionless_type type;$/;"	t	struct:boost::units::detail::get_scale_list_of_heterogeneous_system_impl::apply	access:public
boost::units::detail::is_empty_dim	/usr/include/boost/units/heterogeneous_system.hpp	/^struct is_empty_dim<heterogeneous_system_dim<Unit1,Exponent1> > : detail::is_zero<Exponent1> {};$/;"	s	namespace:boost::units::detail	inherits:detail::is_zero
boost::units::detail::is_zero	/usr/include/boost/units/heterogeneous_system.hpp	/^struct is_zero : mpl::false_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::false_
boost::units::detail::is_zero	/usr/include/boost/units/heterogeneous_system.hpp	/^struct is_zero<static_rational<0> > : mpl::true_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::true_
boost::units::detail::make_heterogeneous_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system$/;"	s	namespace:boost::units::detail
boost::units::detail::make_heterogeneous_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system<Dimensions, heterogeneous_system<T> >$/;"	s	namespace:boost::units::detail
boost::units::detail::make_heterogeneous_system::BOOST_MPL_ASSERT_MSG	/usr/include/boost/units/heterogeneous_system.hpp	/^    BOOST_MPL_ASSERT_MSG((!boost::is_same<exponents, inconsistent>::value), the_specified_dimension_is_not_representible_in_the_given_system, (types<Dimensions, System>));$/;"	p	struct:boost::units::detail::make_heterogeneous_system	access:public	signature:(!boost::is_same<exponents, inconsistent>::value), the_specified_dimension_is_not_representible_in_the_given_system, (types<Dimensions, System>)
boost::units::detail::make_heterogeneous_system::exponents	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef typename calculate_base_unit_exponents<typename System::type, Dimensions>::type exponents;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
boost::units::detail::make_heterogeneous_system::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system<heterogeneous_system_impl<unit_list, Dimensions, no_scale> > type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
boost::units::detail::make_heterogeneous_system::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system<T> type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
boost::units::detail::make_heterogeneous_system::unit_list	/usr/include/boost/units/heterogeneous_system.hpp	/^    >::type unit_list;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
boost::units::detail::make_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system_impl$/;"	s	namespace:boost::units::detail
boost::units::detail::make_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system_impl<0>$/;"	s	namespace:boost::units::detail
boost::units::detail::make_heterogeneous_system_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::units::detail::make_heterogeneous_system_impl	access:public
boost::units::detail::make_heterogeneous_system_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        >::type type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system_impl::apply	access:public
boost::units::detail::make_heterogeneous_system_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef dimensionless_type type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system_impl::apply	access:public
boost::units::detail::multiply_systems	/usr/include/boost/units/heterogeneous_system.hpp	/^struct multiply_systems$/;"	s	namespace:boost::units::detail
boost::units::detail::multiply_systems::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::detail::multiply_systems	access:public
boost::units::detail::unscale_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale_heterogeneous_system_impl$/;"	s	namespace:boost::units::detail
boost::units::detail::unscale_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale_heterogeneous_system_impl<0>$/;"	s	namespace:boost::units::detail
boost::units::detail::unscale_heterogeneous_system_impl::apply	/usr/include/boost/units/heterogeneous_system.hpp	/^    struct apply$/;"	s	struct:boost::units::detail::unscale_heterogeneous_system_impl	access:public
boost::units::detail::unscale_heterogeneous_system_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        >::type type;$/;"	t	struct:boost::units::detail::unscale_heterogeneous_system_impl::apply	access:public
boost::units::detail::unscale_heterogeneous_system_impl::apply::type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef dimensionless_type type;$/;"	t	struct:boost::units::detail::unscale_heterogeneous_system_impl::apply	access:public
boost::units::detail::unspecified	/usr/include/boost/units/make_system.hpp	/^struct unspecified {};$/;"	s	namespace:boost::units::detail
boost::units::fahrenheit	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^namespace fahrenheit {$/;"	n	namespace:boost::units
boost::units::fahrenheit::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degree,temperature);$/;"	p	namespace:boost::units::fahrenheit	signature:(degree,temperature)
boost::units::fahrenheit::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degrees,temperature);$/;"	p	namespace:boost::units::fahrenheit	signature:(degrees,temperature)
boost::units::fahrenheit::system	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^typedef make_system<boost::units::temperature::fahrenheit_base_unit>::type system;$/;"	t	namespace:boost::units::fahrenheit
boost::units::fahrenheit::temperature	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^typedef unit<temperature_dimension,system>   temperature;$/;"	t	namespace:boost::units::fahrenheit
boost::units::get_scale_list	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list<heterogeneous_system<T> >$/;"	s	namespace:boost::units
boost::units::get_scale_list	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list<heterogeneous_system_dim<Unit, Exponent> >$/;"	s	namespace:boost::units
boost::units::get_scale_list::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    >::type type;$/;"	t	struct:boost::units::get_scale_list	access:public
boost::units::get_scale_list::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef typename static_power<typename get_scale_list<Unit>::type, Exponent>::type type;$/;"	t	struct:boost::units::get_scale_list	access:public
boost::units::get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system {};$/;"	s	namespace:boost::units
boost::units::get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system< absolute<Unit> >$/;"	s	namespace:boost::units
boost::units::get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system< quantity<Unit,Y> >$/;"	s	namespace:boost::units
boost::units::get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system< unit<Dim,System> >$/;"	s	namespace:boost::units
boost::units::get_system::type	/usr/include/boost/units/get_system.hpp	/^    typedef System type;$/;"	t	struct:boost::units::get_system	access:public
boost::units::get_system::type	/usr/include/boost/units/get_system.hpp	/^    typedef typename get_system<Unit>::type     type;$/;"	t	struct:boost::units::get_system	access:public
boost::units::get_system::type	/usr/include/boost/units/get_system.hpp	/^    typedef typename get_system<Unit>::type type;$/;"	t	struct:boost::units::get_system	access:public
boost::units::gradian	/usr/include/boost/units/systems/angle/gradians.hpp	/^namespace gradian {$/;"	n	namespace:boost::units
boost::units::gradian::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/gradians.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gradian,plane_angle);$/;"	p	namespace:boost::units::gradian	signature:(gradian,plane_angle)
boost::units::gradian::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/gradians.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gradians,plane_angle);$/;"	p	namespace:boost::units::gradian	signature:(gradians,plane_angle)
boost::units::gradian::dimensionless	/usr/include/boost/units/systems/angle/gradians.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::gradian
boost::units::gradian::plane_angle	/usr/include/boost/units/systems/angle/gradians.hpp	/^typedef unit<plane_angle_dimension,system>      plane_angle;          \/\/\/< angle gradian unit constant$/;"	t	namespace:boost::units::gradian
boost::units::gradian::system	/usr/include/boost/units/systems/angle/gradians.hpp	/^typedef make_system<boost::units::angle::gradian_base_unit>::type system;$/;"	t	namespace:boost::units::gradian
boost::units::heterogeneous_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system : T {};$/;"	s	namespace:boost::units	inherits:T
boost::units::heterogeneous_system_dim	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system_dim$/;"	s	namespace:boost::units
boost::units::heterogeneous_system_dim::tag	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system_dim_tag tag;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
boost::units::heterogeneous_system_dim::tag_type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Unit tag_type;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
boost::units::heterogeneous_system_dim::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system_dim type;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
boost::units::heterogeneous_system_dim::value_type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Exponent value_type;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
boost::units::heterogeneous_system_dim_tag	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system_dim_tag {};$/;"	s	namespace:boost::units
boost::units::heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system_impl$/;"	s	namespace:boost::units
boost::units::heterogeneous_system_impl::dimensions	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Dimensions dimensions;$/;"	t	struct:boost::units::heterogeneous_system_impl	access:public
boost::units::heterogeneous_system_impl::scale	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Scale scale;$/;"	t	struct:boost::units::heterogeneous_system_impl	access:public
boost::units::heterogeneous_system_impl::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef L type;$/;"	t	struct:boost::units::heterogeneous_system_impl	access:public
boost::units::homogeneous_system	/usr/include/boost/units/homogeneous_system.hpp	/^struct homogeneous_system {$/;"	s	namespace:boost::units
boost::units::homogeneous_system::type	/usr/include/boost/units/homogeneous_system.hpp	/^    typedef L type;$/;"	t	struct:boost::units::homogeneous_system	access:public
boost::units::is_quantity_of_system	/usr/include/boost/units/is_quantity_of_system.hpp	/^struct is_quantity_of_system :$/;"	s	namespace:boost::units	inherits:mpl::false_
boost::units::is_quantity_of_system	/usr/include/boost/units/is_quantity_of_system.hpp	/^struct is_quantity_of_system< quantity< Unit,Y>,System > :$/;"	s	namespace:boost::units	inherits:is_unit_of_system
boost::units::is_unit_of_system	/usr/include/boost/units/is_unit_of_system.hpp	/^struct is_unit_of_system :$/;"	s	namespace:boost::units	inherits:mpl::false_
boost::units::is_unit_of_system	/usr/include/boost/units/is_unit_of_system.hpp	/^struct is_unit_of_system< absolute<unit<Dim,System> >,System > :$/;"	s	namespace:boost::units	inherits:mpl::true_
boost::units::is_unit_of_system	/usr/include/boost/units/is_unit_of_system.hpp	/^struct is_unit_of_system< unit<Dim,System>,System > :$/;"	s	namespace:boost::units	inherits:mpl::true_
boost::units::make_system	/usr/include/boost/units/make_system.hpp	/^struct make_system$/;"	s	namespace:boost::units
boost::units::make_system::type	/usr/include/boost/units/make_system.hpp	/^    typedef homogeneous_system<detail::unspecified> type;$/;"	t	struct:boost::units::make_system	access:public
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::acceleration>::type&) { return "galileo"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::acceleration>::type&)
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::current>::type&)   { return "biot"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::current>::type&)
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::dynamic_viscosity>::type&) { return "poise"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::dynamic_viscosity>::type&)
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::energy>::type&) { return "erg"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::energy>::type&)
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::force>::type&) { return "dyne"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::force>::type&)
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::kinematic_viscosity>::type&) { return "stoke"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::kinematic_viscosity>::type&)
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::pressure>::type&) { return "barye"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::pressure>::type&)
boost::units::name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::wavenumber>::type&) { return "kayser"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::wavenumber>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::absorbed_dose>::type&) { return "gray"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::absorbed_dose>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::capacitance>::type&)   { return "farad"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::capacitance>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::catalytic_activity>::type&) { return "katal"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::catalytic_activity>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::conductance>::type&) { return "siemen"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::conductance>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::electric_charge>::type&) { return "coulomb"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_charge>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::electric_potential>::type&) { return "volt"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_potential>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::energy>::type&) { return "joule"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::energy>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::force>::type&) { return "newton"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::force>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::frequency>::type&) { return "hertz"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::frequency>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::illuminance>::type&) { return "lux"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::illuminance>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::inductance>::type&) { return "henry"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::inductance>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::luminous_flux>::type&) { return "lumen"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::luminous_flux>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::magnetic_flux>::type&) { return "weber"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::magnetic_flux_density>::type&) { return "tesla"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux_density>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::power>::type&) { return "watt"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::power>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::pressure>::type&) { return "pascal"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::pressure>::type&)
boost::units::name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::resistance>::type&) { return "ohm"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::resistance>::type&)
boost::units::no_scale	/usr/include/boost/units/heterogeneous_system.hpp	/^typedef dimensionless_type no_scale;$/;"	t	namespace:boost::units
boost::units::operator <<	/usr/include/boost/units/systems/detail/constants.hpp	/^std::basic_ostream<Char,Traits>& operator<<(std::basic_ostream<Char,Traits>& os,const constant<Y>&)$/;"	f	namespace:boost::units	signature:(std::basic_ostream<Char,Traits>& os,const constant<Y>&)
boost::units::operator <<	/usr/include/boost/units/systems/detail/constants.hpp	/^std::basic_ostream<Char,Traits>& operator<<(std::basic_ostream<Char,Traits>& os,const physical_constant<Y>& val)$/;"	f	namespace:boost::units	signature:(std::basic_ostream<Char,Traits>& os,const physical_constant<Y>& val)
boost::units::physical_constant	/usr/include/boost/units/systems/detail/constants.hpp	/^struct physical_constant $/;"	s	namespace:boost::units
boost::units::physical_constant::lower_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type lower_bound() const { return Base().lower_bound(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
boost::units::physical_constant::operator value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    operator value_type() const    { return Base().value(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
boost::units::physical_constant::uncertainty	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type uncertainty() const { return Base().uncertainty(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
boost::units::physical_constant::upper_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type upper_bound() const { return Base().upper_bound(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
boost::units::physical_constant::value	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type value() const       { return Base().value(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
boost::units::physical_constant::value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef typename Base::value_type value_type; $/;"	t	struct:boost::units::physical_constant	access:public
boost::units::power_typeof_helper	/usr/include/boost/units/systems/detail/constants.hpp	/^struct power_typeof_helper<constant<T1>, static_rational<N,D> >$/;"	s	namespace:boost::units
boost::units::power_typeof_helper::base	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef power_typeof_helper<typename T1::value_type, static_rational<N,D> > base;$/;"	t	struct:boost::units::power_typeof_helper	access:public
boost::units::power_typeof_helper::type	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef typename base::type type;$/;"	t	struct:boost::units::power_typeof_helper	access:public
boost::units::power_typeof_helper::value	/usr/include/boost/units/systems/detail/constants.hpp	/^    static type value(const constant<T1>& arg)$/;"	f	struct:boost::units::power_typeof_helper	access:public	signature:(const constant<T1>& arg)
boost::units::revolution	/usr/include/boost/units/systems/angle/revolutions.hpp	/^namespace revolution {$/;"	n	namespace:boost::units
boost::units::revolution::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/revolutions.hpp	/^BOOST_UNITS_STATIC_CONSTANT(revolution,plane_angle);$/;"	p	namespace:boost::units::revolution	signature:(revolution,plane_angle)
boost::units::revolution::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/revolutions.hpp	/^BOOST_UNITS_STATIC_CONSTANT(revolutions,plane_angle);$/;"	p	namespace:boost::units::revolution	signature:(revolutions,plane_angle)
boost::units::revolution::dimensionless	/usr/include/boost/units/systems/angle/revolutions.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::revolution
boost::units::revolution::plane_angle	/usr/include/boost/units/systems/angle/revolutions.hpp	/^typedef unit<plane_angle_dimension,system>      plane_angle;          \/\/\/< angle revolution unit constant$/;"	t	namespace:boost::units::revolution
boost::units::revolution::system	/usr/include/boost/units/systems/angle/revolutions.hpp	/^typedef make_system<boost::units::angle::revolution_base_unit>::type system;$/;"	t	namespace:boost::units::revolution
boost::units::si	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/acceleration.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/action.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/activity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/amount.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/angular_acceleration.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/angular_momentum.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/area.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/base.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/capacitance.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/conductance.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/conductivity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/current.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/dimensionless.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/electric_charge.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/electric_potential.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/energy.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/force.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/frequency.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/illuminance.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/impedance.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/inductance.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/length.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/mass.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/mass_density.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/momentum.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/permeability.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/permittivity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/plane_angle.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/power.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/prefixes.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/pressure.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/reluctance.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/resistance.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/resistivity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/solid_angle.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/surface_density.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/surface_tension.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/temperature.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/time.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/torque.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/velocity.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/volume.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si	/usr/include/boost/units/systems/si/wavenumber.hpp	/^namespace si {$/;"	n	namespace:boost::units
boost::units::si::absorbed_dose	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^typedef unit<absorbed_dose_dimension,si::system>     absorbed_dose;$/;"	t	namespace:boost::units::si
boost::units::si::acceleration	/usr/include/boost/units/systems/si/acceleration.hpp	/^typedef unit<acceleration_dimension,si::system>  acceleration;$/;"	t	namespace:boost::units::si
boost::units::si::action	/usr/include/boost/units/systems/si/action.hpp	/^typedef unit<action_dimension,si::system>    action;$/;"	t	namespace:boost::units::si
boost::units::si::activity	/usr/include/boost/units/systems/si/activity.hpp	/^typedef unit<activity_dimension,si::system>  activity;$/;"	t	namespace:boost::units::si
boost::units::si::amount	/usr/include/boost/units/systems/si/amount.hpp	/^typedef unit<amount_dimension,si::system>    amount;$/;"	t	namespace:boost::units::si
boost::units::si::angular_acceleration	/usr/include/boost/units/systems/si/angular_acceleration.hpp	/^typedef unit<angular_acceleration_dimension,si::system>      angular_acceleration;$/;"	t	namespace:boost::units::si
boost::units::si::angular_momentum	/usr/include/boost/units/systems/si/angular_momentum.hpp	/^typedef unit<angular_momentum_dimension,si::system>      angular_momentum;$/;"	t	namespace:boost::units::si
boost::units::si::angular_velocity	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^typedef unit<angular_velocity_dimension,si::system>      angular_velocity;$/;"	t	namespace:boost::units::si
boost::units::si::area	/usr/include/boost/units/systems/si/area.hpp	/^typedef unit<area_dimension,si::system>      area;$/;"	t	namespace:boost::units::si
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gray,absorbed_dose);  $/;"	p	namespace:boost::units::si	signature:(gray,absorbed_dose)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^BOOST_UNITS_STATIC_CONSTANT(grays,absorbed_dose); $/;"	p	namespace:boost::units::si	signature:(grays,absorbed_dose)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meters_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(meters_per_second_squared,acceleration)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meter_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(meter_per_second_squared,acceleration)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metres_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(metres_per_second_squared,acceleration)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metre_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(metre_per_second_squared,acceleration)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(becquerel,activity);$/;"	p	namespace:boost::units::si	signature:(becquerel,activity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(becquerels,activity);$/;"	p	namespace:boost::units::si	signature:(becquerels,activity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/amount.hpp	/^BOOST_UNITS_STATIC_CONSTANT(mole,amount);$/;"	p	namespace:boost::units::si	signature:(mole,amount)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/amount.hpp	/^BOOST_UNITS_STATIC_CONSTANT(moles,amount);$/;"	p	namespace:boost::units::si	signature:(moles,amount)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radians_per_second,angular_velocity);    $/;"	p	namespace:boost::units::si	signature:(radians_per_second,angular_velocity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radian_per_second,angular_velocity); $/;"	p	namespace:boost::units::si	signature:(radian_per_second,angular_velocity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_meter,area);$/;"	p	namespace:boost::units::si	signature:(square_meter,area)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_meters,area);$/;"	p	namespace:boost::units::si	signature:(square_meters,area)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_metre,area);$/;"	p	namespace:boost::units::si	signature:(square_metre,area)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_metres,area);$/;"	p	namespace:boost::units::si	signature:(square_metres,area)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/capacitance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(farad,capacitance);$/;"	p	namespace:boost::units::si	signature:(farad,capacitance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/capacitance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(farads,capacitance);$/;"	p	namespace:boost::units::si	signature:(farads,capacitance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(katal,catalytic_activity);$/;"	p	namespace:boost::units::si	signature:(katal,catalytic_activity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(katals,catalytic_activity);$/;"	p	namespace:boost::units::si	signature:(katals,catalytic_activity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(mho,conductance);   $/;"	p	namespace:boost::units::si	signature:(mho,conductance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(mhos,conductance);  $/;"	p	namespace:boost::units::si	signature:(mhos,conductance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(siemen,conductance);    $/;"	p	namespace:boost::units::si	signature:(siemen,conductance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(siemens,conductance);   $/;"	p	namespace:boost::units::si	signature:(siemens,conductance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ampere,current);$/;"	p	namespace:boost::units::si	signature:(ampere,current)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(amperes,current);$/;"	p	namespace:boost::units::si	signature:(amperes,current)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/dimensionless.hpp	/^BOOST_UNITS_STATIC_CONSTANT(si_dimensionless,dimensionless);$/;"	p	namespace:boost::units::si	signature:(si_dimensionless,dimensionless)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^BOOST_UNITS_STATIC_CONSTANT(sievert,dose_equivalent);  $/;"	p	namespace:boost::units::si	signature:(sievert,dose_equivalent)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^BOOST_UNITS_STATIC_CONSTANT(sieverts,dose_equivalent); $/;"	p	namespace:boost::units::si	signature:(sieverts,dose_equivalent)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_charge.hpp	/^BOOST_UNITS_STATIC_CONSTANT(coulomb,electric_charge);   $/;"	p	namespace:boost::units::si	signature:(coulomb,electric_charge)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_charge.hpp	/^BOOST_UNITS_STATIC_CONSTANT(coulombs,electric_charge);  $/;"	p	namespace:boost::units::si	signature:(coulombs,electric_charge)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_potential.hpp	/^BOOST_UNITS_STATIC_CONSTANT(volt,electric_potential);   $/;"	p	namespace:boost::units::si	signature:(volt,electric_potential)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_potential.hpp	/^BOOST_UNITS_STATIC_CONSTANT(volts,electric_potential);  $/;"	p	namespace:boost::units::si	signature:(volts,electric_potential)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(joule,energy);  $/;"	p	namespace:boost::units::si	signature:(joule,energy)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(joules,energy); $/;"	p	namespace:boost::units::si	signature:(joules,energy)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton,force);  $/;"	p	namespace:boost::units::si	signature:(newton,force)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newtons,force); $/;"	p	namespace:boost::units::si	signature:(newtons,force)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/frequency.hpp	/^BOOST_UNITS_STATIC_CONSTANT(hertz,frequency);   $/;"	p	namespace:boost::units::si	signature:(hertz,frequency)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/illuminance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(lux,illuminance); $/;"	p	namespace:boost::units::si	signature:(lux,illuminance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/inductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(henry,inductance);  $/;"	p	namespace:boost::units::si	signature:(henry,inductance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/inductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(henrys,inductance); $/;"	p	namespace:boost::units::si	signature:(henrys,inductance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meter,length);  $/;"	p	namespace:boost::units::si	signature:(meter,length)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meters,length); $/;"	p	namespace:boost::units::si	signature:(meters,length)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metre,length);  $/;"	p	namespace:boost::units::si	signature:(metre,length)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metres,length); $/;"	p	namespace:boost::units::si	signature:(metres,length)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(lumen,luminous_flux); $/;"	p	namespace:boost::units::si	signature:(lumen,luminous_flux)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(lumens,luminous_flux);    $/;"	p	namespace:boost::units::si	signature:(lumens,luminous_flux)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(candela,luminous_intensity); $/;"	p	namespace:boost::units::si	signature:(candela,luminous_intensity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(candelas,luminous_intensity);    $/;"	p	namespace:boost::units::si	signature:(candelas,luminous_intensity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(weber,magnetic_flux);   $/;"	p	namespace:boost::units::si	signature:(weber,magnetic_flux)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(webers,magnetic_flux);  $/;"	p	namespace:boost::units::si	signature:(webers,magnetic_flux)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(tesla,magnetic_flux_density);   $/;"	p	namespace:boost::units::si	signature:(tesla,magnetic_flux_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(teslas,magnetic_flux_density);  $/;"	p	namespace:boost::units::si	signature:(teslas,magnetic_flux_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogram,mass); $/;"	p	namespace:boost::units::si	signature:(kilogram,mass)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogramme,mass);   $/;"	p	namespace:boost::units::si	signature:(kilogramme,mass)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogrammes,mass);  $/;"	p	namespace:boost::units::si	signature:(kilogrammes,mass)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilograms,mass);    $/;"	p	namespace:boost::units::si	signature:(kilograms,mass)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogrammes_per_cubic_metre,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilogrammes_per_cubic_metre,mass_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogramme_per_cubic_metre,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilogramme_per_cubic_metre,mass_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilograms_per_cubic_meter,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilograms_per_cubic_meter,mass_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogram_per_cubic_meter,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilogram_per_cubic_meter,mass_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/plane_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radian,plane_angle); $/;"	p	namespace:boost::units::si	signature:(radian,plane_angle)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/plane_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radians,plane_angle);    $/;"	p	namespace:boost::units::si	signature:(radians,plane_angle)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/power.hpp	/^BOOST_UNITS_STATIC_CONSTANT(watt,power);    $/;"	p	namespace:boost::units::si	signature:(watt,power)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/power.hpp	/^BOOST_UNITS_STATIC_CONSTANT(watts,power);   $/;"	p	namespace:boost::units::si	signature:(watts,power)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(pascal,pressure);   $/;"	p	namespace:boost::units::si	signature:(pascal,pressure)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(pascals,pressure);  $/;"	p	namespace:boost::units::si	signature:(pascals,pressure)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/resistance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ohm,resistance);    $/;"	p	namespace:boost::units::si	signature:(ohm,resistance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/resistance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ohms,resistance);   $/;"	p	namespace:boost::units::si	signature:(ohms,resistance)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/solid_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(steradian,solid_angle); $/;"	p	namespace:boost::units::si	signature:(steradian,solid_angle)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/solid_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(steradians,solid_angle);    $/;"	p	namespace:boost::units::si	signature:(steradians,solid_angle)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogrammes_per_square_metre,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilogrammes_per_square_metre,surface_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogramme_per_square_metre,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilogramme_per_square_metre,surface_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilograms_per_square_meter,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilograms_per_square_meter,surface_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogram_per_square_meter,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilogram_per_square_meter,surface_density)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_tension.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newtons_per_meter,surface_tension); $/;"	p	namespace:boost::units::si	signature:(newtons_per_meter,surface_tension)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_tension.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton_per_meter,surface_tension);  $/;"	p	namespace:boost::units::si	signature:(newton_per_meter,surface_tension)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/temperature.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kelvin,temperature);    $/;"	p	namespace:boost::units::si	signature:(kelvin,temperature)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/temperature.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kelvins,temperature);   $/;"	p	namespace:boost::units::si	signature:(kelvins,temperature)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(second,time);   $/;"	p	namespace:boost::units::si	signature:(second,time)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(seconds,time);  $/;"	p	namespace:boost::units::si	signature:(seconds,time)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/torque.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton_meter,torque);  $/;"	p	namespace:boost::units::si	signature:(newton_meter,torque)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/torque.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton_meters,torque); $/;"	p	namespace:boost::units::si	signature:(newton_meters,torque)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meters_per_second,velocity);    $/;"	p	namespace:boost::units::si	signature:(meters_per_second,velocity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meter_per_second,velocity); $/;"	p	namespace:boost::units::si	signature:(meter_per_second,velocity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metres_per_second,velocity);    $/;"	p	namespace:boost::units::si	signature:(metres_per_second,velocity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metre_per_second,velocity); $/;"	p	namespace:boost::units::si	signature:(metre_per_second,velocity)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_meter,volume);    $/;"	p	namespace:boost::units::si	signature:(cubic_meter,volume)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_meters,volume);   $/;"	p	namespace:boost::units::si	signature:(cubic_meters,volume)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_metre,volume);    $/;"	p	namespace:boost::units::si	signature:(cubic_metre,volume)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_metres,volume);   $/;"	p	namespace:boost::units::si	signature:(cubic_metres,volume)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_meter,wavenumber);   $/;"	p	namespace:boost::units::si	signature:(reciprocal_meter,wavenumber)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_meters,wavenumber);  $/;"	p	namespace:boost::units::si	signature:(reciprocal_meters,wavenumber)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_metre,wavenumber);   $/;"	p	namespace:boost::units::si	signature:(reciprocal_metre,wavenumber)
boost::units::si::BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_metres,wavenumber);  $/;"	p	namespace:boost::units::si	signature:(reciprocal_metres,wavenumber)
boost::units::si::capacitance	/usr/include/boost/units/systems/si/capacitance.hpp	/^typedef unit<capacitance_dimension,si::system>    capacitance;$/;"	t	namespace:boost::units::si
boost::units::si::catalytic_activity	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^typedef unit<si::catalytic_activity_dim,si::system>                                    catalytic_activity;$/;"	t	namespace:boost::units::si
boost::units::si::catalytic_activity_dim	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^typedef derived_dimension<time_base_dimension,-1,amount_base_dimension,1>::type                             catalytic_activity_dim;    $/;"	t	namespace:boost::units::si
boost::units::si::conductance	/usr/include/boost/units/systems/si/conductance.hpp	/^typedef unit<conductance_dimension,si::system>    conductance;$/;"	t	namespace:boost::units::si
boost::units::si::conductivity	/usr/include/boost/units/systems/si/conductivity.hpp	/^typedef unit<conductivity_dimension,si::system>    conductivity;$/;"	t	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_alpha,quantity<mass>,6.64465620e-27*kilograms,3.3e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_alpha,quantity<mass>,6.64465620e-27*kilograms,3.3e-34*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_alpha,quantity<mass_over_amount>,4.001506179127e-3*kilograms\/mole,6.2e-14*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_alpha,quantity<mass_over_amount>,4.001506179127e-3*kilograms/mole,6.2e-14*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_alpha_over_m_e,quantity<dimensionless>,7294.2995365*dimensionless(),3.1e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_alpha_over_m_e,quantity<dimensionless>,7294.2995365*dimensionless(),3.1e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_alpha_over_m_p,quantity<dimensionless>,3.97259968951*dimensionless(),4.1e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_alpha_over_m_p,quantity<dimensionless>,3.97259968951*dimensionless(),4.1e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(alpha,quantity<dimensionless>,7.2973525376e-3*dimensionless(),5.0e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(alpha,quantity<dimensionless>,7.2973525376e-3*dimensionless(),5.0e-12*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(a_0,quantity<length>,0.52917720859e-10*meters,3.6e-20*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(a_0,quantity<length>,0.52917720859e-10*meters,3.6e-20*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(E_h,quantity<energy>,4.35974394e-18*joules,2.2e-25*joules);$/;"	p	namespace:boost::units::si::constants::codata	signature:(E_h,quantity<energy>,4.35974394e-18*joules,2.2e-25*joules)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_infinity,quantity<wavenumber>,10973731.568527\/meter,7.3e-5\/meter);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_infinity,quantity<wavenumber>,10973731.568527/meter,7.3e-5/meter)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_d,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_d,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d,quantity<energy_over_magnetic_flux_density>,0.433073465e-26*joules\/tesla,1.1e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d,quantity<energy_over_magnetic_flux_density>,0.433073465e-26*joules/tesla,1.1e-34*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_B,quantity<dimensionless>,0.4669754556e-3*dimensionless(),3.9e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_B,quantity<dimensionless>,0.4669754556e-3*dimensionless(),3.9e-12*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_e,quantity<dimensionless>,-4.664345537e-4*dimensionless(),3.9e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_e,quantity<dimensionless>,-4.664345537e-4*dimensionless(),3.9e-12*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_n,quantity<dimensionless>,-0.44820652*dimensionless(),1.1e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_n,quantity<dimensionless>,-0.44820652*dimensionless(),1.1e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_N,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_N,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_p,quantity<dimensionless>,0.3070122070*dimensionless(),2.4e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_p,quantity<dimensionless>,0.3070122070*dimensionless(),2.4e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_d,quantity<mass>,3.34358320e-27*kilograms,1.7e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_d,quantity<mass>,3.34358320e-27*kilograms,1.7e-34*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_d,quantity<mass_over_amount>,2.013553212724e-3*kilograms\/mole,7.8e-14*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_d,quantity<mass_over_amount>,2.013553212724e-3*kilograms/mole,7.8e-14*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_d_over_m_e,quantity<dimensionless>,3670.4829654*dimensionless(),1.6e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_d_over_m_e,quantity<dimensionless>,3670.4829654*dimensionless(),1.6e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_d_over_m_p,quantity<dimensionless>,1.99900750108*dimensionless(),2.2e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_d_over_m_p,quantity<dimensionless>,1.99900750108*dimensionless(),2.2e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_d,quantity<length>,2.1402e-15*meters,2.8e-18*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_d,quantity<length>,2.1402e-15*meters,2.8e-18*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e,quantity<electric_charge>,1.602176487e-19*coulombs,4.0e-27*coulombs);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e,quantity<electric_charge>,1.602176487e-19*coulombs,4.0e-27*coulombs)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e_over_h,quantity<current_over_energy>,2.417989454e14*amperes\/joule,6.0e6*amperes\/joule);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e_over_h,quantity<current_over_energy>,2.417989454e14*amperes/joule,6.0e6*amperes/joule)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(G_0,quantity<conductance>,7.7480917004e-5*siemens,5.3e-14*siemens);$/;"	p	namespace:boost::units::si::constants::codata	signature:(G_0,quantity<conductance>,7.7480917004e-5*siemens,5.3e-14*siemens)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(K_J,quantity<frequency_over_electric_potential>,483597.891e9*hertz\/volt,1.2e7*hertz\/volt);$/;"	p	namespace:boost::units::si::constants::codata	signature:(K_J,quantity<frequency_over_electric_potential>,483597.891e9*hertz/volt,1.2e7*hertz/volt)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_B,quantity<energy_over_magnetic_flux_density>,927.400915e-26*joules\/tesla,2.3e-31*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_B,quantity<energy_over_magnetic_flux_density>,927.400915e-26*joules/tesla,2.3e-31*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_N,quantity<energy_over_magnetic_flux_density>,5.05078324e-27*joules\/tesla,1.3e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_N,quantity<energy_over_magnetic_flux_density>,5.05078324e-27*joules/tesla,1.3e-34*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(Phi_0,quantity<magnetic_flux>,2.067833667e-15*webers,5.2e-23*webers);$/;"	p	namespace:boost::units::si::constants::codata	signature:(Phi_0,quantity<magnetic_flux>,2.067833667e-15*webers,5.2e-23*webers)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_K,quantity<resistance>,25812.807557*ohms,1.77e-5*ohms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_K,quantity<resistance>,25812.807557*ohms,1.77e-5*ohms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(a_e,quantity<dimensionless>,1.15965218111e-3*dimensionless(),7.4e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(a_e,quantity<dimensionless>,1.15965218111e-3*dimensionless(),7.4e-13*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e_over_m_e,quantity<electric_charge_over_mass>,1.758820150e11*coulombs\/kilogram,4.4e3*coulombs\/kilogram);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e_over_m_e,quantity<electric_charge_over_mass>,1.758820150e11*coulombs/kilogram,4.4e3*coulombs/kilogram)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_e,quantity<frequency_over_magnetic_flux_density>,1.760859770e11\/second\/tesla,4.4e3\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_e,quantity<frequency_over_magnetic_flux_density>,1.760859770e11/second/tesla,4.4e3/second/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_e,quantity<dimensionless>,-2.0023193043622*dimensionless(),1.5e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_e,quantity<dimensionless>,-2.0023193043622*dimensionless(),1.5e-12*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C,quantity<length>,2.4263102175e-12*meters,3.3e-21*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C,quantity<length>,2.4263102175e-12*meters,3.3e-21*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e,quantity<energy_over_magnetic_flux_density>,-928.476377e-26*joules\/tesla,2.3e-31*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e,quantity<energy_over_magnetic_flux_density>,-928.476377e-26*joules/tesla,2.3e-31*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_B,quantity<dimensionless>,-1.00115965218111*dimensionless(),7.4e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_B,quantity<dimensionless>,-1.00115965218111*dimensionless(),7.4e-13*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_d,quantity<dimensionless>,-2143.923498*dimensionless(),1.8e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_d,quantity<dimensionless>,-2143.923498*dimensionless(),1.8e-5*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_h_prime,quantity<dimensionless>,864.058257*dimensionless(),1.0e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_h_prime,quantity<dimensionless>,864.058257*dimensionless(),1.0e-5*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_mu,quantity<dimensionless>,206.7669877*dimensionless(),5.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_mu,quantity<dimensionless>,206.7669877*dimensionless(),5.2e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_N,quantity<dimensionless>,-183.28197092*dimensionless(),8.0e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_N,quantity<dimensionless>,-183.28197092*dimensionless(),8.0e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_n,quantity<dimensionless>,960.92050*dimensionless(),2.3e-4*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_n,quantity<dimensionless>,960.92050*dimensionless(),2.3e-4*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_p,quantity<dimensionless>,-658.2106848*dimensionless(),5.4e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_p,quantity<dimensionless>,-658.2106848*dimensionless(),5.4e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_p_prime,quantity<dimensionless>,-658.2275971*dimensionless(),7.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_p_prime,quantity<dimensionless>,-658.2275971*dimensionless(),7.2e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e,quantity<mass>,9.10938215e-31*kilograms,4.5e-38*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e,quantity<mass>,9.10938215e-31*kilograms,4.5e-38*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_e,quantity<mass_over_amount>,5.4857990943e-7*kilograms\/mole,2.3e-16*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_e,quantity<mass_over_amount>,5.4857990943e-7*kilograms/mole,2.3e-16*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_alpha,quantity<dimensionless>,1.37093355570e-4*dimensionless(),5.8e-14*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_alpha,quantity<dimensionless>,1.37093355570e-4*dimensionless(),5.8e-14*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_d,quantity<dimensionless>,2.7244371093e-4*dimensionless(),1.2e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_d,quantity<dimensionless>,2.7244371093e-4*dimensionless(),1.2e-13*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_mu,quantity<dimensionless>,4.83633171e-3*dimensionless(),1.2e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_mu,quantity<dimensionless>,4.83633171e-3*dimensionless(),1.2e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_n,quantity<dimensionless>,5.4386734459e-4*dimensionless(),3.3e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_n,quantity<dimensionless>,5.4386734459e-4*dimensionless(),3.3e-13*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_p,quantity<dimensionless>,5.4461702177e-4*dimensionless(),2.4e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_p,quantity<dimensionless>,5.4461702177e-4*dimensionless(),2.4e-13*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_tau,quantity<dimensionless>,2.87564e-4*dimensionless(),4.7e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_tau,quantity<dimensionless>,2.87564e-4*dimensionless(),4.7e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(r_e,quantity<length>,2.8179402894e-15*meters,5.8e-24*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(r_e,quantity<length>,2.8179402894e-15*meters,5.8e-24*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(sigma_e,quantity<area>,0.6652458558e-28*square_meters,2.7e-37*square_meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(sigma_e,quantity<area>,0.6652458558e-28*square_meters,2.7e-37*square_meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_h_prime,quantity<frequency_over_magnetic_flux_density>,2.037894730e8\/second\/tesla,5.6e-0\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_h_prime,quantity<frequency_over_magnetic_flux_density>,2.037894730e8/second/tesla,5.6e-0/second/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime,quantity<energy_over_magnetic_flux_density>,-1.074552982e-26*joules\/tesla,3.0e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime,quantity<energy_over_magnetic_flux_density>,-1.074552982e-26*joules/tesla,3.0e-34*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_B,quantity<dimensionless>,-1.158671471e-3*dimensionless(),1.4e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_B,quantity<dimensionless>,-1.158671471e-3*dimensionless(),1.4e-11*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_N,quantity<dimensionless>,-2.127497718*dimensionless(),2.5e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_N,quantity<dimensionless>,-2.127497718*dimensionless(),2.5e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_p,quantity<dimensionless>,-0.761766558*dimensionless(),1.1e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_p,quantity<dimensionless>,-0.761766558*dimensionless(),1.1e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_p_prime,quantity<dimensionless>,-0.7617861313*dimensionless(),3.3e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_p_prime,quantity<dimensionless>,-0.7617861313*dimensionless(),3.3e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_h,quantity<mass>,5.00641192e-27*kilograms,2.5e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_h,quantity<mass>,5.00641192e-27*kilograms,2.5e-34*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_h,quantity<mass_over_amount>,3.0149322473e-3*kilograms\/mole,2.6e-12*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_h,quantity<mass_over_amount>,3.0149322473e-3*kilograms/mole,2.6e-12*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_h_over_m_e,quantity<dimensionless>,5495.8852765*dimensionless(),5.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_h_over_m_e,quantity<dimensionless>,5495.8852765*dimensionless(),5.2e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_h_over_m_p,quantity<dimensionless>,2.9931526713*dimensionless(),2.6e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_h_over_m_p,quantity<dimensionless>,2.9931526713*dimensionless(),2.6e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(a_mu,quantity<dimensionless>,1.16592069e-3*dimensionless(),6.0e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(a_mu,quantity<dimensionless>,1.16592069e-3*dimensionless(),6.0e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_mu,quantity<dimensionless>,-2.0023318414*dimensionless(),1.2e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_mu,quantity<dimensionless>,-2.0023318414*dimensionless(),1.2e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_mu,quantity<length>,11.73444104e-15*meters,3.0e-22*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_mu,quantity<length>,11.73444104e-15*meters,3.0e-22*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu,quantity<energy_over_magnetic_flux_density>,-4.49044786e-26*joules\/tesla,1.6e-33*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu,quantity<energy_over_magnetic_flux_density>,-4.49044786e-26*joules/tesla,1.6e-33*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu_over_mu_B,quantity<dimensionless>,-4.84197049e-3*dimensionless(),1.2e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu_over_mu_B,quantity<dimensionless>,-4.84197049e-3*dimensionless(),1.2e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu_over_mu_N,quantity<dimensionless>,-8.89059705*dimensionless(),2.3e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu_over_mu_N,quantity<dimensionless>,-8.89059705*dimensionless(),2.3e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu_over_mu_p,quantity<dimensionless>,-3.183345137*dimensionless(),8.5e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu_over_mu_p,quantity<dimensionless>,-3.183345137*dimensionless(),8.5e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu,quantity<mass>,1.88353130e-28*kilograms,1.1e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu,quantity<mass>,1.88353130e-28*kilograms,1.1e-35*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_mu,quantity<mass_over_amount>,0.1134289256e-3*kilograms\/mole,2.9e-12*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_mu,quantity<mass_over_amount>,0.1134289256e-3*kilograms/mole,2.9e-12*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_e,quantity<dimensionless>,206.7682823*dimensionless(),5.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_e,quantity<dimensionless>,206.7682823*dimensionless(),5.2e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_n,quantity<dimensionless>,0.1124545167*dimensionless(),2.9e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_n,quantity<dimensionless>,0.1124545167*dimensionless(),2.9e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_p,quantity<dimensionless>,0.1126095261*dimensionless(),2.9e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_p,quantity<dimensionless>,0.1126095261*dimensionless(),2.9e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_tau,quantity<dimensionless>,5.94592e-2*dimensionless(),9.7e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_tau,quantity<dimensionless>,5.94592e-2*dimensionless(),9.7e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_n,quantity<frequency_over_magnetic_flux_density>,1.83247185e8\/second\/tesla,4.3e1\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_n,quantity<frequency_over_magnetic_flux_density>,1.83247185e8/second/tesla,4.3e1/second/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_n,quantity<dimensionless>,-3.82608545*dimensionless(),9.0e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_n,quantity<dimensionless>,-3.82608545*dimensionless(),9.0e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_n,quantity<length>,1.3195908951e-15*meters,2.0e-24*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_n,quantity<length>,1.3195908951e-15*meters,2.0e-24*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n,quantity<energy_over_magnetic_flux_density>,-0.96623641e-26*joules\/tesla,2.3e-33*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n,quantity<energy_over_magnetic_flux_density>,-0.96623641e-26*joules/tesla,2.3e-33*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n_over_mu_e,quantity<dimensionless>,1.04066882e-3*dimensionless(),2.5e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n_over_mu_e,quantity<dimensionless>,1.04066882e-3*dimensionless(),2.5e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n_over_mu_p,quantity<dimensionless>,-0.68497934*dimensionless(),1.6e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n_over_mu_p,quantity<dimensionless>,-0.68497934*dimensionless(),1.6e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n_over_mu_p_prime,quantity<dimensionless>,-0.68499694*dimensionless(),1.6e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n_over_mu_p_prime,quantity<dimensionless>,-0.68499694*dimensionless(),1.6e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n,quantity<mass>,1.674927211e-27*kilograms,8.4e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n,quantity<mass>,1.674927211e-27*kilograms,8.4e-35*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_n,quantity<mass_over_amount>,1.00866491597e-3*kilograms\/mole,4.3e-13*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_n,quantity<mass_over_amount>,1.00866491597e-3*kilograms/mole,4.3e-13*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_e,quantity<dimensionless>,1838.6836605*dimensionless(),1.1e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_e,quantity<dimensionless>,1838.6836605*dimensionless(),1.1e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_mu,quantity<dimensionless>,8.89248409*dimensionless(),2.3e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_mu,quantity<dimensionless>,8.89248409*dimensionless(),2.3e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_p,quantity<dimensionless>,1.00137841918*dimensionless(),4.6e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_p,quantity<dimensionless>,1.00137841918*dimensionless(),4.6e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_tau,quantity<dimensionless>,0.528740*dimensionless(),8.6e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_tau,quantity<dimensionless>,0.528740*dimensionless(),8.6e-5*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(b,quantity<length_temperature>,2.8977685e-3*meter*kelvin,5.1e-9*meter*kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(b,quantity<length_temperature>,2.8977685e-3*meter*kelvin,5.1e-9*meter*kelvin)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(b_prime,quantity<frequency_over_temperature>,5.878933e10*hertz\/kelvin,1.0e15*hertz\/kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(b_prime,quantity<frequency_over_temperature>,5.878933e10*hertz/kelvin,1.0e15*hertz/kelvin)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c_1,quantity<power_area>,3.74177118e-16*watt*square_meters,1.9e-23*watt*square_meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c_1,quantity<power_area>,3.74177118e-16*watt*square_meters,1.9e-23*watt*square_meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c_1L,quantity<power_area_over_solid_angle>,1.191042759e-16*watt*square_meters\/steradian,5.9e-24*watt*square_meters\/steradian);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c_1L,quantity<power_area_over_solid_angle>,1.191042759e-16*watt*square_meters/steradian,5.9e-24*watt*square_meters/steradian)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c_2,quantity<length_temperature>,1.4387752e-2*meter*kelvin,2.5e-8*meter*kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c_2,quantity<length_temperature>,1.4387752e-2*meter*kelvin,2.5e-8*meter*kelvin)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(F,quantity<electric_charge_over_amount>,96485.3399*coulombs\/mole,2.4e-3*coulombs\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(F,quantity<electric_charge_over_amount>,96485.3399*coulombs/mole,2.4e-3*coulombs/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(k_B,quantity<energy_over_temperature>,1.3806504e-23*joules\/kelvin,2.4e-29*joules\/kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(k_B,quantity<energy_over_temperature>,1.3806504e-23*joules/kelvin,2.4e-29*joules/kelvin)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_u,quantity<mass>,1.660538782e-27*kilograms,8.3e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_u,quantity<mass>,1.660538782e-27*kilograms,8.3e-35*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(N_A,quantity<inverse_amount>,6.02214179e23\/mole,3.0e16\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(N_A,quantity<inverse_amount>,6.02214179e23/mole,3.0e16/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R,quantity<energy_over_temperature_amount>,8.314472*joules\/kelvin\/mole,1.5e-5*joules\/kelvin\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R,quantity<energy_over_temperature_amount>,8.314472*joules/kelvin/mole,1.5e-5*joules/kelvin/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(sigma_SB,quantity<power_over_area_temperature_4>,5.670400e-8*watts\/square_meter\/pow<4>(kelvin),4.0e-13*watts\/square_meter\/pow<4>(kelvin));$/;"	p	namespace:boost::units::si::constants::codata	signature:(sigma_SB,quantity<power_over_area_temperature_4>,5.670400e-8*watts/square_meter/pow<4>(kelvin),4.0e-13*watts/square_meter/pow<4>(kelvin))
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e_over_m_p,quantity<electric_charge_over_mass>,9.57883392e7*coulombs\/kilogram,2.4e0*coulombs\/kilogram);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e_over_m_p,quantity<electric_charge_over_mass>,9.57883392e7*coulombs/kilogram,2.4e0*coulombs/kilogram)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_p,quantity<frequency_over_magnetic_flux_density>,2.675222099e8\/second\/tesla,7.0e0\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_p,quantity<frequency_over_magnetic_flux_density>,2.675222099e8/second/tesla,7.0e0/second/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_p_prime,quantity<frequency_over_magnetic_flux_density>,2.675153362e8\/second\/tesla,7.3e0\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_p_prime,quantity<frequency_over_magnetic_flux_density>,2.675153362e8/second/tesla,7.3e0/second/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_p,quantity<dimensionless>,5.585694713*dimensionless(),4.6e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_p,quantity<dimensionless>,5.585694713*dimensionless(),4.6e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_p,quantity<length>,1.3214098446e-15*meters,1.9e-24*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_p,quantity<length>,1.3214098446e-15*meters,1.9e-24*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p,quantity<energy_over_magnetic_flux_density>,1.410606662e-26*joules\/tesla,3.7e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p,quantity<energy_over_magnetic_flux_density>,1.410606662e-26*joules/tesla,3.7e-34*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_over_mu_B,quantity<dimensionless>,1.521032209e-3*dimensionless(),1.2e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_over_mu_B,quantity<dimensionless>,1.521032209e-3*dimensionless(),1.2e-11*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_over_mu_n,quantity<dimensionless>,-1.45989806*dimensionless(),3.4e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_over_mu_n,quantity<dimensionless>,-1.45989806*dimensionless(),3.4e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_over_mu_N,quantity<dimensionless>,2.792847356*dimensionless(),2.3e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_over_mu_N,quantity<dimensionless>,2.792847356*dimensionless(),2.3e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_prime,quantity<energy_over_magnetic_flux_density>,1.410570419e-26*joules\/tesla,3.8e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_prime,quantity<energy_over_magnetic_flux_density>,1.410570419e-26*joules/tesla,3.8e-34*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_prime_over_mu_B,quantity<dimensionless>,1.520993128e-3*dimensionless(),1.7e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_prime_over_mu_B,quantity<dimensionless>,1.520993128e-3*dimensionless(),1.7e-11*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_prime_over_mu_N,quantity<dimensionless>,2.792775598*dimensionless(),3.0e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_prime_over_mu_N,quantity<dimensionless>,2.792775598*dimensionless(),3.0e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p,quantity<mass>,1.672621637e-27*kilograms,8.3e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p,quantity<mass>,1.672621637e-27*kilograms,8.3e-35*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_p,quantity<mass_over_amount>,1.00727646677e-3*kilograms\/mole,1.0e-13*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_p,quantity<mass_over_amount>,1.00727646677e-3*kilograms/mole,1.0e-13*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_e,quantity<dimensionless>,1836.15267247*dimensionless(),8.0e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_e,quantity<dimensionless>,1836.15267247*dimensionless(),8.0e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_mu,quantity<dimensionless>,8.88024339*dimensionless(),2.3e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_mu,quantity<dimensionless>,8.88024339*dimensionless(),2.3e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_n,quantity<dimensionless>,0.99862347824*dimensionless(),4.6e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_n,quantity<dimensionless>,0.99862347824*dimensionless(),4.6e-10*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_tau,quantity<dimensionless>,0.528012*dimensionless(),8.6e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_tau,quantity<dimensionless>,0.528012*dimensionless(),8.6e-5*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_p,quantity<length>,0.8768e-15*meters,6.9e-18*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_p,quantity<length>,0.8768e-15*meters,6.9e-18*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(sigma_p_prime,quantity<dimensionless>,25.694e-6*dimensionless(),1.4e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(sigma_p_prime,quantity<dimensionless>,25.694e-6*dimensionless(),1.4e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_tau,quantity<length>,0.69772e-15*meters,1.1e-19*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_tau,quantity<length>,0.69772e-15*meters,1.1e-19*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau,quantity<mass>,3.16777e-27*kilograms,5.2e-31*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau,quantity<mass>,3.16777e-27*kilograms,5.2e-31*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_tau,quantity<mass_over_amount>,1.90768e-3*kilograms\/mole,3.1e-7*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_tau,quantity<mass_over_amount>,1.90768e-3*kilograms/mole,3.1e-7*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_e,quantity<dimensionless>,3477.48*dimensionless(),5.7e-1*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_e,quantity<dimensionless>,3477.48*dimensionless(),5.7e-1*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_mu,quantity<dimensionless>,16.8183*dimensionless(),2.7e-3*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_mu,quantity<dimensionless>,16.8183*dimensionless(),2.7e-3*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_n,quantity<dimensionless>,1.89129*dimensionless(),3.1e-4*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_n,quantity<dimensionless>,1.89129*dimensionless(),3.1e-4*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_p,quantity<dimensionless>,1.89390*dimensionless(),3.1e-4*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_p,quantity<dimensionless>,1.89390*dimensionless(),3.1e-4*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_t,quantity<dimensionless>,5.957924896*dimensionless(),7.6e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_t,quantity<dimensionless>,5.957924896*dimensionless(),7.6e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t,quantity<energy_over_magnetic_flux_density>,1.504609361e-26*joules\/tesla,4.2e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t,quantity<energy_over_magnetic_flux_density>,1.504609361e-26*joules/tesla,4.2e-34*joules/tesla)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_B,quantity<dimensionless>,1.622393657e-3*dimensionless(),2.1e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_B,quantity<dimensionless>,1.622393657e-3*dimensionless(),2.1e-11*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_e,quantity<dimensionless>,-1.620514423e-3*dimensionless(),2.1e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_e,quantity<dimensionless>,-1.620514423e-3*dimensionless(),2.1e-11*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_n,quantity<dimensionless>,-1.55718553*dimensionless(),3.7e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_n,quantity<dimensionless>,-1.55718553*dimensionless(),3.7e-7*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_N,quantity<dimensionless>,2.978962448*dimensionless(),3.8e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_N,quantity<dimensionless>,2.978962448*dimensionless(),3.8e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_p,quantity<dimensionless>,1.066639908*dimensionless(),1.0e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_p,quantity<dimensionless>,1.066639908*dimensionless(),1.0e-8*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_t,quantity<mass>,5.00735588e-27*kilograms,2.5e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_t,quantity<mass>,5.00735588e-27*kilograms,2.5e-34*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_t,quantity<mass_over_amount>,3.0155007134e-3*kilograms\/mole,2.5e-12*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_t,quantity<mass_over_amount>,3.0155007134e-3*kilograms/mole,2.5e-12*kilograms/mole)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_t_over_m_e,quantity<dimensionless>,5496.9215269*dimensionless(),5.1e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_t_over_m_e,quantity<dimensionless>,5496.9215269*dimensionless(),5.1e-6*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_t_over_m_p,quantity<dimensionless>,2.9937170309*dimensionless(),2.5e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_t_over_m_p,quantity<dimensionless>,2.9937170309*dimensionless(),2.5e-9*dimensionless())
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c,quantity<velocity>,299792458.0*meters\/second,0.0*meters\/second);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c,quantity<velocity>,299792458.0*meters/second,0.0*meters/second)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(epsilon_0,quantity<capacitance_over_length>,8.854187817620389850536563031710750260608e-12*farad\/meter,0.0*farad\/meter);$/;"	p	namespace:boost::units::si::constants::codata	signature:(epsilon_0,quantity<capacitance_over_length>,8.854187817620389850536563031710750260608e-12*farad/meter,0.0*farad/meter)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(G,quantity<volume_over_mass_time_squared>,6.67428e-11*cubic_meters\/kilogram\/second\/second,6.7e-15*cubic_meters\/kilogram\/second\/second);$/;"	p	namespace:boost::units::si::constants::codata	signature:(G,quantity<volume_over_mass_time_squared>,6.67428e-11*cubic_meters/kilogram/second/second,6.7e-15*cubic_meters/kilogram/second/second)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(h,quantity<energy_time>,6.62606896e-34*joule*seconds,3.3e-41*joule*seconds);$/;"	p	namespace:boost::units::si::constants::codata	signature:(h,quantity<energy_time>,6.62606896e-34*joule*seconds,3.3e-41*joule*seconds)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(hbar,quantity<energy_time>,1.054571628e-34*joule*seconds,5.3e-42*joule*seconds);$/;"	p	namespace:boost::units::si::constants::codata	signature:(hbar,quantity<energy_time>,1.054571628e-34*joule*seconds,5.3e-42*joule*seconds)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(l_P,quantity<length>,1.616252e-35*meters,8.1e-40*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(l_P,quantity<length>,1.616252e-35*meters,8.1e-40*meters)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_0,quantity<force_over_current_squared>,12.56637061435917295385057353311801153679e-7*newtons\/ampere\/ampere,0.0*newtons\/ampere\/ampere);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_0,quantity<force_over_current_squared>,12.56637061435917295385057353311801153679e-7*newtons/ampere/ampere,0.0*newtons/ampere/ampere)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_P,quantity<mass>,2.17644e-8*kilograms,1.1e-12*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_P,quantity<mass>,2.17644e-8*kilograms,1.1e-12*kilograms)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(T_P,quantity<temperature>,1.416785e32*kelvin,7.1e27*kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(T_P,quantity<temperature>,1.416785e32*kelvin,7.1e27*kelvin)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(t_P,quantity<time>,5.39124e-44*seconds,2.7e-48*seconds);$/;"	p	namespace:boost::units::si::constants::codata	signature:(t_P,quantity<time>,5.39124e-44*seconds,2.7e-48*seconds)
boost::units::si::constants::codata::BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(Z_0,quantity<resistance>,376.7303134617706554681984004203193082686*ohm,0.0*ohm);$/;"	p	namespace:boost::units::si::constants::codata	signature:(Z_0,quantity<resistance>,376.7303134617706554681984004203193082686*ohm,0.0*ohm)
boost::units::si::constants::codata::capacitance_over_length	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<capacitance,length>::type capacitance_over_length;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::current_over_energy	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<current,energy>::type current_over_energy;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::electric_charge_over_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<electric_charge,amount>::type electric_charge_over_amount;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::electric_charge_over_mass	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<electric_charge,mass>::type electric_charge_over_mass;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::energy_over_magnetic_flux_density	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<energy,magnetic_flux_density>::type energy_over_magnetic_flux_density;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::energy_over_temperature	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<energy,temperature>::type energy_over_temperature;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::energy_over_temperature_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<energy_over_temperature,amount>::type energy_over_temperature_amount;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::energy_time	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef multiply_typeof_helper<energy,time>::type energy_time;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::force_over_current_squared	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<divide_typeof_helper<force,current>::type,current>::type force_over_current_squared;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::frequency_over_electric_potential	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<frequency,electric_potential>::type frequency_over_electric_potential;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::frequency_over_magnetic_flux_density	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<frequency,magnetic_flux_density>::type frequency_over_magnetic_flux_density;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::frequency_over_temperature	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<frequency,temperature>::type frequency_over_temperature;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::inverse_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<dimensionless,amount>::type inverse_amount;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::length_temperature	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef multiply_typeof_helper<length,temperature>::type length_temperature;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::mass_over_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<mass,amount>::type mass_over_amount;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::power_area	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef multiply_typeof_helper<power,area>::type power_area;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::power_area_over_solid_angle	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<power_area,solid_angle>::type power_area_over_solid_angle;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::power_over_area_temperature_4	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^        >::type power_over_area_temperature_4;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::constants::codata::volume_over_mass_time_squared	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^        >::type volume_over_mass_time_squared;$/;"	t	namespace:boost::units::si::constants::codata
boost::units::si::current	/usr/include/boost/units/systems/si/current.hpp	/^typedef unit<current_dimension,si::system>   current;$/;"	t	namespace:boost::units::si
boost::units::si::dimensionless	/usr/include/boost/units/systems/si/base.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::si
boost::units::si::dose_equivalent	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^typedef unit<dose_equivalent_dimension,si::system>     dose_equivalent;$/;"	t	namespace:boost::units::si
boost::units::si::dynamic_viscosity	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	/^typedef unit<dynamic_viscosity_dimension,si::system>     dynamic_viscosity;$/;"	t	namespace:boost::units::si
boost::units::si::electric_charge	/usr/include/boost/units/systems/si/electric_charge.hpp	/^typedef unit<electric_charge_dimension,si::system>    electric_charge;$/;"	t	namespace:boost::units::si
boost::units::si::electric_potential	/usr/include/boost/units/systems/si/electric_potential.hpp	/^typedef unit<electric_potential_dimension,si::system>    electric_potential;$/;"	t	namespace:boost::units::si
boost::units::si::energy	/usr/include/boost/units/systems/si/energy.hpp	/^typedef unit<energy_dimension,si::system>    energy;$/;"	t	namespace:boost::units::si
boost::units::si::force	/usr/include/boost/units/systems/si/force.hpp	/^typedef unit<force_dimension,si::system>     force;$/;"	t	namespace:boost::units::si
boost::units::si::frequency	/usr/include/boost/units/systems/si/frequency.hpp	/^typedef unit<frequency_dimension,si::system>     frequency;$/;"	t	namespace:boost::units::si
boost::units::si::illuminance	/usr/include/boost/units/systems/si/illuminance.hpp	/^typedef unit<illuminance_dimension,si::system>      illuminance;$/;"	t	namespace:boost::units::si
boost::units::si::impedance	/usr/include/boost/units/systems/si/impedance.hpp	/^typedef unit<impedance_dimension,si::system>    impedance;$/;"	t	namespace:boost::units::si
boost::units::si::inductance	/usr/include/boost/units/systems/si/inductance.hpp	/^typedef unit<inductance_dimension,si::system>    inductance;$/;"	t	namespace:boost::units::si
boost::units::si::kinematic_viscosity	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	/^typedef unit<kinematic_viscosity_dimension,si::system>     kinematic_viscosity;$/;"	t	namespace:boost::units::si
boost::units::si::length	/usr/include/boost/units/systems/si/length.hpp	/^typedef unit<length_dimension,si::system>    length;$/;"	t	namespace:boost::units::si
boost::units::si::luminous_flux	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^typedef unit<luminous_flux_dimension,si::system>      luminous_flux;$/;"	t	namespace:boost::units::si
boost::units::si::luminous_intensity	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^typedef unit<luminous_intensity_dimension,si::system>      luminous_intensity;$/;"	t	namespace:boost::units::si
boost::units::si::magnetic_field_intensity	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	/^typedef unit<magnetic_field_intensity_dimension,si::system>    magnetic_field_intensity;$/;"	t	namespace:boost::units::si
boost::units::si::magnetic_flux	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^typedef unit<magnetic_flux_dimension,si::system>    magnetic_flux;$/;"	t	namespace:boost::units::si
boost::units::si::magnetic_flux_density	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^typedef unit<magnetic_flux_density_dimension,si::system>    magnetic_flux_density;$/;"	t	namespace:boost::units::si
boost::units::si::mass	/usr/include/boost/units/systems/si/mass.hpp	/^typedef unit<mass_dimension,si::system>      mass;$/;"	t	namespace:boost::units::si
boost::units::si::mass_density	/usr/include/boost/units/systems/si/mass_density.hpp	/^typedef unit<mass_density_dimension,si::system>  mass_density;$/;"	t	namespace:boost::units::si
boost::units::si::momentum	/usr/include/boost/units/systems/si/momentum.hpp	/^typedef unit<momentum_dimension,si::system>  momentum;$/;"	t	namespace:boost::units::si
boost::units::si::moment_of_inertia	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	/^typedef unit<moment_of_inertia_dimension,si::system>      moment_of_inertia;$/;"	t	namespace:boost::units::si
boost::units::si::permeability	/usr/include/boost/units/systems/si/permeability.hpp	/^typedef unit<permeability_dimension,si::system>    permeability;$/;"	t	namespace:boost::units::si
boost::units::si::permittivity	/usr/include/boost/units/systems/si/permittivity.hpp	/^typedef unit<permittivity_dimension,si::system>    permittivity;$/;"	t	namespace:boost::units::si
boost::units::si::plane_angle	/usr/include/boost/units/systems/si/plane_angle.hpp	/^typedef unit<plane_angle_dimension,si::system>      plane_angle;$/;"	t	namespace:boost::units::si
boost::units::si::power	/usr/include/boost/units/systems/si/power.hpp	/^typedef unit<power_dimension,si::system>     power;$/;"	t	namespace:boost::units::si
boost::units::si::pressure	/usr/include/boost/units/systems/si/pressure.hpp	/^typedef unit<pressure_dimension,si::system>      pressure;$/;"	t	namespace:boost::units::si
boost::units::si::reluctance	/usr/include/boost/units/systems/si/reluctance.hpp	/^typedef unit<reluctance_dimension,si::system>    reluctance;$/;"	t	namespace:boost::units::si
boost::units::si::resistance	/usr/include/boost/units/systems/si/resistance.hpp	/^typedef unit<resistance_dimension,si::system>    resistance;$/;"	t	namespace:boost::units::si
boost::units::si::resistivity	/usr/include/boost/units/systems/si/resistivity.hpp	/^typedef unit<resistivity_dimension,si::system>    resistivity;$/;"	t	namespace:boost::units::si
boost::units::si::solid_angle	/usr/include/boost/units/systems/si/solid_angle.hpp	/^typedef unit<solid_angle_dimension,si::system>      solid_angle;$/;"	t	namespace:boost::units::si
boost::units::si::surface_density	/usr/include/boost/units/systems/si/surface_density.hpp	/^typedef unit<surface_density_dimension,si::system>  surface_density;$/;"	t	namespace:boost::units::si
boost::units::si::surface_tension	/usr/include/boost/units/systems/si/surface_tension.hpp	/^typedef unit<surface_tension_dimension,si::system>     surface_tension;$/;"	t	namespace:boost::units::si
boost::units::si::system	/usr/include/boost/units/systems/si/base.hpp	/^                    angle::steradian_base_unit>::type system;$/;"	t	namespace:boost::units::si
boost::units::si::temperature	/usr/include/boost/units/systems/si/temperature.hpp	/^typedef unit<temperature_dimension,si::system>   temperature;$/;"	t	namespace:boost::units::si
boost::units::si::time	/usr/include/boost/units/systems/si/time.hpp	/^typedef unit<time_dimension,si::system>      time;$/;"	t	namespace:boost::units::si
boost::units::si::torque	/usr/include/boost/units/systems/si/torque.hpp	/^typedef unit<torque_dimension,si::system>     torque;$/;"	t	namespace:boost::units::si
boost::units::si::velocity	/usr/include/boost/units/systems/si/velocity.hpp	/^typedef unit<velocity_dimension,si::system>      velocity;$/;"	t	namespace:boost::units::si
boost::units::si::volume	/usr/include/boost/units/systems/si/volume.hpp	/^typedef unit<volume_dimension,si::system>    volume;$/;"	t	namespace:boost::units::si
boost::units::si::wavenumber	/usr/include/boost/units/systems/si/wavenumber.hpp	/^typedef unit<wavenumber_dimension,si::system>    wavenumber;$/;"	t	namespace:boost::units::si
boost::units::static_power	/usr/include/boost/units/heterogeneous_system.hpp	/^struct static_power<heterogeneous_system<S>, static_rational<N,D> >$/;"	s	namespace:boost::units
boost::units::static_power	/usr/include/boost/units/homogeneous_system.hpp	/^struct static_power<homogeneous_system<L>, static_rational<N,D> >$/;"	s	namespace:boost::units
boost::units::static_power::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::static_power	access:public
boost::units::static_power::type	/usr/include/boost/units/homogeneous_system.hpp	/^    typedef homogeneous_system<L> type;$/;"	t	struct:boost::units::static_power	access:public
boost::units::static_root	/usr/include/boost/units/heterogeneous_system.hpp	/^struct static_root<heterogeneous_system<S>, static_rational<N,D> >$/;"	s	namespace:boost::units
boost::units::static_root	/usr/include/boost/units/homogeneous_system.hpp	/^struct static_root<homogeneous_system<L>, static_rational<N,D> >$/;"	s	namespace:boost::units
boost::units::static_root::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::static_root	access:public
boost::units::static_root::type	/usr/include/boost/units/homogeneous_system.hpp	/^    typedef homogeneous_system<L> type;$/;"	t	struct:boost::units::static_root	access:public
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::acceleration>::type&) { return "Gal"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::acceleration>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::current>::type&) { return "Bi"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::current>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::dynamic_viscosity>::type&) { return "P"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::dynamic_viscosity>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::energy>::type&) { return "erg"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::energy>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::force>::type&) { return "dyn"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::force>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::kinematic_viscosity>::type&) { return "St"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::kinematic_viscosity>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::pressure>::type&) { return "Ba"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::pressure>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::wavenumber>::type&) { return "K"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::wavenumber>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::absorbed_dose>::type&) { return "Gy"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::absorbed_dose>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::capacitance>::type&) { return "F"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::capacitance>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::catalytic_activity>::type&) { return "kat"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::catalytic_activity>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::conductance>::type&) { return "S"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::conductance>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::electric_charge>::type&) { return "C"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_charge>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::electric_potential>::type&) { return "V"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_potential>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::energy>::type&) { return "J"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::energy>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::force>::type&) { return "N"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::force>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::frequency>::type&) { return "Hz"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::frequency>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::illuminance>::type&) { return "lx"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::illuminance>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::inductance>::type&) { return "H"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::inductance>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::luminous_flux>::type&) { return "lm"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::luminous_flux>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::magnetic_flux>::type&) { return "Wb"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::magnetic_flux_density>::type&) { return "T"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux_density>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::power>::type&) { return "W"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::power>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::pressure>::type&) { return "Pa"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::pressure>::type&)
boost::units::symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::resistance>::type&) { return "Ohm"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::resistance>::type&)
boost::units::unscale	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale<heterogeneous_system<T> >$/;"	s	namespace:boost::units
boost::units::unscale	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale<heterogeneous_system_dim<Unit, Exponent> >$/;"	s	namespace:boost::units
boost::units::unscale::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::unscale	access:public
boost::units::unscale::type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system_dim<typename unscale<Unit>::type, Exponent> type;$/;"	t	struct:boost::units::unscale	access:public
boost::utf16regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^typedef u32regex_iterator<const UChar*> utf16regex_iterator;$/;"	t	namespace:boost
boost::utf16regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^typedef u32regex_token_iterator<const UChar*> utf16regex_token_iterator;$/;"	t	namespace:boost
boost::utf16_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class utf16_output_iterator$/;"	c	namespace:boost
boost::utf16_output_iterator::base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::utf16_output_iterator	access:public	signature:() const
boost::utf16_output_iterator::difference_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   difference_type;$/;"	t	class:boost::utf16_output_iterator	access:public
boost::utf16_output_iterator::iterator_category	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef std::output_iterator_tag               iterator_category;$/;"	t	class:boost::utf16_output_iterator	access:public
boost::utf16_output_iterator::m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable BaseIterator m_position;$/;"	m	class:boost::utf16_output_iterator	access:private
boost::utf16_output_iterator::operator *	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   const utf16_output_iterator& operator*()const$/;"	f	class:boost::utf16_output_iterator	access:public	signature:() const
boost::utf16_output_iterator::operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator& operator++()$/;"	f	class:boost::utf16_output_iterator	access:public	signature:()
boost::utf16_output_iterator::operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator& operator++(int)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(int)
boost::utf16_output_iterator::operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator& operator=(const utf16_output_iterator& that)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(const utf16_output_iterator& that)
boost::utf16_output_iterator::operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void operator=(boost::uint32_t val)const$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(boost::uint32_t val) const
boost::utf16_output_iterator::pointer	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t*                       pointer;$/;"	t	class:boost::utf16_output_iterator	access:public
boost::utf16_output_iterator::push	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void push(boost::uint32_t v)const$/;"	f	class:boost::utf16_output_iterator	access:private	signature:(boost::uint32_t v) const
boost::utf16_output_iterator::reference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t&                       reference;$/;"	t	class:boost::utf16_output_iterator	access:public
boost::utf16_output_iterator::utf16_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator(const BaseIterator& b)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(const BaseIterator& b)
boost::utf16_output_iterator::utf16_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator(const utf16_output_iterator& that)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(const utf16_output_iterator& that)
boost::utf16_output_iterator::value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   value_type;$/;"	t	class:boost::utf16_output_iterator	access:public
boost::utf32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^typedef u32regex_iterator<const UChar32*> utf32regex_iterator;$/;"	t	namespace:boost
boost::utf32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^typedef u32regex_token_iterator<const UChar32*> utf32regex_token_iterator;$/;"	t	namespace:boost
boost::utf8regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^typedef u32regex_iterator<const char*> utf8regex_iterator;$/;"	t	namespace:boost
boost::utf8regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^typedef u32regex_token_iterator<const char*> utf8regex_token_iterator;$/;"	t	namespace:boost
boost::utf8_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class utf8_output_iterator$/;"	c	namespace:boost
boost::utf8_output_iterator::base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator base()const$/;"	f	class:boost::utf8_output_iterator	access:public	signature:() const
boost::utf8_output_iterator::difference_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   difference_type;$/;"	t	class:boost::utf8_output_iterator	access:public
boost::utf8_output_iterator::iterator_category	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef std::output_iterator_tag               iterator_category;$/;"	t	class:boost::utf8_output_iterator	access:public
boost::utf8_output_iterator::m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable BaseIterator m_position;$/;"	m	class:boost::utf8_output_iterator	access:private
boost::utf8_output_iterator::operator *	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   const utf8_output_iterator& operator*()const$/;"	f	class:boost::utf8_output_iterator	access:public	signature:() const
boost::utf8_output_iterator::operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator& operator++()$/;"	f	class:boost::utf8_output_iterator	access:public	signature:()
boost::utf8_output_iterator::operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator& operator++(int)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(int)
boost::utf8_output_iterator::operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator& operator=(const utf8_output_iterator& that)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(const utf8_output_iterator& that)
boost::utf8_output_iterator::operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void operator=(boost::uint32_t val)const$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(boost::uint32_t val) const
boost::utf8_output_iterator::pointer	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t*                       pointer;$/;"	t	class:boost::utf8_output_iterator	access:public
boost::utf8_output_iterator::push	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void push(boost::uint32_t c)const$/;"	f	class:boost::utf8_output_iterator	access:private	signature:(boost::uint32_t c) const
boost::utf8_output_iterator::reference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t&                       reference;$/;"	t	class:boost::utf8_output_iterator	access:public
boost::utf8_output_iterator::utf8_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator(const BaseIterator& b)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(const BaseIterator& b)
boost::utf8_output_iterator::utf8_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator(const utf8_output_iterator& that)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(const utf8_output_iterator& that)
boost::utf8_output_iterator::value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   value_type;$/;"	t	class:boost::utf8_output_iterator	access:public
boost::w32_regex_traits	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class w32_regex_traits$/;"	c	namespace:boost
boost::w32_regex_traits::boost_extensions_tag	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   struct boost_extensions_tag{};$/;"	s	class:boost::w32_regex_traits	access:public
boost::w32_regex_traits::catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static std::string catalog_name(const std::string& name);$/;"	p	class:boost::w32_regex_traits	access:public	signature:(const std::string& name)
boost::w32_regex_traits::catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^std::string w32_regex_traits<charT>::catalog_name(const std::string& name)$/;"	f	class:boost::w32_regex_traits	signature:(const std::string& name)
boost::w32_regex_traits::char_class_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef boost::uint_least32_t         char_class_type;$/;"	t	class:boost::w32_regex_traits	access:public
boost::w32_regex_traits::char_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef charT                         char_type;$/;"	t	class:boost::w32_regex_traits	access:public
boost::w32_regex_traits::error_string	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(regex_constants::error_type n) const
boost::w32_regex_traits::escape_syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
boost::w32_regex_traits::getloc	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   locale_type getloc()const$/;"	f	class:boost::w32_regex_traits	access:public	signature:() const
boost::w32_regex_traits::get_catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static std::string get_catalog_name();$/;"	p	class:boost::w32_regex_traits	access:public	signature:()
boost::w32_regex_traits::get_catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^std::string w32_regex_traits<charT>::get_catalog_name()$/;"	f	class:boost::w32_regex_traits	signature:()
boost::w32_regex_traits::get_catalog_name_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static std::string& get_catalog_name_inst();$/;"	p	class:boost::w32_regex_traits	access:private	signature:()
boost::w32_regex_traits::get_catalog_name_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^std::string& w32_regex_traits<charT>::get_catalog_name_inst()$/;"	f	class:boost::w32_regex_traits	signature:()
boost::w32_regex_traits::get_mutex_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static static_mutex& get_mutex_inst();$/;"	p	class:boost::w32_regex_traits	access:private	signature:()
boost::w32_regex_traits::get_mutex_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^static_mutex& w32_regex_traits<charT>::get_mutex_inst()$/;"	f	class:boost::w32_regex_traits	signature:()
boost::w32_regex_traits::imbue	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   locale_type imbue(locale_type l)$/;"	f	class:boost::w32_regex_traits	access:public	signature:(locale_type l)
boost::w32_regex_traits::isctype	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   bool isctype(charT c, char_class_type f) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c, char_class_type f) const
boost::w32_regex_traits::length	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static size_type length(const char_type* p)$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const char_type* p)
boost::w32_regex_traits::locale_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef ::boost::re_detail::lcid_type locale_type;$/;"	t	class:boost::w32_regex_traits	access:public
boost::w32_regex_traits::lookup_classname	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::w32_regex_traits::lookup_collatename	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::w32_regex_traits::m_pimpl	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   boost::shared_ptr<const re_detail::w32_regex_traits_implementation<charT> > m_pimpl;$/;"	m	class:boost::w32_regex_traits	access:private
boost::w32_regex_traits::size_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::size_t                   size_type;$/;"	t	class:boost::w32_regex_traits	access:public
boost::w32_regex_traits::string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::basic_string<char_type>  string_type;$/;"	t	class:boost::w32_regex_traits	access:public
boost::w32_regex_traits::syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
boost::w32_regex_traits::toi	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   int toi(const charT*& p1, const charT* p2, int radix)const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT*& p1, const charT* p2, int radix) const
boost::w32_regex_traits::tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT tolower(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
boost::w32_regex_traits::toupper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT toupper(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
boost::w32_regex_traits::transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::w32_regex_traits::transform_primary	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
boost::w32_regex_traits::translate	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT translate(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
boost::w32_regex_traits::translate	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT translate(charT c, bool icase) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c, bool icase) const
boost::w32_regex_traits::translate_nocase	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT translate_nocase(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
boost::w32_regex_traits::value	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   int value(charT c, int radix)const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c, int radix) const
boost::w32_regex_traits::w32_regex_traits	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits()$/;"	f	class:boost::w32_regex_traits	access:public	signature:()
boost::wave	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost
boost::wave::util	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost::wave
boost::wave::util::branch_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path branch_path(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
boost::wave::util::complete_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p)
boost::wave::util::complete_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p, boost::filesystem::path const& base)
boost::wave::util::create_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path create_path(String const& p)$/;"	f	namespace:boost::wave::util	signature:(String const& p)
boost::wave::util::current_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path current_path()$/;"	f	namespace:boost::wave::util	signature:()
boost::wave::util::initial_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path initial_path()$/;"	f	namespace:boost::wave::util	signature:()
boost::wave::util::leaf	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline std::string leaf(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
boost::wave::util::native_file_string	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline std::string native_file_string(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
boost::wave::util::normalize	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path normalize(boost::filesystem::path& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path& p)
boost::wcmatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<const wchar_t*> wcmatch;$/;"	t	namespace:boost
boost::wcregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<const wchar_t*> wcregex_iterator;$/;"	t	namespace:boost
boost::wcregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<const wchar_t*> wcregex_token_iterator;$/;"	t	namespace:boost
boost::wcsub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<const wchar_t*> wcsub_match;$/;"	t	namespace:boost
boost::wregex	/usr/include/boost/regex/v4/regex.hpp	/^typedef basic_regex<wchar_t, regex_traits<wchar_t> > wregex;$/;"	t	namespace:boost
boost::wregex	/usr/include/boost/regex/v4/regex_fwd.hpp	/^typedef basic_regex<wchar_t, regex_traits<wchar_t> > wregex;$/;"	t	namespace:boost
boost::wsmatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<std::wstring::const_iterator> wsmatch;$/;"	t	namespace:boost
boost::wsregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<std::wstring::const_iterator> wsregex_iterator;$/;"	t	namespace:boost
boost::wsregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<std::wstring::const_iterator> wsregex_token_iterator;$/;"	t	namespace:boost
boost::wssub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<std::wstring::const_iterator> wssub_match;$/;"	t	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/basic_regex.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_actions.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_algorithms.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_compiler.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_error.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive::as_xpr	/usr/include/boost/xpressive/regex_primitives.hpp	/^template<typename Literal> detail::unspecified as_xpr(Literal const &literal) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Literal const &literal)
boost::xpressive::basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^struct basic_regex$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::basic_regex::base_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef proto::extends<pimpl_type, basic_regex<BidiIter>, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
boost::xpressive::basic_regex::basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:()
boost::xpressive::basic_regex::basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
boost::xpressive::basic_regex::basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(char_type const *);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(char_type const *)
boost::xpressive::basic_regex::basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
boost::xpressive::basic_regex::basic_regex	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex(string_type const &);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(string_type const &)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, collate            = regex_constants::collate);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, collate = regex_constants::collate)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ECMAScript         = regex_constants::ECMAScript);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ECMAScript = regex_constants::ECMAScript)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, icase              = regex_constants::icase_);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, icase = regex_constants::icase_)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, nosubs             = regex_constants::nosubs);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, nosubs = regex_constants::nosubs)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_newline    = regex_constants::not_dot_newline);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_newline = regex_constants::not_dot_newline)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_null       = regex_constants::not_dot_null);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_null = regex_constants::not_dot_null)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, optimize           = regex_constants::optimize);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, optimize = regex_constants::optimize)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, single_line        = regex_constants::single_line);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, single_line = regex_constants::single_line)
boost::xpressive::basic_regex::char_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::basic_regex::compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, std::size_t len, flag_type flags)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, std::size_t len, flag_type flags)
boost::xpressive::basic_regex::compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::basic_regex::compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::basic_regex::compile_	/usr/include/boost/xpressive/basic_regex.hpp	/^    void compile_(Expr const &, mpl::false_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &, mpl::false_)
boost::xpressive::basic_regex::compile_	/usr/include/boost/xpressive/basic_regex.hpp	/^    void compile_(Expr const &expr, mpl::true_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &expr, mpl::true_)
boost::xpressive::basic_regex::flag_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::iterator_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::mark_count	/usr/include/boost/xpressive/basic_regex.hpp	/^    std::size_t mark_count() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
boost::xpressive::basic_regex::match_	/usr/include/boost/xpressive/basic_regex.hpp	/^    bool match_(detail::match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(detail::match_state<BidiIter> &state) const
boost::xpressive::basic_regex::operator =	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
boost::xpressive::basic_regex::operator =	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
boost::xpressive::basic_regex::pimpl_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<detail::tracking_ptr<detail::regex_impl<BidiIter> > >, 0> pimpl_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
boost::xpressive::basic_regex::regex_id	/usr/include/boost/xpressive/basic_regex.hpp	/^    regex_id_type regex_id() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
boost::xpressive::basic_regex::string_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef typename detail::string_type<char_type>::type string_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::swap	/usr/include/boost/xpressive/basic_regex.hpp	/^    void swap(basic_regex<BidiIter> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> &that)
boost::xpressive::basic_regex::value_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type value_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s0, 0);$/;"	p	namespace:boost::xpressive	signature:(s0, 0)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s1, 1);$/;"	p	namespace:boost::xpressive	signature:(s1, 1)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s2, 2);$/;"	p	namespace:boost::xpressive	signature:(s2, 2)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s3, 3);$/;"	p	namespace:boost::xpressive	signature:(s3, 3)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s4, 4);$/;"	p	namespace:boost::xpressive	signature:(s4, 4)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s5, 5);$/;"	p	namespace:boost::xpressive	signature:(s5, 5)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s6, 6);$/;"	p	namespace:boost::xpressive	signature:(s6, 6)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s7, 7);$/;"	p	namespace:boost::xpressive	signature:(s7, 7)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s8, 8);$/;"	p	namespace:boost::xpressive	signature:(s8, 8)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s9, 9);$/;"	p	namespace:boost::xpressive	signature:(s9, 9)
boost::xpressive::cpp_regex_traits	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^struct cpp_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::cpp_regex_traits_base
boost::xpressive::cpp_regex_traits::base_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::cpp_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::char_class	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_pair const &char_class(std::size_t j)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(std::size_t j)
boost::xpressive::cpp_regex_traits::char_class_pair	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct char_class_pair$/;"	s	struct:boost::xpressive::cpp_regex_traits	access:private
boost::xpressive::cpp_regex_traits::char_class_pair::class_name_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        char_type const *class_name_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
boost::xpressive::cpp_regex_traits::char_class_pair::class_type_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        char_class_type class_type_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
boost::xpressive::cpp_regex_traits::char_class_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::umaskex_t char_class_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::char_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::compare_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static bool compare_(char_type const *name, FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(char_type const *name, FwdIter begin, FwdIter end)
boost::xpressive::cpp_regex_traits::cpp_regex_traits	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    cpp_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
boost::xpressive::cpp_regex_traits::fold_case	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::getloc	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:() const
boost::xpressive::cpp_regex_traits::hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::cpp_regex_traits::hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(char ch)
boost::xpressive::cpp_regex_traits::hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<signed char>::hash(signed char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(signed char ch)
boost::xpressive::cpp_regex_traits::hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<unsigned char>::hash(unsigned char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(unsigned char ch)
boost::xpressive::cpp_regex_traits::hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(wchar_t ch)
boost::xpressive::cpp_regex_traits::imbue	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type loc)
boost::xpressive::cpp_regex_traits::in_range	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::cpp_regex_traits::in_range_nocase	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool in_range_nocase(char_type first, char_type last, char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch) const
boost::xpressive::cpp_regex_traits::isctype	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool isctype(char_type ch, char_class_type mask) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, char_class_type mask) const
boost::xpressive::cpp_regex_traits::locale_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::locale locale_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::loc_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    locale_type loc_;$/;"	m	struct:boost::xpressive::cpp_regex_traits	access:private
boost::xpressive::cpp_regex_traits::lookup_classname	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase) const
boost::xpressive::cpp_regex_traits::lookup_classname_impl_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_type lookup_classname_impl_(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(FwdIter begin, FwdIter end)
boost::xpressive::cpp_regex_traits::lookup_collatename	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type lookup_collatename(FwdIter begin, FwdIter end) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end) const
boost::xpressive::cpp_regex_traits::operator !=	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool operator !=(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
boost::xpressive::cpp_regex_traits::operator ==	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool operator ==(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
boost::xpressive::cpp_regex_traits::std::ctype_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    std::ctype<char_type> const *ctype_;$/;"	m	class:boost::xpressive::cpp_regex_traits::std	access:private
boost::xpressive::cpp_regex_traits::string_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::tolower	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::toupper	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::transform	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform(FwdIter begin, FwdIter end) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end) const
boost::xpressive::cpp_regex_traits::transform_primary	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform_primary(FwdIter begin, FwdIter end) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end) const
boost::xpressive::cpp_regex_traits::translate	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::cpp_regex_traits::translate_nocase	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type translate_nocase(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::value	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, int radix) const
boost::xpressive::cpp_regex_traits::version_tag	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::widen	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char ch) const
boost::xpressive::cref	/usr/include/boost/xpressive/regex_actions.hpp	/^    reference<T const> const cref(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
boost::xpressive::c_regex_traits	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^struct c_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::c_regex_traits_base
boost::xpressive::c_regex_traits::base_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef detail::c_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::char_class_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef typename detail::char_class_impl<Char>::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::char_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::c_regex_traits	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    c_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
boost::xpressive::c_regex_traits::fold_case	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::c_regex_traits::getloc	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:()
boost::xpressive::c_regex_traits::hash	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::hash	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
boost::xpressive::c_regex_traits::hash	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch)
boost::xpressive::c_regex_traits::imbue	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type loc)
boost::xpressive::c_regex_traits::in_range	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::c_regex_traits::in_range_nocase	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::c_regex_traits::isctype	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
boost::xpressive::c_regex_traits::locale_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef detail::empty_locale locale_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::lookup_classname	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
boost::xpressive::c_regex_traits::lookup_collatename	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::c_regex_traits::operator !=	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    bool operator !=(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
boost::xpressive::c_regex_traits::operator ==	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    bool operator ==(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
boost::xpressive::c_regex_traits::string_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type tolower(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type toupper(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::transform	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::c_regex_traits::transform_primary	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::c_regex_traits::translate	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::translate_nocase	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::value	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static int value(char_type ch, int radix);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, int radix)
boost::xpressive::c_regex_traits::value	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<char>::value(char ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch, int radix)
boost::xpressive::c_regex_traits::value	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<wchar_t>::value(wchar_t ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch, int radix)
boost::xpressive::c_regex_traits::version_tag	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::widen	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type widen(char ch);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char ch)
boost::xpressive::c_regex_traits::widen	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline char c_regex_traits<char>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
boost::xpressive::c_regex_traits::widen	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline wchar_t c_regex_traits<wchar_t>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
boost::xpressive::detail	/usr/include/boost/xpressive/basic_regex.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/regex_actions.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/regex_algorithms.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/regex_error.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/regex_primitives.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail::action_arg	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct action_arg$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::action_arg::cast	/usr/include/boost/xpressive/regex_actions.hpp	/^            reference cast(void *pv) const$/;"	f	struct:boost::xpressive::detail::action_arg	access:public	signature:(void *pv) const
boost::xpressive::detail::action_arg::reference	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef typename add_reference<T>::type reference;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
boost::xpressive::detail::action_arg::type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T type;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
boost::xpressive::detail::all_ctype_masks	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const all_ctype_masks = std_ctype_reserved$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_word_begin	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_begin> assert_word_begin;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_word_boundary	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_boundary<mpl::true_> > assert_word_boundary;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_word_end	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_end> assert_word_end;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::begin	/usr/include/boost/xpressive/regex_algorithms.hpp	/^        BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) begin$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::BindArg	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct BindArg$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::BindArg::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            Expr const & operator ()(MatchResults &what, Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::BindArg	access:public	signature:(MatchResults &what, Expr const &expr) const
boost::xpressive::detail::BindArg::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(MatchResults, Expr)>$/;"	s	struct:boost::xpressive::detail::BindArg	access:public
boost::xpressive::detail::BindArg::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef Expr type;$/;"	t	struct:boost::xpressive::detail::BindArg::result	access:public
boost::xpressive::detail::BindArgs	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct BindArgs$/;"	s	namespace:boost::xpressive::detail	inherits:proto::function
boost::xpressive::detail::bind_args	/usr/include/boost/xpressive/regex_actions.hpp	/^        void bind_args(let_<Args> const &args, match_results<BidiIter> &what)$/;"	f	namespace:boost::xpressive::detail	signature:(let_<Args> const &args, match_results<BidiIter> &what)
boost::xpressive::detail::check_tag	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct check_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::cpp_regex_traits_base	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::cpp_regex_traits_base	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::cpp_regex_traits_base::imbue	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &)
boost::xpressive::detail::cpp_regex_traits_base::imbue	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &loc)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &loc)
boost::xpressive::detail::cpp_regex_traits_base::is	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        bool is(std::ctype<Char> const &, Char ch, umaskex_t mask) const$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &, Char ch, umaskex_t mask) const
boost::xpressive::detail::cpp_regex_traits_base::is	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is(std::ctype<Char> const &ct, Char ch, umaskex_t mask)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &ct, Char ch, umaskex_t mask)
boost::xpressive::detail::cpp_regex_traits_base::is_blank	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_blank(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
boost::xpressive::detail::cpp_regex_traits_base::is_newline	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_newline(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
boost::xpressive::detail::cpp_regex_traits_base::is_underscore	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_underscore(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
boost::xpressive::detail::cpp_regex_traits_base::masks_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        umaskex_t masks_[UCHAR_MAX + 1];$/;"	m	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private
boost::xpressive::detail::c_regex_traits_base	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::c_regex_traits_base	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::c_regex_traits_base	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<wchar_t, SizeOfChar>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::c_regex_traits_base::imbue	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^        static void imbue(Traits const &)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &)
boost::xpressive::detail::c_regex_traits_base::imbue	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^        void imbue(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &tr)
boost::xpressive::detail::c_tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    Char c_tolower(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
boost::xpressive::detail::c_tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline char c_tolower(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
boost::xpressive::detail::c_tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_tolower(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
boost::xpressive::detail::c_toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    Char c_toupper(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
boost::xpressive::detail::c_toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline char c_toupper(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
boost::xpressive::detail::c_toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_toupper(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
boost::xpressive::detail::empty_locale	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct empty_locale$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::end	/usr/include/boost/xpressive/regex_algorithms.hpp	/^      , BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) end$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::ensure_	/usr/include/boost/xpressive/regex_error.hpp	/^    inline bool ensure_($/;"	f	namespace:boost::xpressive::detail	signature:( bool cond , regex_constants::error_type code , char const *msg , char const *fun , char const *file , unsigned long line )
boost::xpressive::detail::finder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct finder$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::finder::ok_for_partial_matches	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual bool ok_for_partial_matches() const { return true; }$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:() const
boost::xpressive::detail::finder::operator ()	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual bool operator ()(match_state<BidiIter> &state) const = 0;$/;"	p	struct:boost::xpressive::detail::finder	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::finder::~finder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual ~finder() {}$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:()
boost::xpressive::detail::get_mark_number	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline int get_mark_number(int i)$/;"	f	namespace:boost::xpressive::detail	signature:(int i)
boost::xpressive::detail::highest_bit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const highest_bit = static_cast<umaskex_t>(1) << (sizeof(umaskex_t) * CHAR_BIT - 1);$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::ignore_unused_regex_actions	/usr/include/boost/xpressive/regex_actions.hpp	/^        inline void ignore_unused_regex_actions()$/;"	f	namespace:boost::xpressive::detail	signature:()
boost::xpressive::detail::ignore_unused_regex_primitives	/usr/include/boost/xpressive/regex_primitives.hpp	/^    inline void ignore_unused_regex_primitives()$/;"	f	namespace:boost::xpressive::detail	signature:()
boost::xpressive::detail::imbue	/usr/include/boost/xpressive/regex_primitives.hpp	/^imbue(Locale const &loc)$/;"	f	class:boost::xpressive::detail	signature:(Locale const &loc)
boost::xpressive::detail::let	/usr/include/boost/xpressive/regex_actions.hpp	/^    detail::let_<proto::terminal<detail::let_tag>::type> const let = {{{}}};$/;"	m	class:boost::xpressive::detail
boost::xpressive::detail::let_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct let_$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::let_domain	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct let_domain$/;"	s	namespace:boost::xpressive::detail	inherits:boost::proto::domain
boost::xpressive::detail::let_tag	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct let_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::make_function	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef boost::proto::functional::make_expr<proto::tag::function, proto::default_domain> make_function;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::make_function::impl::as	/usr/include/boost/xpressive/regex_actions.hpp	/^    as(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
boost::xpressive::detail::make_function::impl::const_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^    const_cast_(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
boost::xpressive::detail::make_function::impl::dynamic_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^    dynamic_cast_(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
boost::xpressive::detail::make_function::impl::static_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^    static_cast_(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
boost::xpressive::detail::mark_nbr	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct mark_nbr$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mark_nbr::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            int operator()(mark_placeholder m) const$/;"	f	struct:boost::xpressive::detail::mark_nbr	access:public	signature:(mark_placeholder m) const
boost::xpressive::detail::mark_nbr::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_nbr	access:public
boost::xpressive::detail::mark_number	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct mark_number : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
boost::xpressive::detail::mark_number::operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^        int operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::mark_number	access:public	signature:(Expr const &expr) const
boost::xpressive::detail::mark_number::result_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_number	access:public
boost::xpressive::detail::mask_cast	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mask_cast	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast<std::ctype_base::print>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mask_cast::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = 0227);$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = 0227)
boost::xpressive::detail::mask_cast::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = static_cast<umask_t>(Mask));$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = static_cast<umask_t>(Mask))
boost::xpressive::detail::mask_cast::value	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const mask_cast<Mask>::value;$/;"	m	class:boost::xpressive::detail::mask_cast
boost::xpressive::detail::minus_one	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef mpl::int_<-1> minus_one;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::mylog2	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    inline int mylog2(umaskex_t i)$/;"	f	namespace:boost::xpressive::detail	signature:(umaskex_t i)
boost::xpressive::detail::named_mark	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct named_mark$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::named_mark::mark_nbr_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_nbr_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
boost::xpressive::detail::named_mark::named_mark	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    named_mark(string_type name, std::size_t mark_nbr)$/;"	f	struct:boost::xpressive::detail::named_mark	access:public	signature:(string_type name, std::size_t mark_nbr)
boost::xpressive::detail::named_mark::name_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    string_type name_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
boost::xpressive::detail::named_mark::string_type	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    typedef typename detail::string_type<Char>::type string_type;$/;"	t	struct:boost::xpressive::detail::named_mark	access:public
boost::xpressive::detail::non_std_ctype_blank	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = 1 << 12;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_blank	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = unused_mask<all_ctype_masks | non_std_ctype_underscore>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_masks	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_masks = non_std_ctype_underscore | non_std_ctype_blank | non_std_ctype_newline;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_newline	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = 1 << 13;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_newline	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = unused_mask<all_ctype_masks | non_std_ctype_underscore | non_std_ctype_blank>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_underscore	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = 1 << 11;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_underscore	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = unused_mask<all_ctype_masks>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::not_a_locale	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    struct not_a_locale {};$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::Primitives	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct Primitives$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::push_back	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct push_back : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
boost::xpressive::detail::push_back::operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^        int operator ()(Subs &subs, int i) const$/;"	f	struct:boost::xpressive::detail::push_back	access:public	signature:(Subs &subs, int i) const
boost::xpressive::detail::push_back::result_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::push_back	access:public
boost::xpressive::detail::re	/usr/include/boost/xpressive/regex_algorithms.hpp	/^      , basic_regex<BidiIter> const &re$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::regex_byref_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^    struct regex_byref_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::regex_byref_matcher::match	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::regex_byref_matcher::pimpl_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_impl<BidiIter> const *pimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
boost::xpressive::detail::regex_byref_matcher::regex_byref_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_byref_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
boost::xpressive::detail::regex_byref_matcher::wimpl_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        weak_ptr<regex_impl<BidiIter> > wimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
boost::xpressive::detail::regex_byref_matcher::wrap_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static Next const &wrap_(Next const &next, mpl::false_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::false_)
boost::xpressive::detail::regex_byref_matcher::wrap_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static xpression_adaptor<reference_wrapper<Next const>, matchable<BidiIter> > wrap_(Next const &next, mpl::true_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::true_)
boost::xpressive::detail::regex_domain	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	/^    struct regex_domain$/;"	s	namespace:boost::xpressive::detail	inherits:proto::domain
boost::xpressive::detail::regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct regex_impl$/;"	s	namespace:boost::xpressive::detail	inherits:enable_reference_tracking
boost::xpressive::detail::regex_impl::char_type	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::finder_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<finder<BidiIter> > finder_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::hidden_mark_count_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::instances	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    static int instances;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::instances	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^int regex_impl<BidiIter>::instances = 0;$/;"	m	class:boost::xpressive::detail::regex_impl
boost::xpressive::detail::regex_impl::mark_count_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::named_marks_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::vector<named_mark<char_type> > named_marks_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::operator =	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    regex_impl &operator =(regex_impl const &);$/;"	p	struct:boost::xpressive::detail::regex_impl	access:private	signature:(regex_impl const &)
boost::xpressive::detail::regex_impl::regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
boost::xpressive::detail::regex_impl::regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    regex_impl(regex_impl<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> const &that)
boost::xpressive::detail::regex_impl::swap	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    void swap(regex_impl<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> &that)
boost::xpressive::detail::regex_impl::traits_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<traits<char_type> const> traits_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::xpr_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<matchable_ex<BidiIter> const> xpr_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::~regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    ~regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
boost::xpressive::detail::regex_iterator_impl	/usr/include/boost/xpressive/regex_iterator.hpp	/^struct regex_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::regex_iterator_impl::access	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef detail::core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::equal_to	/usr/include/boost/xpressive/regex_iterator.hpp	/^    bool equal_to(regex_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:(regex_iterator_impl<BidiIter> const &that) const
boost::xpressive::detail::regex_iterator_impl::next	/usr/include/boost/xpressive/regex_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:()
boost::xpressive::detail::regex_iterator_impl::not_null_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    bool not_null_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::regex_constants::flags_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_constants::match_flag_type const flags_;$/;"	m	class:boost::xpressive::detail::regex_iterator_impl::regex_constants	access:public
boost::xpressive::detail::regex_iterator_impl::regex_iterator_impl	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags , bool not_null = false )
boost::xpressive::detail::regex_iterator_impl::rex_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    basic_regex<BidiIter> rex_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::state_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    match_state<BidiIter> state_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::what_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    match_results<BidiIter> what_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^    struct regex_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::regex_matcher::impl_	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_impl<BidiIter> impl_;$/;"	m	struct:boost::xpressive::detail::regex_matcher	access:public
boost::xpressive::detail::regex_matcher::match	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::regex_matcher::regex_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
boost::xpressive::detail::regex_token_iterator_impl	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::regex_token_iterator_impl::equal_to	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    bool equal_to(regex_token_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:(regex_token_iterator_impl<BidiIter> const &that) const
boost::xpressive::detail::regex_token_iterator_impl::iter_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_iterator_impl<BidiIter> iter_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::next	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:()
boost::xpressive::detail::regex_token_iterator_impl::n_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    int n_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::regex_token_iterator_impl	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default , std::vector<int> subs = std::vector<int>(1, 0) , int n = -2 , bool not_null = false )
boost::xpressive::detail::regex_token_iterator_impl::result_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    value_type result_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::subs_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    std::vector<int> subs_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::value_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::ReplaceAlgo	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct ReplaceAlgo$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::set	/usr/include/boost/xpressive/regex_primitives.hpp	/^detail::set_initializer_type const set = {{}};$/;"	m	class:boost::xpressive::detail
boost::xpressive::detail::sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(std::ctype_base::mask)
boost::xpressive::detail::sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
boost::xpressive::detail::sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umaskex_t)
boost::xpressive::detail::sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
boost::xpressive::detail::SkipGrammar	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct SkipGrammar$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::skip_directive	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct skip_directive$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::skip_directive::operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^        operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Expr const &expr) const
boost::xpressive::detail::skip_directive::result	/usr/include/boost/xpressive/regex_primitives.hpp	/^        struct result<This(Expr)>$/;"	s	struct:boost::xpressive::detail::skip_directive	access:public
boost::xpressive::detail::skip_directive::result::skip_transform	/usr/include/boost/xpressive/regex_primitives.hpp	/^            skip_transform;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
boost::xpressive::detail::skip_directive::result::type	/usr/include/boost/xpressive/regex_primitives.hpp	/^            type;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
boost::xpressive::detail::skip_directive::skip_	/usr/include/boost/xpressive/regex_primitives.hpp	/^        skip_type skip_;$/;"	m	struct:boost::xpressive::detail::skip_directive	access:private
boost::xpressive::detail::skip_directive::skip_directive	/usr/include/boost/xpressive/regex_primitives.hpp	/^        skip_directive(Skip const &skip)$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Skip const &skip)
boost::xpressive::detail::skip_directive::skip_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^        typedef typename proto::result_of::as_expr<Skip>::type skip_type;$/;"	t	struct:boost::xpressive::detail::skip_directive	access:public
boost::xpressive::detail::skip_primitives	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct skip_primitives : proto::transform<skip_primitives>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
boost::xpressive::detail::skip_primitives::impl	/usr/include/boost/xpressive/regex_primitives.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::skip_primitives	inherits:proto::transform_impl	access:public
boost::xpressive::detail::skip_primitives::impl::operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::skip_primitives::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param ) const
boost::xpressive::detail::skip_primitives::impl::result_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::skip_primitives::impl	access:public
boost::xpressive::detail::std::to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> const &to_vector(std::vector<int> const &subs)$/;"	f	class:boost::xpressive::detail::std	signature:(std::vector<int> const &subs)
boost::xpressive::detail::std_ctype_alnum	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = 1 << 0;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_alnum	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = mask_cast<std::ctype_base::alnum>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_alpha	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = 1 << 1;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_alpha	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = mask_cast<std::ctype_base::alpha>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_cntrl	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = 1 << 2;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_cntrl	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = mask_cast<std::ctype_base::cntrl>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_digit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = 1 << 3;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_digit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = mask_cast<std::ctype_base::digit>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_graph	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = 1 << 4;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_graph	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = mask_cast<std::ctype_base::graph>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_lower	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = 1 << 5;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_lower	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = mask_cast<std::ctype_base::lower>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_print	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = 1 << 6;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_print	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = mask_cast<std::ctype_base::print>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_punct	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = 1 << 7;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_punct	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = mask_cast<std::ctype_base::punct>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_reserved	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_reserved	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8000;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_reserved	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8200;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_space	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = 1 << 8;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_space	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = mask_cast<std::ctype_base::space>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_upper	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = 1 << 9;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_upper	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = mask_cast<std::ctype_base::upper>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_xdigit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = 1 << 10;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_xdigit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = mask_cast<std::ctype_base::xdigit>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_masks	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static umaskex_t const std_masks[] =$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::SubMatch	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct SubMatch$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::SubMatchList	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct SubMatchList$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::swap	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^void swap(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)$/;"	f	namespace:boost::xpressive::detail	signature:(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)
boost::xpressive::detail::throw_on_stack_error	/usr/include/boost/xpressive/basic_regex.hpp	/^    inline void throw_on_stack_error(bool stack_error)$/;"	f	namespace:boost::xpressive::detail	signature:(bool stack_error)
boost::xpressive::detail::to_vector	/usr/include/boost/xpressive/regex_primitives.hpp	/^    to_vector(Subs const &subs)$/;"	f	namespace:boost::xpressive::detail	signature:(Subs const &subs)
boost::xpressive::detail::to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(Int const (&sub_matches)[ Size ])$/;"	f	namespace:boost::xpressive::detail	signature:(Int const (&sub_matches)[ Size ])
boost::xpressive::detail::to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(int subs)$/;"	f	namespace:boost::xpressive::detail	signature:(int subs)
boost::xpressive::detail::to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(std::vector<Int> const &sub_matches)$/;"	f	namespace:boost::xpressive::detail	signature:(std::vector<Int> const &sub_matches)
boost::xpressive::detail::traits	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct traits$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::traits::in_range	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual bool in_range(Char from, Char to, Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char from, Char to, Char ch) const
boost::xpressive::detail::traits::tolower	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual Char tolower(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
boost::xpressive::detail::traits::toupper	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual Char toupper(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
boost::xpressive::detail::traits::value	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual int value(Char ch, int radix) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch, int radix) const
boost::xpressive::detail::traits::~traits	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual ~traits() {}$/;"	f	struct:boost::xpressive::detail::traits	access:public	signature:()
boost::xpressive::detail::traits_holder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct traits_holder$/;"	s	namespace:boost::xpressive::detail	inherits:traits
boost::xpressive::detail::traits_holder::char_type	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::traits_holder	access:public
boost::xpressive::detail::traits_holder::in_range	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    bool in_range(char_type from, char_type to, char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type from, char_type to, char_type ch) const
boost::xpressive::detail::traits_holder::tolower	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
boost::xpressive::detail::traits_holder::tolower_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
boost::xpressive::detail::traits_holder::tolower_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
boost::xpressive::detail::traits_holder::toupper	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
boost::xpressive::detail::traits_holder::toupper_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
boost::xpressive::detail::traits_holder::toupper_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
boost::xpressive::detail::traits_holder::traits	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    Traits const &traits() const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:() const
boost::xpressive::detail::traits_holder::traits_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    Traits traits_;$/;"	m	struct:boost::xpressive::detail::traits_holder	access:private
boost::xpressive::detail::traits_holder::traits_holder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    explicit traits_holder(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(Traits const &tr)
boost::xpressive::detail::traits_holder::value	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch, int radix) const
boost::xpressive::detail::umaskex_bits	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    int const umaskex_bits = (14 > (sizeof(umask_t) * CHAR_BIT)) ? 14 : sizeof(umask_t) * CHAR_BIT;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::umaskex_t	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<umaskex_bits>::fast umaskex_t;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::umask_t	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<sizeof(std::ctype_base::mask) * CHAR_BIT>::least umask_t;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::unused_mask	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::unused_mask	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask<In, Out, true>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::unused_mask::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value));$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value))
boost::xpressive::detail::unused_mask::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = Out);$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = Out)
boost::xpressive::detail::unused_mask::value	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const unused_mask<In, Out, Done>::value;$/;"	m	class:boost::xpressive::detail::unused_mask
boost::xpressive::detail::value_wrapper	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct value_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
boost::xpressive::detail::value_wrapper::value	/usr/include/boost/xpressive/regex_actions.hpp	/^            T value;$/;"	m	struct:boost::xpressive::detail::value_wrapper	access:public
boost::xpressive::detail::value_wrapper::value_wrapper	/usr/include/boost/xpressive/regex_actions.hpp	/^            value_wrapper()$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:()
boost::xpressive::detail::value_wrapper::value_wrapper	/usr/include/boost/xpressive/regex_actions.hpp	/^            value_wrapper(T const &t)$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:(T const &t)
boost::xpressive::detail::what	/usr/include/boost/xpressive/regex_algorithms.hpp	/^      , match_results<BidiIter> &what$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::_ln	/usr/include/boost/xpressive/regex_primitives.hpp	/^detail::logical_newline_xpression const _ln = {{}};$/;"	m	class:boost::xpressive::detail
boost::xpressive::function	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct function$/;"	s	namespace:boost::xpressive
boost::xpressive::function::at	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::at>::type const at = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::back	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::back>::type const back = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::first	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::first>::type const first = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::front	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::front>::type const front = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::insert	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::insert>::type const insert = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::length	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::length>::type const length = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::make_pair	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::make_pair>::type const make_pair = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::matched	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::matched>::type const matched = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::pop	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::pop>::type const pop = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::pop_back	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::pop_back>::type const pop_back = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::pop_front	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::pop_front>::type const pop_front = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::push	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::push>::type const push = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::push_back	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::push_back>::type const push_back = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::push_front	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::push_front>::type const push_front = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::second	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::second>::type const second = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::str	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::str>::type const str = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::top	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::top>::type const top = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<Fun>::type type;$/;"	t	struct:boost::xpressive::function	access:public
boost::xpressive::function::unwrap_reference	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::unwrap_reference>::type const unwrap_reference = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::has_fold_case	/usr/include/boost/xpressive/regex_traits.hpp	/^struct has_fold_case$/;"	s	namespace:boost::xpressive	inherits:is_convertible
boost::xpressive::has_fold_case	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^struct has_fold_case<cpp_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
boost::xpressive::has_fold_case	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^struct has_fold_case<c_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
boost::xpressive::icase	/usr/include/boost/xpressive/regex_primitives.hpp	/^template<typename Expr> detail::unspecified icase(Expr const &expr) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Expr const &expr)
boost::xpressive::inf	/usr/include/boost/xpressive/regex_primitives.hpp	/^unsigned int const inf = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
boost::xpressive::local	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct local$/;"	s	namespace:boost::xpressive	inherits:detail::value_wrapper,proto::terminal::type
boost::xpressive::local::base_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<reference_wrapper<T> >::type base_type;$/;"	t	struct:boost::xpressive::local	access:public
boost::xpressive::local::get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
boost::xpressive::local::get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::local	access:public	signature:() const
boost::xpressive::local::local	/usr/include/boost/xpressive/regex_actions.hpp	/^        explicit local(T const &t)$/;"	f	struct:boost::xpressive::local	access:public	signature:(T const &t)
boost::xpressive::local::local	/usr/include/boost/xpressive/regex_actions.hpp	/^        local()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
boost::xpressive::lookup_classname	/usr/include/boost/xpressive/regex_traits.hpp	/^lookup_classname(Traits const &traits, char const (&cname)[N], bool icase)$/;"	f	namespace:boost::xpressive	signature:(Traits const &traits, char const (&cname)[N], bool icase)
boost::xpressive::mark_tag	/usr/include/boost/xpressive/regex_primitives.hpp	/^struct mark_tag$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::mark_tag::base_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef proto::extends<detail::basic_mark_tag, mark_tag, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::mark_tag	access:private
boost::xpressive::mark_tag::make_tag	/usr/include/boost/xpressive/regex_primitives.hpp	/^    static detail::basic_mark_tag make_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:private	signature:(int mark_nbr)
boost::xpressive::mark_tag::mark_tag	/usr/include/boost/xpressive/regex_primitives.hpp	/^    mark_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:(int mark_nbr)
boost::xpressive::mark_tag::operator detail::basic_mark_tag const &	/usr/include/boost/xpressive/regex_primitives.hpp	/^    operator detail::basic_mark_tag const &() const$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:() const
boost::xpressive::null_regex_traits	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^struct null_regex_traits$/;"	s	namespace:boost::xpressive
boost::xpressive::null_regex_traits::char_class_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef int char_class_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::char_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef Elem char_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::getloc	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:()
boost::xpressive::null_regex_traits::hash	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::null_regex_traits::imbue	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type loc)
boost::xpressive::null_regex_traits::in_range	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::null_regex_traits::in_range_nocase	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::null_regex_traits::isctype	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
boost::xpressive::null_regex_traits::locale_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef detail::not_a_locale locale_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::lookup_classname	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
boost::xpressive::null_regex_traits::lookup_collatename	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::null_regex_traits::null_regex_traits	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    null_regex_traits(locale_type = locale_type())$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type = locale_type())
boost::xpressive::null_regex_traits::operator !=	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    bool operator !=(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
boost::xpressive::null_regex_traits::operator ==	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    bool operator ==(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
boost::xpressive::null_regex_traits::string_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef std::vector<char_type> string_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::transform	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::null_regex_traits::transform_primary	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::null_regex_traits::translate	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::null_regex_traits::translate_nocase	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::null_regex_traits::value	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static int value(char_type ch, int radix)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, int radix)
boost::xpressive::null_regex_traits::version_tag	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef regex_traits_version_1_tag version_tag;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::widen	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char ch) const
boost::xpressive::op	/usr/include/boost/xpressive/regex_actions.hpp	/^    namespace op$/;"	n	namespace:boost::xpressive
boost::xpressive::op::as	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct as$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::as::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(csub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(csub_match const &val) const
boost::xpressive::op::as::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(ssub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(ssub_match const &val) const
boost::xpressive::op::as::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(sub_match<BidiIter> const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(sub_match<BidiIter> const &val) const
boost::xpressive::op::as::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(Value const &val) const
boost::xpressive::op::as::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(wcsub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(wcsub_match const &val) const
boost::xpressive::op::as::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(wssub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(wssub_match const &val) const
boost::xpressive::op::as::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::as	access:public
boost::xpressive::op::at	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct at$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::at::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Cont::const_reference operator()(Cont const &c, Idx idx) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont const &c, Idx idx) const
boost::xpressive::op::at::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Cont::reference operator()(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const
boost::xpressive::op::at::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
boost::xpressive::op::at::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont const &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
boost::xpressive::op::at::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Idx)>$/;"	s	struct:boost::xpressive::op::at	inherits:result	access:public
boost::xpressive::op::at::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef typename Cont::const_reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
boost::xpressive::op::at::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef typename Cont::reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
boost::xpressive::op::back	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct back$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::back::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename result<back(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::back	access:public	signature:(Sequence &seq) const
boost::xpressive::op::back::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::back	access:public
boost::xpressive::op::back::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::back	access:public
boost::xpressive::op::back::result::sequence_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sequence) sequence_type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
boost::xpressive::op::back::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
boost::xpressive::op::construct	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct construct$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::construct::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()() const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:() const
boost::xpressive::op::construct::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0) const
boost::xpressive::op::construct::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1) const
boost::xpressive::op::construct::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
boost::xpressive::op::construct::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::construct	access:public
boost::xpressive::op::const_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct const_cast_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::const_cast_::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::const_cast_	access:public	signature:(Value const &val) const
boost::xpressive::op::const_cast_::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::const_cast_	access:public
boost::xpressive::op::dynamic_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct dynamic_cast_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::dynamic_cast_::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::dynamic_cast_	access:public	signature:(Value const &val) const
boost::xpressive::op::dynamic_cast_::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::dynamic_cast_	access:public
boost::xpressive::op::first	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct first$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::first::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Pair::first_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::first	access:public	signature:(Pair const &p) const
boost::xpressive::op::first::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::first	access:public
boost::xpressive::op::first::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::first	access:public
boost::xpressive::op::first::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Pair)::first_type type;$/;"	t	struct:boost::xpressive::op::first::result	access:public
boost::xpressive::op::front	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct front$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::front::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename result<front(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::front	access:public	signature:(Sequence &seq) const
boost::xpressive::op::front::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::front	access:public
boost::xpressive::op::front::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::front	access:public
boost::xpressive::op::front::result::sequence_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sequence) sequence_type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
boost::xpressive::op::front::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
boost::xpressive::op::insert	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct insert$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::insert::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0) const
boost::xpressive::op::insert::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1) const
boost::xpressive::op::insert::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const
boost::xpressive::op::insert::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, It, It), void>$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, It, Size, Value),$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, It, Value),$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Size, A0, A1),$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Size, T),$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Value), void>$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result::BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/regex_actions.hpp	/^                BOOST_STATIC_CONSTANT(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))));$/;"	p	struct:boost::xpressive::op::insert::result	access:public	signature:(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))))
boost::xpressive::op::insert::result::check_insert_return	/usr/include/boost/xpressive/regex_actions.hpp	/^                static no_type check_insert_return(std::pair<typename cont_type::iterator, bool>);$/;"	p	struct:boost::xpressive::op::insert::result	access:public	signature:(std::pair<typename cont_type::iterator, bool>)
boost::xpressive::op::insert::result::check_insert_return	/usr/include/boost/xpressive/regex_actions.hpp	/^                static yes_type check_insert_return(typename cont_type::iterator);$/;"	p	struct:boost::xpressive::op::insert::result	access:public	signature:(typename cont_type::iterator)
boost::xpressive::op::insert::result::cont_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Cont) cont_type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::no_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef char (&no_type)[2];$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::scont_	/usr/include/boost/xpressive/regex_actions.hpp	/^                static cont_type &scont_;$/;"	m	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::svalue_	/usr/include/boost/xpressive/regex_actions.hpp	/^                static value_type &svalue_;$/;"	m	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Cont) &type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Cont)::iterator type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef void type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::value_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Value) value_type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::insert::result::yes_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef char yes_type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::length	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct length$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::length::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Sub::difference_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::length	access:public	signature:(Sub const &sub) const
boost::xpressive::op::length::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::length	access:public
boost::xpressive::op::length::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::length	access:public
boost::xpressive::op::length::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sub)::difference_type type;$/;"	t	struct:boost::xpressive::op::length::result	access:public
boost::xpressive::op::make_pair	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct make_pair$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::make_pair::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            std::pair<First, Second> operator()(First const &first, Second const &second) const$/;"	f	struct:boost::xpressive::op::make_pair	access:public	signature:(First const &first, Second const &second) const
boost::xpressive::op::make_pair::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::make_pair	access:public
boost::xpressive::op::make_pair::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(First, Second)>$/;"	s	struct:boost::xpressive::op::make_pair	access:public
boost::xpressive::op::make_pair::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef std::pair<UNCVREF(First), UNCVREF(Second)> type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
boost::xpressive::op::matched	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct matched$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::matched::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            bool operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::matched	access:public	signature:(Sub const &sub) const
boost::xpressive::op::matched::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef bool result_type;$/;"	t	struct:boost::xpressive::op::matched	access:public
boost::xpressive::op::pop	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct pop$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::pop::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop	access:public	signature:(Sequence &seq) const
boost::xpressive::op::pop::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop	access:public
boost::xpressive::op::pop_back	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct pop_back$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::pop_back::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_back	access:public	signature:(Sequence &seq) const
boost::xpressive::op::pop_back::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_back	access:public
boost::xpressive::op::pop_front	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct pop_front$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::pop_front::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_front	access:public	signature:(Sequence &seq) const
boost::xpressive::op::pop_front::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_front	access:public
boost::xpressive::op::push	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct push$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::push::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push	access:public	signature:(Sequence &seq, Value const &val) const
boost::xpressive::op::push::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push	access:public
boost::xpressive::op::push_back	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct push_back$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::push_back::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_back	access:public	signature:(Sequence &seq, Value const &val) const
boost::xpressive::op::push_back::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_back	access:public
boost::xpressive::op::push_front	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct push_front$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::push_front::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_front	access:public	signature:(Sequence &seq, Value const &val) const
boost::xpressive::op::push_front::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_front	access:public
boost::xpressive::op::second	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct second$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::second::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Pair::second_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::second	access:public	signature:(Pair const &p) const
boost::xpressive::op::second::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::second	access:public
boost::xpressive::op::second::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::second	access:public
boost::xpressive::op::second::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Pair)::second_type type;$/;"	t	struct:boost::xpressive::op::second::result	access:public
boost::xpressive::op::static_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct static_cast_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::static_cast_::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::static_cast_	access:public	signature:(Value const &val) const
boost::xpressive::op::static_cast_::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::static_cast_	access:public
boost::xpressive::op::str	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct str$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::str::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Sub::string_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::str	access:public	signature:(Sub const &sub) const
boost::xpressive::op::str::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::str	access:public
boost::xpressive::op::str::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::str	access:public
boost::xpressive::op::str::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sub)::string_type type;$/;"	t	struct:boost::xpressive::op::str::result	access:public
boost::xpressive::op::throw_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct throw_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::throw_::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()() const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:() const
boost::xpressive::op::throw_::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0) const
boost::xpressive::op::throw_::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1) const
boost::xpressive::op::throw_::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
boost::xpressive::op::throw_::result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::throw_	access:public
boost::xpressive::op::top	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct top$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::top::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename result<top(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::top	access:public	signature:(Sequence &seq) const
boost::xpressive::op::top::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::top	access:public
boost::xpressive::op::top::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::top	access:public
boost::xpressive::op::top::result::sequence_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sequence) sequence_type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
boost::xpressive::op::top::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
boost::xpressive::op::unwrap_reference	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct unwrap_reference$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::unwrap_reference::operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T &operator()(boost::reference_wrapper<T> r) const$/;"	f	struct:boost::xpressive::op::unwrap_reference	access:public	signature:(boost::reference_wrapper<T> r) const
boost::xpressive::op::unwrap_reference::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Ref &)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
boost::xpressive::op::unwrap_reference::result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Ref)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
boost::xpressive::op::unwrap_reference::result::type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef typename boost::unwrap_reference<Ref>::type &type;$/;"	t	struct:boost::xpressive::op::unwrap_reference::result	access:public
boost::xpressive::placeholder	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct placeholder$/;"	s	namespace:boost::xpressive
boost::xpressive::placeholder::action_arg_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<detail::action_arg<T, mpl::int_<I> > >::type action_arg_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
boost::xpressive::placeholder::this_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef placeholder<T, I, Dummy> this_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
boost::xpressive::proto::functional::as_xpr	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::functional::as_expr<> const as_xpr = {};$/;"	m	class:boost::xpressive::proto::functional
boost::xpressive::proto::result_of::make_expr::after	/usr/include/boost/xpressive/regex_primitives.hpp	/^after(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::before	/usr/include/boost/xpressive/regex_primitives.hpp	/^before(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::keep	/usr/include/boost/xpressive/regex_primitives.hpp	/^keep(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::optional	/usr/include/boost/xpressive/regex_primitives.hpp	/^optional(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::repeat	/usr/include/boost/xpressive/regex_primitives.hpp	/^repeat(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::repeat	/usr/include/boost/xpressive/regex_primitives.hpp	/^repeat(Expr2 const &expr2)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr2 const &expr2)
boost::xpressive::proto::terminal::a1	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<1> > >::type const a1 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a2	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<2> > >::type const a2 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a3	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<3> > >::type const a3 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a4	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<4> > >::type const a4 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a5	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<5> > >::type const a5 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a6	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<6> > >::type const a6 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a7	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<7> > >::type const a7 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a8	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<8> > >::type const a8 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a9	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<9> > >::type const a9 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::alnum	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alnum = {{"alnum", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::alpha	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alpha = {{"alpha", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::blank	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const blank = {{"blank", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::bol	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bol_placeholder>::type const bol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::bos	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bos_matcher>::type const bos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::bow	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_begin>::type const bow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::by_ref	/usr/include/boost/xpressive/regex_primitives.hpp	/^by_ref(basic_regex<BidiIter> const &rex)$/;"	f	class:boost::xpressive::proto::terminal	signature:(basic_regex<BidiIter> const &rex)
boost::xpressive::proto::terminal::check	/usr/include/boost/xpressive/regex_actions.hpp	/^    proto::terminal<detail::check_tag>::type const check = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::cntrl	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const cntrl = {{"cntrl", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::digit	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const digit = {{"digit", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::eol	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eol_placeholder>::type const eol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::eos	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eos_matcher>::type const eos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::eow	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_end>::type const eow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::epsilon	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const epsilon = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::graph	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const graph = {{"graph", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::lower	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const lower = {{"lower", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::nil	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const nil = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::print	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const print = {{"print", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::punct	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const punct = {{"punct", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::range	/usr/include/boost/xpressive/regex_primitives.hpp	/^range(Char ch_min, Char ch_max)$/;"	f	class:boost::xpressive::proto::terminal	signature:(Char ch_min, Char ch_max)
boost::xpressive::proto::terminal::self	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::self_placeholder>::type const self = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::space	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const space = {{"space", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::upper	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const upper = {{"upper", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::xdigit	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const xdigit = {{"xdigit", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::any_matcher>::type const _ = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_b	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_boundary>::type const _b = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_d	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _d = {{"d", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_n	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<char>::type const _n = {'\\n'};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_s	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _s = {{"s", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_w	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _w = {{"w", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::ref	/usr/include/boost/xpressive/regex_actions.hpp	/^    reference<T> const ref(T &t)$/;"	f	namespace:boost::xpressive	signature:(T &t)
boost::xpressive::reference	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct reference$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::reference::base_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<reference_wrapper<T> >::type, reference<T> > base_type;$/;"	t	struct:boost::xpressive::reference	access:public
boost::xpressive::reference::get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T &get() const$/;"	f	struct:boost::xpressive::reference	access:public	signature:() const
boost::xpressive::reference::reference	/usr/include/boost/xpressive/regex_actions.hpp	/^        explicit reference(T &t)$/;"	f	struct:boost::xpressive::reference	access:public	signature:(T &t)
boost::xpressive::regex_compiler	/usr/include/boost/xpressive/regex_compiler.hpp	/^struct regex_compiler$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_compiler::alternate_matcher	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef detail::alternate_matcher<detail::alternates_vector<BidiIter>, RegexTraits> alternate_matcher;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::char_class_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename traits_type::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::char_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile(char_type const *begin, std::size_t size, flag_type flags)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, std::size_t size, flag_type flags)
boost::xpressive::regex_compiler::compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::regex_compiler::compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::regex_compiler::compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::regex_compiler::compile_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)
boost::xpressive::regex_compiler::compile_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)
boost::xpressive::regex_compiler::escape_value	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef detail::escape_value<char_type, char_class_type> escape_value;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::flag_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::getloc	/usr/include/boost/xpressive/regex_compiler.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:() const
boost::xpressive::regex_compiler::hidden_mark_count_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::imbue	/usr/include/boost/xpressive/regex_compiler.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(locale_type loc)
boost::xpressive::regex_compiler::is_upper_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    bool is_upper_(char_type ch) const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(char_type ch) const
boost::xpressive::regex_compiler::iterator_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::locale_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename traits_type::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::mark_count_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::operator []	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> &operator [](string_type const &name)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name)
boost::xpressive::regex_compiler::operator []	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> const &operator [](string_type const &name) const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name) const
boost::xpressive::regex_compiler::parse_alternates	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_alternates(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_atom	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_atom(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_charset	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_charset(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_escape	/usr/include/boost/xpressive/regex_compiler.hpp	/^    escape_value parse_escape(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_group	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_group(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_literal	/usr/include/boost/xpressive/regex_compiler.hpp	/^    string_type parse_literal(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_quant	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_quant(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_quote_meta	/usr/include/boost/xpressive/regex_compiler.hpp	/^    string_type parse_quote_meta(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_sequence	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_sequence(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::regex_compiler	/usr/include/boost/xpressive/regex_compiler.hpp	/^    explicit regex_compiler(RegexTraits const &traits = RegexTraits())$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(RegexTraits const &traits = RegexTraits())
boost::xpressive::regex_compiler::reset	/usr/include/boost/xpressive/regex_compiler.hpp	/^    void reset()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
boost::xpressive::regex_compiler::rules_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    std::map<string_type, basic_regex<BidiIter> > rules_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::rxtraits	/usr/include/boost/xpressive/regex_compiler.hpp	/^    traits_type &rxtraits()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
boost::xpressive::regex_compiler::rxtraits	/usr/include/boost/xpressive/regex_compiler.hpp	/^    traits_type const &rxtraits() const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:() const
boost::xpressive::regex_compiler::self_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    shared_ptr<detail::regex_impl<BidiIter> > self_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::string_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename traits_type::string_type string_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::traits_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    CompilerTraits traits_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::traits_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef RegexTraits traits_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::upper_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typename RegexTraits::char_class_type upper_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_constants	/usr/include/boost/xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
boost::xpressive::regex_constants::basic_regex::collate	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::collate;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::ECMAScript	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ECMAScript;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::icase	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::icase;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::ignore_white_space	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ignore_white_space;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::nosubs	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::nosubs;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::not_dot_newline	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_newline;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::not_dot_null	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_null;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::optimize	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::optimize;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::single_line	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::single_line;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::collate	/usr/include/boost/xpressive/regex_constants.hpp	/^    collate     = 1 << 4,   \/\/\/< Specifies that character ranges of the form "[a-b]" should be$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::ECMAScript	/usr/include/boost/xpressive/regex_constants.hpp	/^    ECMAScript  = 0,        \/\/\/< Specifies that the grammar recognized by the regular expression$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::error_badarg	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badarg,               \/\/\/< An argument to an action was unbound.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badattr	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badattr,              \/\/\/< Tried to read from an uninitialized attribute.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badbrace	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badbrace,             \/\/\/< The expression contained an invalid range in a {} expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badlookbehind	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badlookbehind,        \/\/\/< An attempt to create a variable-width look-behind assertion$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badmark	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badmark,              \/\/\/< An invalid use of a named capture.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badref	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badref,               \/\/\/< An nested regex is uninitialized.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badrepeat	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badrepeat,            \/\/\/< One of *?+{ was not preceded by a valid regular expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badrule	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badrule,              \/\/\/< An invalid use of a rule was detected.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_brace	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_brace,                \/\/\/< The expression contained mismatched { and }.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_brack	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_brack,                \/\/\/< The expression contained mismatched [ and ].$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_collate	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_collate,              \/\/\/< The expression contained an invalid collating element name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_complexity	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_complexity,           \/\/\/< The complexity of an attempted match against a regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_ctype	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_ctype,                \/\/\/< The expression contained an invalid character class name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_escape	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_escape,               \/\/\/< The expression contained an invalid escaped character,$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_internal	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_internal              \/\/\/< An internal error has occurred.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_paren	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_paren,                \/\/\/< The expression contained mismatched ( and ).$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_range	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_range,                \/\/\/< The expression contained an invalid character range, for$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_space	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_space,                \/\/\/< There was insufficient memory to convert the expression into a$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_stack	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_stack,                \/\/\/< There was insufficient memory to determine whether the regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_subreg	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_subreg,               \/\/\/< The expression contained an invalid back-reference.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_type	/usr/include/boost/xpressive/regex_constants.hpp	/^enum error_type$/;"	g	namespace:boost::xpressive::regex_constants
boost::xpressive::regex_constants::format_all	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_all              = 1 << 18   \/\/\/< Specifies that all syntax extensions are enabled,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_default	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_default          = 0,        \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_first_only	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_first_only       = 1 << 16,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_literal	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_literal          = 1 << 17,  \/\/\/< Treat the format string as a literal.$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_no_copy	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_no_copy          = 1 << 15,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_perl	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_perl             = 1 << 14,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_sed	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_sed              = 1 << 13,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::icase	/usr/include/boost/xpressive/regex_constants.hpp	/^    icase       = 1 << 1,   \/\/\/< Specifies that matching of regular expressions against a character$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::ignore_white_space	/usr/include/boost/xpressive/regex_constants.hpp	/^    ignore_white_space  = 1 << 13   \/\/\/< Specifies that non-escaped white-space is not significant.$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::match_any	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_any               = 1 << 7,   \/\/\/< Specifies that if more than one match is possible then$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_continuous	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_continuous        = 1 << 10,  \/\/\/< Specifies that the expression must match a sub-sequence$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_default	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_default           = 0,        \/\/\/< Specifies that matching of regular expressions proceeds$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_flag_type	/usr/include/boost/xpressive/regex_constants.hpp	/^enum match_flag_type$/;"	g	namespace:boost::xpressive::regex_constants
boost::xpressive::regex_constants::match_not_bol	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_bol           = 1 << 1,   \/\/\/< Specifies that the expression "^" should not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_bow	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_bow           = 1 << 3,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_eol	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_eol           = 1 << 2,   \/\/\/< Specifies that the expression "\\$" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_eow	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_eow           = 1 << 4,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_null	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_null          = 1 << 8,   \/\/\/< Specifies that the expression can not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_partial	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_partial           = 1 << 11,  \/\/\/< Specifies that if no match can be found, then it is$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_prev_avail	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_prev_avail        = 1 << 12,  \/\/\/< Specifies that --first is a valid iterator position,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::nosubs	/usr/include/boost/xpressive/regex_constants.hpp	/^    nosubs      = 1 << 2,   \/\/\/< Specifies that when a regular expression is matched against a$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::not_dot_newline	/usr/include/boost/xpressive/regex_constants.hpp	/^    not_dot_newline     = 1 << 12,  \/\/\/< Specifies that the . metacharacter does not match the$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::not_dot_null	/usr/include/boost/xpressive/regex_constants.hpp	/^    not_dot_null        = 1 << 11,  \/\/\/< Specifies that the . metacharacter does not match the null$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::operator &	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator &(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
boost::xpressive::regex_constants::operator &	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator &(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
boost::xpressive::regex_constants::operator ^	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator ^(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
boost::xpressive::regex_constants::operator ^	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator ^(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
boost::xpressive::regex_constants::operator |	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator |(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
boost::xpressive::regex_constants::operator |	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator |(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
boost::xpressive::regex_constants::operator ~	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator ~(match_flag_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b)
boost::xpressive::regex_constants::operator ~	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator ~(syntax_option_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b)
boost::xpressive::regex_constants::optimize	/usr/include/boost/xpressive/regex_constants.hpp	/^    optimize    = 1 << 3,   \/\/\/< Specifies that the regular expression engine should pay more$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::single_line	/usr/include/boost/xpressive/regex_constants.hpp	/^    single_line         = 1 << 10,  \/\/\/< Specifies that the ^ and \\$ metacharacters DO NOT match at$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::syntax_option_type	/usr/include/boost/xpressive/regex_constants.hpp	/^enum syntax_option_type$/;"	g	namespace:boost::xpressive::regex_constants
boost::xpressive::regex_error	/usr/include/boost/xpressive/regex_error.hpp	/^struct regex_error$/;"	s	namespace:boost::xpressive	inherits:std::runtime_error,boost::exception
boost::xpressive::regex_error::code	/usr/include/boost/xpressive/regex_error.hpp	/^    regex_constants::error_type code() const$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:() const
boost::xpressive::regex_error::code_	/usr/include/boost/xpressive/regex_error.hpp	/^    regex_constants::error_type code_;$/;"	m	struct:boost::xpressive::regex_error	access:private
boost::xpressive::regex_error::regex_error	/usr/include/boost/xpressive/regex_error.hpp	/^    explicit regex_error(regex_constants::error_type code, char const *str = "")$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:(regex_constants::error_type code, char const *str = )
boost::xpressive::regex_error::~regex_error	/usr/include/boost/xpressive/regex_error.hpp	/^    virtual ~regex_error() throw()$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:()
boost::xpressive::regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^struct regex_iterator$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_iterator::difference_type	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::fork_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
boost::xpressive::regex_iterator::impl_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_iterator	access:private
boost::xpressive::regex_iterator::impl_type_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef detail::regex_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::iterator_category	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::next_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
boost::xpressive::regex_iterator::operator !=	/usr/include/boost/xpressive/regex_iterator.hpp	/^    friend bool operator !=(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
boost::xpressive::regex_iterator::operator *	/usr/include/boost/xpressive/regex_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
boost::xpressive::regex_iterator::operator ++	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
boost::xpressive::regex_iterator::operator ++	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(int)
boost::xpressive::regex_iterator::operator ->	/usr/include/boost/xpressive/regex_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
boost::xpressive::regex_iterator::operator =	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator =(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
boost::xpressive::regex_iterator::operator ==	/usr/include/boost/xpressive/regex_iterator.hpp	/^    friend bool operator ==(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
boost::xpressive::regex_iterator::pointer	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::reference	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_iterator::regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_iterator::regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
boost::xpressive::regex_iterator::regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
boost::xpressive::regex_iterator::regex_type	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::value_type	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef match_results<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_token_iterator::char_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::difference_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::fork_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
boost::xpressive::regex_token_iterator::impl_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_token_iterator	access:private
boost::xpressive::regex_token_iterator::impl_type_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef detail::regex_token_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::iterator_category	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::next_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
boost::xpressive::regex_token_iterator::operator !=	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    friend bool operator !=(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
boost::xpressive::regex_token_iterator::operator *	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
boost::xpressive::regex_token_iterator::operator ++	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
boost::xpressive::regex_token_iterator::operator ++	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(int)
boost::xpressive::regex_token_iterator::operator ->	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
boost::xpressive::regex_token_iterator::operator =	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator =(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
boost::xpressive::regex_token_iterator::operator ==	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    friend bool operator ==(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
boost::xpressive::regex_token_iterator::pointer	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::reference	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex )
boost::xpressive::regex_token_iterator::regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args )
boost::xpressive::regex_token_iterator::regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_token_iterator::regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_token_iterator::regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
boost::xpressive::regex_token_iterator::regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
boost::xpressive::regex_token_iterator::regex_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::value_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_traits	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits$/;"	s	namespace:boost::xpressive	inherits:Impl
boost::xpressive::regex_traits::locale_type	/usr/include/boost/xpressive/regex_traits.hpp	/^    typedef typename Impl::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_traits	access:public
boost::xpressive::regex_traits::regex_traits	/usr/include/boost/xpressive/regex_traits.hpp	/^    explicit regex_traits(locale_type const &loc)$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:(locale_type const &loc)
boost::xpressive::regex_traits::regex_traits	/usr/include/boost/xpressive/regex_traits.hpp	/^    regex_traits()$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:()
boost::xpressive::regex_traits_version_1_case_fold_tag	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits_version_1_case_fold_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
boost::xpressive::regex_traits_version_1_tag	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits_version_1_tag$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_traits_version_2_tag	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits_version_2_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
boost::xpressive::repeat_max	/usr/include/boost/xpressive/regex_primitives.hpp	/^unsigned int const repeat_max = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
boost::xpressive::skip	/usr/include/boost/xpressive/regex_primitives.hpp	/^detail::skip_directive<Skip> skip(Skip const &skip)$/;"	f	namespace:boost::xpressive	signature:(Skip const &skip)
boost::xpressive::swap	/usr/include/boost/xpressive/basic_regex.hpp	/^inline void swap(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right) \/\/ throw()$/;"	f	namespace:boost::xpressive	signature:(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right)
boost::xpressive::val	/usr/include/boost/xpressive/regex_actions.hpp	/^    value<T> const val(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
boost::xpressive::value	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct value$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::value::base_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<T>::type, value<T> > base_type;$/;"	t	struct:boost::xpressive::value	access:public
boost::xpressive::value::get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
boost::xpressive::value::get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::value	access:public	signature:() const
boost::xpressive::value::value	/usr/include/boost/xpressive/regex_actions.hpp	/^        explicit value(T const &t)$/;"	f	struct:boost::xpressive::value	access:public	signature:(T const &t)
boost::xpressive::value::value	/usr/include/boost/xpressive/regex_actions.hpp	/^        value()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
boost::__anon3::eflags	/usr/include/boost/regex/v4/cregex.hpp	/^   match_flag_type eflags;        \/* none of your business :-) *\/$/;"	m	struct:boost::__anon3	access:public
boost::__anon3::guts	/usr/include/boost/regex/v4/cregex.hpp	/^   void* guts;                \/* none of your business :-) *\/$/;"	m	struct:boost::__anon3	access:public
boost::__anon3::re_endp	/usr/include/boost/regex/v4/cregex.hpp	/^   const char*  re_endp;       \/* end pointer for REG_PEND *\/$/;"	m	struct:boost::__anon3	access:public
boost::__anon3::re_magic	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int re_magic;$/;"	m	struct:boost::__anon3	access:public
boost::__anon3::re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   size_t re_nsub; $/;"	m	struct:boost::__anon3	access:public
boost::__anon3::re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t  re_nsub;      \/* number of parenthesized subexpressions *\/$/;"	m	struct:boost::__anon3	access:public
boost::__anon4::eflags	/usr/include/boost/regex/v4/cregex.hpp	/^   match_flag_type eflags;           \/* none of your business :-) *\/$/;"	m	struct:boost::__anon4	access:public
boost::__anon4::guts	/usr/include/boost/regex/v4/cregex.hpp	/^   void* guts;                   \/* none of your business :-) *\/$/;"	m	struct:boost::__anon4	access:public
boost::__anon4::re_endp	/usr/include/boost/regex/v4/cregex.hpp	/^   const wchar_t* re_endp;       \/* end pointer for REG_PEND *\/$/;"	m	struct:boost::__anon4	access:public
boost::__anon4::re_magic	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int re_magic;$/;"	m	struct:boost::__anon4	access:public
boost::__anon4::re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   size_t re_nsub;$/;"	m	struct:boost::__anon4	access:public
boost::__anon4::re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t  re_nsub;         \/* number of parenthesized subexpressions *\/$/;"	m	struct:boost::__anon4	access:public
boost::__anon5::rm_eo	/usr/include/boost/regex/v4/cregex.hpp	/^   regoff_t rm_eo;      \/* end of match *\/$/;"	m	struct:boost::__anon5	access:public
boost::__anon5::rm_so	/usr/include/boost/regex/v4/cregex.hpp	/^   regoff_t rm_so;      \/* start of match *\/$/;"	m	struct:boost::__anon5	access:public
BoostRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BoostRegexConcept();$/;"	p	struct:boost::BoostRegexConcept	access:public	signature:()
BoostRegexConcept	/usr/include/boost/regex/concepts.hpp	/^   BoostRegexConcept(const BoostRegexConcept&);$/;"	p	struct:boost::BoostRegexConcept	access:public	signature:(const BoostRegexConcept&)
BoostRegexConcept	/usr/include/boost/regex/concepts.hpp	/^struct BoostRegexConcept$/;"	s	namespace:boost
BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^inline boost::shared_ptr<const cpp_regex_traits_implementation<charT> > create_cpp_regex_traits(const std::locale& l BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(charT))$/;"	f	namespace:boost::re_detail	signature:(charT)
BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^boost::shared_ptr<const w32_regex_traits_implementation<charT> > create_w32_regex_traits(::boost::re_detail::lcid_type l BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(charT))$/;"	f	namespace:boost::re_detail	signature:(charT)
BOOST_ASIO_DETAIL_REGEX_FWD_HPP	/usr/include/boost/asio/detail/regex_fwd.hpp	12;"	d
BOOST_ASIO_SYSTEM_TIMER_HPP	/usr/include/boost/asio/system_timer.hpp	12;"	d
BOOST_CHRONO_DETAIL_SYSTEM_HPP	/usr/include/boost/chrono/detail/system.hpp	7;"	d
BOOST_CHRONO_IS_THROWS	/usr/include/boost/chrono/detail/system.hpp	20;"	d
BOOST_CHRONO_IS_THROWS	/usr/include/boost/chrono/detail/system.hpp	23;"	d
BOOST_CHRONO_SYSTEM_CATEGORY	/usr/include/boost/chrono/detail/system.hpp	13;"	d
BOOST_CHRONO_SYSTEM_CATEGORY	/usr/include/boost/chrono/detail/system.hpp	15;"	d
BOOST_CHRONO_SYSTEM_CLOCKS_HPP	/usr/include/boost/chrono/system_clocks.hpp	60;"	d
BOOST_CHRONO_THROWS	/usr/include/boost/chrono/detail/system.hpp	19;"	d
BOOST_CHRONO_THROWS	/usr/include/boost/chrono/detail/system.hpp	22;"	d
BOOST_CPP_REGEX_TRAITS_HPP_INCLUDED	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	20;"	d
BOOST_CYGWIN_ERROR_HPP	/usr/include/boost/system/cygwin_error.hpp	11;"	d
BOOST_C_REGEX_TRAITS_HPP_INCLUDED	/usr/include/boost/regex/v4/c_regex_traits.hpp	20;"	d
BOOST_DETAIL_WIN_SYSTEM_HPP	/usr/include/boost/detail/win/system.hpp	10;"	d
BOOST_DYN_LINK	/usr/include/boost/filesystem/config.hpp	101;"	d
BOOST_DYN_LINK	/usr/include/boost/regex/config.hpp	210;"	d
BOOST_DYN_LINK	/usr/include/boost/system/config.hpp	60;"	d
BOOST_ERROR_CODE_HPP	/usr/include/boost/system/error_code.hpp	12;"	d
boost_extensions_tag	/usr/include/boost/regex/icu.hpp	/^   struct boost_extensions_tag{};$/;"	s	class:boost::icu_regex_traits	access:public
boost_extensions_tag	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   struct boost_extensions_tag{};$/;"	s	class:boost::cpp_regex_traits	access:public
boost_extensions_tag	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   struct boost_extensions_tag{};$/;"	s	class:boost::w32_regex_traits	access:public
BOOST_FILESYSTEM3_CONFIG_HPP	/usr/include/boost/filesystem/config.hpp	13;"	d
BOOST_FILESYSTEM3_CONVENIENCE_HPP	/usr/include/boost/filesystem/convenience.hpp	14;"	d
BOOST_FILESYSTEM3_FSTREAM_HPP	/usr/include/boost/filesystem/fstream.hpp	13;"	d
BOOST_FILESYSTEM3_OPERATIONS_HPP	/usr/include/boost/filesystem/operations.hpp	16;"	d
BOOST_FILESYSTEM_C_STR	/usr/include/boost/filesystem/fstream.hpp	32;"	d
BOOST_FILESYSTEM_C_STR	/usr/include/boost/filesystem/fstream.hpp	34;"	d
BOOST_FILESYSTEM_DECL	/usr/include/boost/filesystem/config.hpp	80;"	d
BOOST_FILESYSTEM_DECL	/usr/include/boost/filesystem/config.hpp	82;"	d
BOOST_FILESYSTEM_DECL	/usr/include/boost/filesystem/config.hpp	85;"	d
BOOST_FILESYSTEM_DEPRECATED	/usr/include/boost/filesystem/config.hpp	35;"	d
BOOST_FILESYSTEM_DYN_LINK	/usr/include/boost/filesystem/config.hpp	63;"	d
BOOST_FILESYSTEM_FILESYSTEM_HPP	/usr/include/boost/filesystem.hpp	13;"	d
BOOST_FILESYSTEM_I18N	/usr/include/boost/filesystem/config.hpp	23;"	d
BOOST_FILESYSTEM_NO_LIB	/usr/include/boost/filesystem/config.hpp	73;"	d
BOOST_FILESYSTEM_PATH_HPP	/usr/include/boost/filesystem/path.hpp	16;"	d
BOOST_FILESYSTEM_PATH_TRAITS_HPP	/usr/include/boost/filesystem/path_traits.hpp	11;"	d
BOOST_FILESYSTEM_STATIC_LINK	/usr/include/boost/filesystem/config.hpp	59;"	d
BOOST_FILESYSTEM_STATIC_LINK	/usr/include/boost/filesystem/config.hpp	65;"	d
BOOST_FILESYSTEM_THROW	/usr/include/boost/filesystem/config.hpp	46;"	d
BOOST_FILESYSTEM_UTF8_CODECVT_FACET_HPP	/usr/include/boost/filesystem/detail/utf8_codecvt_facet.hpp	8;"	d
BOOST_FILESYSTEM_VERSION	/usr/include/boost/filesystem/config.hpp	20;"	d
BOOST_GEOMETRY_CORE_COORDINATE_SYSTEM_HPP	/usr/include/boost/geometry/core/coordinate_system.hpp	15;"	d
BOOST_IOSTREAMS_DETAIL_SYSTEM_FAILURE_HPP_INCLUDED	/usr/include/boost/iostreams/detail/system_failure.hpp	12;"	d
BOOST_IOSTREAMS_REGEX_FILTER_HPP_INCLUDED	/usr/include/boost/iostreams/filter/regex.hpp	9;"	d
BOOST_LIB_DIAGNOSTIC	/usr/include/boost/regex/config.hpp	213;"	d
BOOST_LIB_NAME	/usr/include/boost/filesystem/config.hpp	96;"	d
BOOST_LIB_NAME	/usr/include/boost/regex/config.hpp	208;"	d
BOOST_LIB_NAME	/usr/include/boost/system/config.hpp	55;"	d
BOOST_LINUX_ERROR_HPP	/usr/include/boost/system/linux_error.hpp	11;"	d
BOOST_MPL_ASSERT_MSG	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    BOOST_MPL_ASSERT_MSG$/;"	p	struct:boost::geometry::traits::coordinate_system	access:public	signature:( false, NOT_IMPLEMENTED_FOR_THIS_POINT_TYPE, (types<Point>) )
BOOST_MPL_ASSERT_MSG	/usr/include/boost/units/heterogeneous_system.hpp	/^    BOOST_MPL_ASSERT_MSG((!boost::is_same<exponents, inconsistent>::value), the_specified_dimension_is_not_representible_in_the_given_system, (types<Dimensions, System>));$/;"	p	struct:boost::units::detail::make_heterogeneous_system	access:public	signature:(!boost::is_same<exponents, inconsistent>::value), the_specified_dimension_is_not_representible_in_the_given_system, (types<Dimensions, System>)
BOOST_MSVC	/usr/include/boost/regex/config.hpp	54;"	d
BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE std::time_t to_time_t(const time_point& t) BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::system_clock	access:public
BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  from_time_t(std::time_t t) BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::system_clock	access:public
BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now() BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::steady_clock	access:public
BOOST_NOEXCEPT	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now() BOOST_NOEXCEPT;$/;"	m	class:boost::chrono::system_clock	access:public
BOOST_NOEXCEPT	/usr/include/boost/filesystem/path.hpp	/^    int compare(const path& p) const BOOST_NOEXCEPT;  \/\/ generic, lexicographical$/;"	m	class:boost::filesystem::path	access:public
BOOST_NO_WREGEX	/usr/include/boost/regex/config.hpp	108;"	d
BOOST_POSIX_API	/usr/include/boost/system/api_config.hpp	39;"	d
BOOST_PROTO_LOCAL_a	/usr/include/boost/xpressive/regex_actions.hpp	936;"	d
BOOST_PROTO_LOCAL_LIMITS	/usr/include/boost/xpressive/regex_actions.hpp	937;"	d
BOOST_PROTO_LOCAL_MACRO	/usr/include/boost/xpressive/regex_actions.hpp	919;"	d
BOOST_REGEX_BLOCKSIZE	/usr/include/boost/regex/config.hpp	363;"	d
BOOST_REGEX_BUGGY_CTYPE_FACET	/usr/include/boost/regex/config.hpp	79;"	d
BOOST_REGEX_BUILD_DLL	/usr/include/boost/regex/config.hpp	199;"	d
BOOST_REGEX_CALL	/usr/include/boost/regex/config.hpp	226;"	d
BOOST_REGEX_CALL	/usr/include/boost/regex/config.hpp	228;"	d
BOOST_REGEX_CALL	/usr/include/boost/regex/config.hpp	234;"	d
BOOST_REGEX_CALL	/usr/include/boost/regex/config.hpp	239;"	d
BOOST_REGEX_CCALL	/usr/include/boost/regex/config.hpp	230;"	d
BOOST_REGEX_CCALL	/usr/include/boost/regex/config.hpp	235;"	d
BOOST_REGEX_CCALL	/usr/include/boost/regex/config.hpp	242;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/icu.hpp	219;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/icu.hpp	227;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/v4/regex.hpp	104;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/v4/regex.hpp	109;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/v4/regex.hpp	116;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/v4/regex.hpp	121;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/v4/regex.hpp	93;"	d
BOOST_REGEX_CHAR_T	/usr/include/boost/regex/v4/regex.hpp	98;"	d
BOOST_REGEX_CONCEPTS_HPP_INCLUDED	/usr/include/boost/regex/concepts.hpp	20;"	d
BOOST_REGEX_CONFIG_CWCHAR_HPP	/usr/include/boost/regex/config/cwchar.hpp	20;"	d
BOOST_REGEX_CONFIG_HPP	/usr/include/boost/regex/config.hpp	20;"	d
BOOST_REGEX_DECL	/usr/include/boost/regex/config.hpp	198;"	d
BOOST_REGEX_DECL	/usr/include/boost/regex/config.hpp	201;"	d
BOOST_REGEX_DECL	/usr/include/boost/regex/config.hpp	204;"	d
BOOST_REGEX_ERROR_TYPE_HPP	/usr/include/boost/regex/v4/error_type.hpp	20;"	d
BOOST_REGEX_FI_POSIX_DIR	/usr/include/boost/regex/v4/fileiter.hpp	34;"	d
BOOST_REGEX_FI_POSIX_DIR	/usr/include/boost/regex/v4/fileiter.hpp	40;"	d
BOOST_REGEX_FI_POSIX_MAP	/usr/include/boost/regex/v4/fileiter.hpp	39;"	d
BOOST_REGEX_FI_WIN32_DIR	/usr/include/boost/regex/v4/fileiter.hpp	37;"	d
BOOST_REGEX_FI_WIN32_MAP	/usr/include/boost/regex/v4/fileiter.hpp	33;"	d
BOOST_REGEX_FI_WIN32_MAP	/usr/include/boost/regex/v4/fileiter.hpp	36;"	d
BOOST_REGEX_FORMAT_HPP	/usr/include/boost/regex/v4/regex_format.hpp	22;"	d
BOOST_REGEX_FWD_HPP	/usr/include/boost/regex_fwd.hpp	21;"	d
BOOST_REGEX_FWD_HPP_INCLUDED	/usr/include/boost/regex/v4/regex_fwd.hpp	21;"	d
BOOST_REGEX_HAS_MS_STACK_GUARD	/usr/include/boost/regex/config.hpp	325;"	d
BOOST_REGEX_HAS_MS_STACK_GUARD	/usr/include/boost/regex/config.hpp	328;"	d
BOOST_REGEX_HAS_MS_STACK_GUARD	/usr/include/boost/regex/config.hpp	372;"	d
BOOST_REGEX_HAS_OTHER_WCHAR_T	/usr/include/boost/regex/config.hpp	170;"	d
BOOST_REGEX_ICU_HPP	/usr/include/boost/regex/icu.hpp	20;"	d
BOOST_REGEX_ICU_INSTANCES	/usr/include/boost/regex/icu.hpp	222;"	d
BOOST_REGEX_ICU_INSTANCES	/usr/include/boost/regex/icu.hpp	229;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/icu.hpp	224;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/icu.hpp	231;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/v4/regex.hpp	100;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/v4/regex.hpp	106;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/v4/regex.hpp	111;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/v4/regex.hpp	118;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/v4/regex.hpp	123;"	d
BOOST_REGEX_INSTANTIATE	/usr/include/boost/regex/v4/regex.hpp	95;"	d
BOOST_REGEX_ITERATOR_CATEGORY_HPP	/usr/include/boost/regex/v4/iterator_category.hpp	22;"	d
BOOST_REGEX_MAKE_BOOL	/usr/include/boost/regex/v4/regex_workaround.hpp	67;"	d
BOOST_REGEX_MATCHER_HPP	/usr/include/boost/regex/v4/perl_matcher.hpp	13;"	d
BOOST_REGEX_MATCH_HPP	/usr/include/boost/regex/v4/regex_match.hpp	23;"	d
BOOST_REGEX_MAX_BLOCKS	/usr/include/boost/regex/config.hpp	369;"	d
BOOST_REGEX_MAX_CACHE_BLOCKS	/usr/include/boost/regex/config.hpp	375;"	d
BOOST_REGEX_MAX_STATE_COUNT	/usr/include/boost/regex/config.hpp	278;"	d
BOOST_REGEX_MFC_HPP	/usr/include/boost/regex/mfc.hpp	20;"	d
BOOST_REGEX_NOEH_ASSERT	/usr/include/boost/regex/config.hpp	297;"	d
BOOST_REGEX_NOEH_ASSERT	/usr/include/boost/regex/config.hpp	310;"	d
BOOST_REGEX_NO_EXTERNAL_TEMPLATES	/usr/include/boost/regex/config.hpp	87;"	d
BOOST_REGEX_NO_EXTERNAL_TEMPLATES	/usr/include/boost/regex/config.hpp	93;"	d
BOOST_REGEX_NO_EXTERNAL_TEMPLATES	/usr/include/boost/regex/config.hpp	99;"	d
BOOST_REGEX_NO_EXTERNAL_TEMPLATES	/usr/include/boost/regex/config/borland.hpp	35;"	d
BOOST_REGEX_NO_EXTERNAL_TEMPLATES	/usr/include/boost/spirit/home/classic/utility/regex.hpp	29;"	d
BOOST_REGEX_NO_FILEITER	/usr/include/boost/regex/config.hpp	137;"	d
BOOST_REGEX_NO_LIB	/usr/include/boost/regex/config.hpp	142;"	d
BOOST_REGEX_NO_LIB	/usr/include/boost/regex/config/borland.hpp	54;"	d
BOOST_REGEX_NO_LIB	/usr/include/boost/spirit/home/classic/utility/regex.hpp	27;"	d
BOOST_REGEX_NO_W32	/usr/include/boost/regex/config.hpp	131;"	d
BOOST_REGEX_NO_W32	/usr/include/boost/regex/config.hpp	148;"	d
BOOST_REGEX_NO_W32	/usr/include/boost/regex/config.hpp	151;"	d
BOOST_REGEX_OBJECT_CACHE_HPP	/usr/include/boost/regex/pending/object_cache.hpp	20;"	d
BOOST_REGEX_PRIMARY_TRANSFORM	/usr/include/boost/regex/v4/primary_transform.hpp	21;"	d
BOOST_REGEX_RAW_BUFFER_HPP	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	22;"	d
BOOST_REGEX_RECURSIVE	/usr/include/boost/regex/config.hpp	352;"	d
BOOST_REGEX_SPLIT_HPP	/usr/include/boost/regex/v4/regex_split.hpp	22;"	d
BOOST_REGEX_STATIC_LINK	/usr/include/boost/regex/config/borland.hpp	40;"	d
BOOST_REGEX_STATIC_LINK	/usr/include/boost/regex/config/borland.hpp	57;"	d
BOOST_REGEX_STATIC_LINK	/usr/include/boost/spirit/home/classic/utility/regex.hpp	28;"	d
BOOST_REGEX_STATIC_MUTEX_HPP	/usr/include/boost/regex/pending/static_mutex.hpp	22;"	d
BOOST_REGEX_SYNTAX_TYPE_HPP	/usr/include/boost/regex/v4/syntax_type.hpp	20;"	d
BOOST_REGEX_TRAITS_DEFAULTS_HPP_INCLUDED	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	20;"	d
BOOST_REGEX_TRAITS_HPP	/usr/include/boost/regex/regex_traits.hpp	20;"	d
BOOST_REGEX_TRAITS_HPP_INCLUDED	/usr/include/boost/regex/v4/regex_traits.hpp	20;"	d
BOOST_REGEX_TRAITS_T	/usr/include/boost/regex/icu.hpp	220;"	d
BOOST_REGEX_TRAITS_T	/usr/include/boost/regex/icu.hpp	221;"	d
BOOST_REGEX_TRAITS_T	/usr/include/boost/regex/icu.hpp	228;"	d
BOOST_REGEX_TRAITS_T	/usr/include/boost/regex/v4/instances.hpp	37;"	d
BOOST_REGEX_UNICODE_ITERATOR_HPP	/usr/include/boost/regex/pending/unicode_iterator.hpp	62;"	d
BOOST_REGEX_USER_CONFIG	/usr/include/boost/regex/config.hpp	38;"	d
BOOST_REGEX_USE_CPP_LOCALE	/usr/include/boost/regex/config.hpp	257;"	d
BOOST_REGEX_USE_CPP_LOCALE	/usr/include/boost/regex/config.hpp	270;"	d
BOOST_REGEX_USE_C_LOCALE	/usr/include/boost/regex/config.hpp	253;"	d
BOOST_REGEX_USE_C_LOCALE	/usr/include/boost/regex/config.hpp	261;"	d
BOOST_REGEX_USE_C_LOCALE	/usr/include/boost/regex/config.hpp	274;"	d
BOOST_REGEX_USE_VCL	/usr/include/boost/regex/config/borland.hpp	46;"	d
BOOST_REGEX_USE_WIN32_LOCALE	/usr/include/boost/regex/config.hpp	266;"	d
BOOST_REGEX_V4_BASIC_REGEX_CREATOR_HPP	/usr/include/boost/regex/v4/basic_regex_creator.hpp	21;"	d
BOOST_REGEX_V4_BASIC_REGEX_HPP	/usr/include/boost/regex/v4/basic_regex.hpp	20;"	d
BOOST_REGEX_V4_BASIC_REGEX_PARSER_HPP	/usr/include/boost/regex/v4/basic_regex_parser.hpp	20;"	d
BOOST_REGEX_V4_CHAR_REGEX_TRAITS_HPP	/usr/include/boost/regex/v4/char_regex_traits.hpp	21;"	d
BOOST_REGEX_V4_ITERATOR_TRAITS_HPP	/usr/include/boost/regex/v4/iterator_traits.hpp	20;"	d
BOOST_REGEX_V4_MATCH_FLAGS	/usr/include/boost/regex/v4/match_flags.hpp	20;"	d
BOOST_REGEX_V4_MATCH_RESULTS_HPP	/usr/include/boost/regex/v4/match_results.hpp	20;"	d
BOOST_REGEX_V4_MEM_BLOCK_CACHE_HPP	/usr/include/boost/regex/v4/mem_block_cache.hpp	19;"	d
BOOST_REGEX_V4_PERL_MATCHER_COMMON_HPP	/usr/include/boost/regex/v4/perl_matcher_common.hpp	21;"	d
BOOST_REGEX_V4_PERL_MATCHER_NON_RECURSIVE_HPP	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	21;"	d
BOOST_REGEX_V4_PERL_MATCHER_RECURSIVE_HPP	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	21;"	d
BOOST_REGEX_V4_PROTECTED_CALL_HPP	/usr/include/boost/regex/v4/protected_call.hpp	21;"	d
BOOST_REGEX_V4_REGBASE_HPP	/usr/include/boost/regex/v4/regbase.hpp	20;"	d
BOOST_REGEX_V4_REGEX_GREP_HPP	/usr/include/boost/regex/v4/regex_grep.hpp	20;"	d
BOOST_REGEX_V4_REGEX_ITERATOR_HPP	/usr/include/boost/regex/v4/regex_iterator.hpp	20;"	d
BOOST_REGEX_V4_REGEX_MERGE_HPP	/usr/include/boost/regex/v4/regex_merge.hpp	22;"	d
BOOST_REGEX_V4_REGEX_REPLACE_HPP	/usr/include/boost/regex/v4/regex_replace.hpp	22;"	d
BOOST_REGEX_V4_REGEX_SEARCH_HPP	/usr/include/boost/regex/v4/regex_search.hpp	20;"	d
BOOST_REGEX_V4_REGEX_TOKEN_ITERATOR_HPP	/usr/include/boost/regex/v4/regex_token_iterator.hpp	20;"	d
BOOST_REGEX_V4_STATES_HPP	/usr/include/boost/regex/v4/states.hpp	20;"	d
BOOST_REGEX_V4_SUB_MATCH_HPP	/usr/include/boost/regex/v4/sub_match.hpp	20;"	d
BOOST_REGEX_V4_U32REGEX_ITERATOR_HPP	/usr/include/boost/regex/v4/u32regex_iterator.hpp	20;"	d
BOOST_REGEX_V4_U32REGEX_TOKEN_ITERATOR_HPP	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	20;"	d
BOOST_REGEX_WORKAROUND_HPP	/usr/include/boost/regex/v4/regex_workaround.hpp	20;"	d
BOOST_RE_CREGEX_HPP	/usr/include/boost/cregex.hpp	21;"	d
BOOST_RE_CREGEX_HPP_INCLUDED	/usr/include/boost/regex/v4/cregex.hpp	21;"	d
BOOST_RE_FILEITER_HPP_INCLUDED	/usr/include/boost/regex/v4/fileiter.hpp	22;"	d
BOOST_RE_PAT_EXCEPT_HPP	/usr/include/boost/regex/pattern_except.hpp	20;"	d
BOOST_RE_REGEX_H	/usr/include/boost/regex.h	20;"	d
BOOST_RE_REGEX_HPP	/usr/include/boost/regex.hpp	25;"	d
BOOST_RE_REGEX_HPP_INCLUDED	/usr/include/boost/regex/v4/regex.hpp	22;"	d
BOOST_RE_VERSION	/usr/include/boost/regex/config.hpp	65;"	d
BOOST_SCOPED_ENUM_START	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_SCOPED_ENUM_START(copy_option)$/;"	f	namespace:boost::filesystem	signature:(copy_option)
BOOST_SCOPED_ENUM_START	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_SCOPED_ENUM_START(symlink_option)$/;"	f	namespace:boost::filesystem	signature:(symlink_option)
BOOST_SPIRIT_INCLUDE_CLASSIC_REGEX	/usr/include/boost/spirit/include/classic_regex.hpp	10;"	d
BOOST_SPIRIT_REGEX_HPP	/usr/include/boost/spirit/home/classic/utility/regex.hpp	9;"	d
BOOST_STATIC_ASSERT	/usr/include/boost/regex/v4/regex_format.hpp	/^   BOOST_STATIC_ASSERT((::boost::is_pointer<F>::value || ::boost::is_function<F>::value || ::boost::is_class<F>::value));$/;"	p	struct:boost::re_detail::format_traits_imp	access:private	signature:(::boost::is_pointer<F>::value || ::boost::is_function<F>::value || ::boost::is_class<F>::value)
BOOST_STATIC_CONSTANT	/usr/include/boost/date_time/time_system_split.hpp	/^     BOOST_STATIC_CONSTANT(int_type, ticks_per_day = INT64_C(86400) * config::tick_per_second);$/;"	p	class:boost::date_time::split_timedate_system	access:private	signature:(int_type, ticks_per_day = INT64_C(86400) * config::tick_per_second)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_CONSTANT(U32Type, pending_read = 0xffffffffu);$/;"	p	class:boost::u16_to_u32_iterator	access:private	signature:(U32Type, pending_read = 0xffffffffu)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_CONSTANT(U32Type, pending_read = 0xffffffffu);$/;"	p	class:boost::u8_to_u32_iterator	access:private	signature:(U32Type, pending_read = 0xffffffffu)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_blank = 1u << 24);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_blank = 1u << 24)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_horizontal = 1u << 27);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_horizontal = 1u << 27)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_unicode = 1u << 26);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_unicode = 1u << 26)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_vertical = 1u << 28);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_vertical = 1u << 28)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_word = 1u << 25);$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(char_class_type, mask_word = 1u << 25)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/iterator_category.hpp	/^   BOOST_STATIC_CONSTANT(bool, value = (::boost::is_convertible<cat*, std::random_access_iterator_tag*>::value));$/;"	p	struct:boost::detail::is_random_imp	access:public	signature:(bool, value = (::boost::is_convertible<cat*, std::random_access_iterator_tag*>::value))
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/iterator_category.hpp	/^   BOOST_STATIC_CONSTANT(bool, value = answer::value);$/;"	p	struct:boost::is_random_access_iterator	access:public	signature:(bool, value = answer::value)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/iterator_category.hpp	/^   BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::detail::is_random_pointer_imp	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/regex_format.hpp	/^   BOOST_STATIC_CONSTANT(int, value = sizeof(check_is_formatter(f(m), f(m, out), f(m, out, flags))));$/;"	p	struct:boost::re_detail::format_traits_imp	access:public	signature:(int, value = sizeof(check_is_formatter(f(m), f(m, out), f(m, out, flags))))
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_base = 0x3ff);  \/\/ all the masks used by the CT_CTYPE1 group$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_base = 0x3ff)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_horizontal = 0x1000); \/\/ must be C1_DEFINED << 3$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_horizontal = 0x1000)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_unicode = 0x0800); \/\/ must be C1_DEFINED << 2$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_unicode = 0x0800)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_vertical = 0x2000); \/\/ must be C1_DEFINED << 4$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_vertical = 0x2000)
BOOST_STATIC_CONSTANT	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   BOOST_STATIC_CONSTANT(char_class_type, mask_word = 0x0400); \/\/ must be C1_DEFINED << 1$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(char_class_type, mask_word = 0x0400)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, collate            = regex_constants::collate);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, collate = regex_constants::collate)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ECMAScript         = regex_constants::ECMAScript);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ECMAScript = regex_constants::ECMAScript)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, icase              = regex_constants::icase_);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, icase = regex_constants::icase_)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, nosubs             = regex_constants::nosubs);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, nosubs = regex_constants::nosubs)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_newline    = regex_constants::not_dot_newline);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_newline = regex_constants::not_dot_newline)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_null       = regex_constants::not_dot_null);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_null = regex_constants::not_dot_null)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, optimize           = regex_constants::optimize);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, optimize = regex_constants::optimize)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, single_line        = regex_constants::single_line);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, single_line = regex_constants::single_line)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/regex_actions.hpp	/^                BOOST_STATIC_CONSTANT(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))));$/;"	p	struct:boost::xpressive::op::insert::result	access:public	signature:(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))))
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value));$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value))
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = 0227);$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = 0227)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = Out);$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = Out)
BOOST_STATIC_CONSTANT	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = static_cast<umask_t>(Mask));$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = static_cast<umask_t>(Mask))
BOOST_STATIC_MUTEX_INIT	/usr/include/boost/regex/pending/static_mutex.hpp	48;"	d
BOOST_STRING_ALGO_REGEX_HPP	/usr/include/boost/algorithm/string_regex.hpp	12;"	d
BOOST_STRING_FINDER_REGEX_DETAIL_HPP	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	12;"	d
BOOST_STRING_FORMATTER_REGEX_DETAIL_HPP	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	12;"	d
BOOST_STRING_REGEX_FIND_FORMAT_HPP	/usr/include/boost/algorithm/string/regex_find_format.hpp	12;"	d
BOOST_STRING_REGEX_HPP	/usr/include/boost/algorithm/string/regex.hpp	12;"	d
BOOST_SYMBOL_EXPORT	/usr/include/boost/regex/config.hpp	192;"	d
BOOST_SYMBOL_IMPORT	/usr/include/boost/regex/config.hpp	193;"	d
BOOST_SYSTEM_API_CONFIG_HPP	/usr/include/boost/system/api_config.hpp	25;"	d
BOOST_SYSTEM_CLOCK_DURATION	/usr/include/boost/chrono/system_clocks.hpp	75;"	d
BOOST_SYSTEM_CLOCK_DURATION	/usr/include/boost/chrono/system_clocks.hpp	77;"	d
BOOST_SYSTEM_CONFIG_HPP	/usr/include/boost/system/config.hpp	11;"	d
BOOST_SYSTEM_DECL	/usr/include/boost/system/config.hpp	40;"	d
BOOST_SYSTEM_DECL	/usr/include/boost/system/config.hpp	42;"	d
BOOST_SYSTEM_DECL	/usr/include/boost/system/config.hpp	45;"	d
BOOST_SYSTEM_DYN_LINK	/usr/include/boost/system/config.hpp	27;"	d
BOOST_SYSTEM_ERROR_HPP	/usr/include/boost/system/system_error.hpp	9;"	d
BOOST_SYSTEM_STATIC_LINK	/usr/include/boost/system/config.hpp	23;"	d
BOOST_SYSTEM_STATIC_LINK	/usr/include/boost/system/config.hpp	29;"	d
BOOST_TR1_REGEX_HPP_INCLUDED	/usr/include/boost/tr1/regex.hpp	7;"	d
BOOST_TR1_REGEX_H_INCLUDED	/usr/include/boost/tr1/tr1/bcc32/regex.h	10;"	d
BOOST_UNITS_ABSTRACT_HPP	/usr/include/boost/units/systems/abstract.hpp	12;"	d
BOOST_UNITS_ANGLE_DEGREE_HPP	/usr/include/boost/units/systems/angle/degrees.hpp	12;"	d
BOOST_UNITS_ANGLE_GRADIANS_HPP	/usr/include/boost/units/systems/angle/gradians.hpp	12;"	d
BOOST_UNITS_ANGLE_REVOLUTIONS_HPP	/usr/include/boost/units/systems/angle/revolutions.hpp	12;"	d
BOOST_UNITS_CGS_ACCELERATION_HPP	/usr/include/boost/units/systems/cgs/acceleration.hpp	12;"	d
BOOST_UNITS_CGS_AREA_HPP	/usr/include/boost/units/systems/cgs/area.hpp	12;"	d
BOOST_UNITS_CGS_BASE_HPP	/usr/include/boost/units/systems/cgs/base.hpp	12;"	d
BOOST_UNITS_CGS_CURRENT_HPP	/usr/include/boost/units/systems/cgs/current.hpp	12;"	d
BOOST_UNITS_CGS_DIMENSIONLESS_HPP	/usr/include/boost/units/systems/cgs/dimensionless.hpp	12;"	d
BOOST_UNITS_CGS_DYNAMIC_VISCOSITY_HPP	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	12;"	d
BOOST_UNITS_CGS_ENERGY_HPP	/usr/include/boost/units/systems/cgs/energy.hpp	12;"	d
BOOST_UNITS_CGS_FORCE_HPP	/usr/include/boost/units/systems/cgs/force.hpp	12;"	d
BOOST_UNITS_CGS_FREQUENCY_HPP	/usr/include/boost/units/systems/cgs/frequency.hpp	12;"	d
BOOST_UNITS_CGS_HPP	/usr/include/boost/units/systems/cgs.hpp	12;"	d
BOOST_UNITS_CGS_IO_HPP	/usr/include/boost/units/systems/cgs/io.hpp	12;"	d
BOOST_UNITS_CGS_KINEMATIC_VISCOSITY_HPP	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	12;"	d
BOOST_UNITS_CGS_LENGTH_HPP	/usr/include/boost/units/systems/cgs/length.hpp	12;"	d
BOOST_UNITS_CGS_MASS_DENSITY_HPP	/usr/include/boost/units/systems/cgs/mass_density.hpp	12;"	d
BOOST_UNITS_CGS_MASS_HPP	/usr/include/boost/units/systems/cgs/mass.hpp	12;"	d
BOOST_UNITS_CGS_MOMENTUM_HPP	/usr/include/boost/units/systems/cgs/momentum.hpp	12;"	d
BOOST_UNITS_CGS_POWER_HPP	/usr/include/boost/units/systems/cgs/power.hpp	12;"	d
BOOST_UNITS_CGS_PRESSURE_HPP	/usr/include/boost/units/systems/cgs/pressure.hpp	12;"	d
BOOST_UNITS_CGS_TIME_HPP	/usr/include/boost/units/systems/cgs/time.hpp	12;"	d
BOOST_UNITS_CGS_VELOCITY_HPP	/usr/include/boost/units/systems/cgs/velocity.hpp	12;"	d
BOOST_UNITS_CGS_VOLUME_HPP	/usr/include/boost/units/systems/cgs/volume.hpp	12;"	d
BOOST_UNITS_CGS_WAVENUMBER_HPP	/usr/include/boost/units/systems/cgs/wavenumber.hpp	12;"	d
BOOST_UNITS_CODATA_ALPHA_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	12;"	d
BOOST_UNITS_CODATA_ATOMIC_AND_NUCLEAR_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	12;"	d
BOOST_UNITS_CODATA_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata_constants.hpp	12;"	d
BOOST_UNITS_CODATA_DEUTERON_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	12;"	d
BOOST_UNITS_CODATA_ELECTROMAGNETIC_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	12;"	d
BOOST_UNITS_CODATA_ELECTRON_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	12;"	d
BOOST_UNITS_CODATA_HELION_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	12;"	d
BOOST_UNITS_CODATA_MUON_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	12;"	d
BOOST_UNITS_CODATA_NEUTRON_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	12;"	d
BOOST_UNITS_CODATA_PHYSICO_CHEMICAL_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	12;"	d
BOOST_UNITS_CODATA_PROTON_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	12;"	d
BOOST_UNITS_CODATA_TAU_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	12;"	d
BOOST_UNITS_CODATA_TRITON_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	12;"	d
BOOST_UNITS_CODATA_TYPEDEFS_HPP	/usr/include/boost/units/systems/si/codata/typedefs.hpp	12;"	d
BOOST_UNITS_CODATA_UNIVERSAL_CONSTANTS_HPP	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	12;"	d
BOOST_UNITS_CONSTANTS_HPP	/usr/include/boost/units/systems/detail/constants.hpp	12;"	d
BOOST_UNITS_DEFINE_HELPER	/usr/include/boost/units/systems/detail/constants.hpp	137;"	d
BOOST_UNITS_DEFINE_HELPER	/usr/include/boost/units/systems/detail/constants.hpp	139;"	d
BOOST_UNITS_DEFINE_HELPER	/usr/include/boost/units/systems/detail/constants.hpp	170;"	d
BOOST_UNITS_DEFINE_HELPER	/usr/include/boost/units/systems/detail/constants.hpp	183;"	d
BOOST_UNITS_DEFINE_HELPER	/usr/include/boost/units/systems/detail/constants.hpp	52;"	d
BOOST_UNITS_DEFINE_HELPER	/usr/include/boost/units/systems/detail/constants.hpp	89;"	d
BOOST_UNITS_DEFINE_HELPER	/usr/include/boost/units/systems/detail/constants.hpp	91;"	d
BOOST_UNITS_GET_SYSTEM_HPP	/usr/include/boost/units/get_system.hpp	12;"	d
BOOST_UNITS_HETEROGENEOUS_SYSTEM_HPP	/usr/include/boost/units/heterogeneous_system.hpp	12;"	d
BOOST_UNITS_HOMOGENEOUS_SYSTEM_HPP_INCLUDED	/usr/include/boost/units/homogeneous_system.hpp	12;"	d
BOOST_UNITS_IS_QUANTITY_OF_SYSTEM_HPP	/usr/include/boost/units/is_quantity_of_system.hpp	12;"	d
BOOST_UNITS_IS_UNIT_OF_SYSTEM_HPP	/usr/include/boost/units/is_unit_of_system.hpp	12;"	d
BOOST_UNITS_MAKE_HETEROGENEOUS_UNIT	/usr/include/boost/units/heterogeneous_system.hpp	95;"	d
BOOST_UNITS_MAKE_SYSTEM_HPP	/usr/include/boost/units/make_system.hpp	12;"	d
BOOST_UNITS_METRIC_PREFIX	/usr/include/boost/units/systems/si/prefixes.hpp	25;"	d
BOOST_UNITS_NO_PASCAL	/usr/include/boost/units/systems/si/pressure.hpp	28;"	d
BOOST_UNITS_NO_PASCAL	/usr/include/boost/units/systems/si/pressure.hpp	30;"	d
BOOST_UNITS_NO_PASCAL	/usr/include/boost/units/systems/si/pressure.hpp	33;"	d
BOOST_UNITS_NO_PASCAL	/usr/include/boost/units/systems/si/pressure.hpp	35;"	d
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/detail/constants.hpp	205;"	d
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_alpha,quantity<mass>,6.64465620e-27*kilograms,3.3e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_alpha,quantity<mass>,6.64465620e-27*kilograms,3.3e-34*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_alpha,quantity<mass_over_amount>,4.001506179127e-3*kilograms\/mole,6.2e-14*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_alpha,quantity<mass_over_amount>,4.001506179127e-3*kilograms/mole,6.2e-14*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_alpha_over_m_e,quantity<dimensionless>,7294.2995365*dimensionless(),3.1e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_alpha_over_m_e,quantity<dimensionless>,7294.2995365*dimensionless(),3.1e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_alpha_over_m_p,quantity<dimensionless>,3.97259968951*dimensionless(),4.1e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_alpha_over_m_p,quantity<dimensionless>,3.97259968951*dimensionless(),4.1e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(alpha,quantity<dimensionless>,7.2973525376e-3*dimensionless(),5.0e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(alpha,quantity<dimensionless>,7.2973525376e-3*dimensionless(),5.0e-12*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(a_0,quantity<length>,0.52917720859e-10*meters,3.6e-20*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(a_0,quantity<length>,0.52917720859e-10*meters,3.6e-20*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(E_h,quantity<energy>,4.35974394e-18*joules,2.2e-25*joules);$/;"	p	namespace:boost::units::si::constants::codata	signature:(E_h,quantity<energy>,4.35974394e-18*joules,2.2e-25*joules)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_infinity,quantity<wavenumber>,10973731.568527\/meter,7.3e-5\/meter);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_infinity,quantity<wavenumber>,10973731.568527/meter,7.3e-5/meter)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_d,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_d,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d,quantity<energy_over_magnetic_flux_density>,0.433073465e-26*joules\/tesla,1.1e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d,quantity<energy_over_magnetic_flux_density>,0.433073465e-26*joules/tesla,1.1e-34*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_B,quantity<dimensionless>,0.4669754556e-3*dimensionless(),3.9e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_B,quantity<dimensionless>,0.4669754556e-3*dimensionless(),3.9e-12*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_e,quantity<dimensionless>,-4.664345537e-4*dimensionless(),3.9e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_e,quantity<dimensionless>,-4.664345537e-4*dimensionless(),3.9e-12*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_n,quantity<dimensionless>,-0.44820652*dimensionless(),1.1e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_n,quantity<dimensionless>,-0.44820652*dimensionless(),1.1e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_N,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_N,quantity<dimensionless>,0.8574382308*dimensionless(),7.2e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_d_over_mu_p,quantity<dimensionless>,0.3070122070*dimensionless(),2.4e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_d_over_mu_p,quantity<dimensionless>,0.3070122070*dimensionless(),2.4e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_d,quantity<mass>,3.34358320e-27*kilograms,1.7e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_d,quantity<mass>,3.34358320e-27*kilograms,1.7e-34*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_d,quantity<mass_over_amount>,2.013553212724e-3*kilograms\/mole,7.8e-14*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_d,quantity<mass_over_amount>,2.013553212724e-3*kilograms/mole,7.8e-14*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_d_over_m_e,quantity<dimensionless>,3670.4829654*dimensionless(),1.6e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_d_over_m_e,quantity<dimensionless>,3670.4829654*dimensionless(),1.6e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_d_over_m_p,quantity<dimensionless>,1.99900750108*dimensionless(),2.2e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_d_over_m_p,quantity<dimensionless>,1.99900750108*dimensionless(),2.2e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_d,quantity<length>,2.1402e-15*meters,2.8e-18*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_d,quantity<length>,2.1402e-15*meters,2.8e-18*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e,quantity<electric_charge>,1.602176487e-19*coulombs,4.0e-27*coulombs);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e,quantity<electric_charge>,1.602176487e-19*coulombs,4.0e-27*coulombs)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e_over_h,quantity<current_over_energy>,2.417989454e14*amperes\/joule,6.0e6*amperes\/joule);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e_over_h,quantity<current_over_energy>,2.417989454e14*amperes/joule,6.0e6*amperes/joule)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(G_0,quantity<conductance>,7.7480917004e-5*siemens,5.3e-14*siemens);$/;"	p	namespace:boost::units::si::constants::codata	signature:(G_0,quantity<conductance>,7.7480917004e-5*siemens,5.3e-14*siemens)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(K_J,quantity<frequency_over_electric_potential>,483597.891e9*hertz\/volt,1.2e7*hertz\/volt);$/;"	p	namespace:boost::units::si::constants::codata	signature:(K_J,quantity<frequency_over_electric_potential>,483597.891e9*hertz/volt,1.2e7*hertz/volt)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_B,quantity<energy_over_magnetic_flux_density>,927.400915e-26*joules\/tesla,2.3e-31*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_B,quantity<energy_over_magnetic_flux_density>,927.400915e-26*joules/tesla,2.3e-31*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_N,quantity<energy_over_magnetic_flux_density>,5.05078324e-27*joules\/tesla,1.3e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_N,quantity<energy_over_magnetic_flux_density>,5.05078324e-27*joules/tesla,1.3e-34*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(Phi_0,quantity<magnetic_flux>,2.067833667e-15*webers,5.2e-23*webers);$/;"	p	namespace:boost::units::si::constants::codata	signature:(Phi_0,quantity<magnetic_flux>,2.067833667e-15*webers,5.2e-23*webers)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_K,quantity<resistance>,25812.807557*ohms,1.77e-5*ohms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_K,quantity<resistance>,25812.807557*ohms,1.77e-5*ohms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(a_e,quantity<dimensionless>,1.15965218111e-3*dimensionless(),7.4e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(a_e,quantity<dimensionless>,1.15965218111e-3*dimensionless(),7.4e-13*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e_over_m_e,quantity<electric_charge_over_mass>,1.758820150e11*coulombs\/kilogram,4.4e3*coulombs\/kilogram);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e_over_m_e,quantity<electric_charge_over_mass>,1.758820150e11*coulombs/kilogram,4.4e3*coulombs/kilogram)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_e,quantity<frequency_over_magnetic_flux_density>,1.760859770e11\/second\/tesla,4.4e3\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_e,quantity<frequency_over_magnetic_flux_density>,1.760859770e11/second/tesla,4.4e3/second/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_e,quantity<dimensionless>,-2.0023193043622*dimensionless(),1.5e-12*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_e,quantity<dimensionless>,-2.0023193043622*dimensionless(),1.5e-12*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C,quantity<length>,2.4263102175e-12*meters,3.3e-21*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C,quantity<length>,2.4263102175e-12*meters,3.3e-21*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e,quantity<energy_over_magnetic_flux_density>,-928.476377e-26*joules\/tesla,2.3e-31*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e,quantity<energy_over_magnetic_flux_density>,-928.476377e-26*joules/tesla,2.3e-31*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_B,quantity<dimensionless>,-1.00115965218111*dimensionless(),7.4e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_B,quantity<dimensionless>,-1.00115965218111*dimensionless(),7.4e-13*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_d,quantity<dimensionless>,-2143.923498*dimensionless(),1.8e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_d,quantity<dimensionless>,-2143.923498*dimensionless(),1.8e-5*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_h_prime,quantity<dimensionless>,864.058257*dimensionless(),1.0e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_h_prime,quantity<dimensionless>,864.058257*dimensionless(),1.0e-5*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_mu,quantity<dimensionless>,206.7669877*dimensionless(),5.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_mu,quantity<dimensionless>,206.7669877*dimensionless(),5.2e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_N,quantity<dimensionless>,-183.28197092*dimensionless(),8.0e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_N,quantity<dimensionless>,-183.28197092*dimensionless(),8.0e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_n,quantity<dimensionless>,960.92050*dimensionless(),2.3e-4*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_n,quantity<dimensionless>,960.92050*dimensionless(),2.3e-4*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_p,quantity<dimensionless>,-658.2106848*dimensionless(),5.4e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_p,quantity<dimensionless>,-658.2106848*dimensionless(),5.4e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_e_over_mu_p_prime,quantity<dimensionless>,-658.2275971*dimensionless(),7.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_e_over_mu_p_prime,quantity<dimensionless>,-658.2275971*dimensionless(),7.2e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e,quantity<mass>,9.10938215e-31*kilograms,4.5e-38*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e,quantity<mass>,9.10938215e-31*kilograms,4.5e-38*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_e,quantity<mass_over_amount>,5.4857990943e-7*kilograms\/mole,2.3e-16*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_e,quantity<mass_over_amount>,5.4857990943e-7*kilograms/mole,2.3e-16*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_alpha,quantity<dimensionless>,1.37093355570e-4*dimensionless(),5.8e-14*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_alpha,quantity<dimensionless>,1.37093355570e-4*dimensionless(),5.8e-14*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_d,quantity<dimensionless>,2.7244371093e-4*dimensionless(),1.2e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_d,quantity<dimensionless>,2.7244371093e-4*dimensionless(),1.2e-13*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_mu,quantity<dimensionless>,4.83633171e-3*dimensionless(),1.2e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_mu,quantity<dimensionless>,4.83633171e-3*dimensionless(),1.2e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_n,quantity<dimensionless>,5.4386734459e-4*dimensionless(),3.3e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_n,quantity<dimensionless>,5.4386734459e-4*dimensionless(),3.3e-13*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_p,quantity<dimensionless>,5.4461702177e-4*dimensionless(),2.4e-13*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_p,quantity<dimensionless>,5.4461702177e-4*dimensionless(),2.4e-13*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_e_over_m_tau,quantity<dimensionless>,2.87564e-4*dimensionless(),4.7e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_e_over_m_tau,quantity<dimensionless>,2.87564e-4*dimensionless(),4.7e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(r_e,quantity<length>,2.8179402894e-15*meters,5.8e-24*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(r_e,quantity<length>,2.8179402894e-15*meters,5.8e-24*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(sigma_e,quantity<area>,0.6652458558e-28*square_meters,2.7e-37*square_meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(sigma_e,quantity<area>,0.6652458558e-28*square_meters,2.7e-37*square_meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_h_prime,quantity<frequency_over_magnetic_flux_density>,2.037894730e8\/second\/tesla,5.6e-0\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_h_prime,quantity<frequency_over_magnetic_flux_density>,2.037894730e8/second/tesla,5.6e-0/second/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime,quantity<energy_over_magnetic_flux_density>,-1.074552982e-26*joules\/tesla,3.0e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime,quantity<energy_over_magnetic_flux_density>,-1.074552982e-26*joules/tesla,3.0e-34*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_B,quantity<dimensionless>,-1.158671471e-3*dimensionless(),1.4e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_B,quantity<dimensionless>,-1.158671471e-3*dimensionless(),1.4e-11*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_N,quantity<dimensionless>,-2.127497718*dimensionless(),2.5e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_N,quantity<dimensionless>,-2.127497718*dimensionless(),2.5e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_p,quantity<dimensionless>,-0.761766558*dimensionless(),1.1e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_p,quantity<dimensionless>,-0.761766558*dimensionless(),1.1e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_h_prime_over_mu_p_prime,quantity<dimensionless>,-0.7617861313*dimensionless(),3.3e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_h_prime_over_mu_p_prime,quantity<dimensionless>,-0.7617861313*dimensionless(),3.3e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_h,quantity<mass>,5.00641192e-27*kilograms,2.5e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_h,quantity<mass>,5.00641192e-27*kilograms,2.5e-34*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_h,quantity<mass_over_amount>,3.0149322473e-3*kilograms\/mole,2.6e-12*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_h,quantity<mass_over_amount>,3.0149322473e-3*kilograms/mole,2.6e-12*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_h_over_m_e,quantity<dimensionless>,5495.8852765*dimensionless(),5.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_h_over_m_e,quantity<dimensionless>,5495.8852765*dimensionless(),5.2e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_h_over_m_p,quantity<dimensionless>,2.9931526713*dimensionless(),2.6e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_h_over_m_p,quantity<dimensionless>,2.9931526713*dimensionless(),2.6e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(a_mu,quantity<dimensionless>,1.16592069e-3*dimensionless(),6.0e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(a_mu,quantity<dimensionless>,1.16592069e-3*dimensionless(),6.0e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_mu,quantity<dimensionless>,-2.0023318414*dimensionless(),1.2e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_mu,quantity<dimensionless>,-2.0023318414*dimensionless(),1.2e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_mu,quantity<length>,11.73444104e-15*meters,3.0e-22*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_mu,quantity<length>,11.73444104e-15*meters,3.0e-22*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu,quantity<energy_over_magnetic_flux_density>,-4.49044786e-26*joules\/tesla,1.6e-33*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu,quantity<energy_over_magnetic_flux_density>,-4.49044786e-26*joules/tesla,1.6e-33*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu_over_mu_B,quantity<dimensionless>,-4.84197049e-3*dimensionless(),1.2e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu_over_mu_B,quantity<dimensionless>,-4.84197049e-3*dimensionless(),1.2e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu_over_mu_N,quantity<dimensionless>,-8.89059705*dimensionless(),2.3e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu_over_mu_N,quantity<dimensionless>,-8.89059705*dimensionless(),2.3e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_mu_over_mu_p,quantity<dimensionless>,-3.183345137*dimensionless(),8.5e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_mu_over_mu_p,quantity<dimensionless>,-3.183345137*dimensionless(),8.5e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu,quantity<mass>,1.88353130e-28*kilograms,1.1e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu,quantity<mass>,1.88353130e-28*kilograms,1.1e-35*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_mu,quantity<mass_over_amount>,0.1134289256e-3*kilograms\/mole,2.9e-12*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_mu,quantity<mass_over_amount>,0.1134289256e-3*kilograms/mole,2.9e-12*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_e,quantity<dimensionless>,206.7682823*dimensionless(),5.2e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_e,quantity<dimensionless>,206.7682823*dimensionless(),5.2e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_n,quantity<dimensionless>,0.1124545167*dimensionless(),2.9e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_n,quantity<dimensionless>,0.1124545167*dimensionless(),2.9e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_p,quantity<dimensionless>,0.1126095261*dimensionless(),2.9e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_p,quantity<dimensionless>,0.1126095261*dimensionless(),2.9e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_mu_over_m_tau,quantity<dimensionless>,5.94592e-2*dimensionless(),9.7e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_mu_over_m_tau,quantity<dimensionless>,5.94592e-2*dimensionless(),9.7e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_n,quantity<frequency_over_magnetic_flux_density>,1.83247185e8\/second\/tesla,4.3e1\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_n,quantity<frequency_over_magnetic_flux_density>,1.83247185e8/second/tesla,4.3e1/second/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_n,quantity<dimensionless>,-3.82608545*dimensionless(),9.0e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_n,quantity<dimensionless>,-3.82608545*dimensionless(),9.0e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_n,quantity<length>,1.3195908951e-15*meters,2.0e-24*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_n,quantity<length>,1.3195908951e-15*meters,2.0e-24*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n,quantity<energy_over_magnetic_flux_density>,-0.96623641e-26*joules\/tesla,2.3e-33*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n,quantity<energy_over_magnetic_flux_density>,-0.96623641e-26*joules/tesla,2.3e-33*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n_over_mu_e,quantity<dimensionless>,1.04066882e-3*dimensionless(),2.5e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n_over_mu_e,quantity<dimensionless>,1.04066882e-3*dimensionless(),2.5e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n_over_mu_p,quantity<dimensionless>,-0.68497934*dimensionless(),1.6e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n_over_mu_p,quantity<dimensionless>,-0.68497934*dimensionless(),1.6e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_n_over_mu_p_prime,quantity<dimensionless>,-0.68499694*dimensionless(),1.6e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_n_over_mu_p_prime,quantity<dimensionless>,-0.68499694*dimensionless(),1.6e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n,quantity<mass>,1.674927211e-27*kilograms,8.4e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n,quantity<mass>,1.674927211e-27*kilograms,8.4e-35*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_n,quantity<mass_over_amount>,1.00866491597e-3*kilograms\/mole,4.3e-13*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_n,quantity<mass_over_amount>,1.00866491597e-3*kilograms/mole,4.3e-13*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_e,quantity<dimensionless>,1838.6836605*dimensionless(),1.1e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_e,quantity<dimensionless>,1838.6836605*dimensionless(),1.1e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_mu,quantity<dimensionless>,8.89248409*dimensionless(),2.3e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_mu,quantity<dimensionless>,8.89248409*dimensionless(),2.3e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_p,quantity<dimensionless>,1.00137841918*dimensionless(),4.6e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_p,quantity<dimensionless>,1.00137841918*dimensionless(),4.6e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_n_over_m_tau,quantity<dimensionless>,0.528740*dimensionless(),8.6e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_n_over_m_tau,quantity<dimensionless>,0.528740*dimensionless(),8.6e-5*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(b,quantity<length_temperature>,2.8977685e-3*meter*kelvin,5.1e-9*meter*kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(b,quantity<length_temperature>,2.8977685e-3*meter*kelvin,5.1e-9*meter*kelvin)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(b_prime,quantity<frequency_over_temperature>,5.878933e10*hertz\/kelvin,1.0e15*hertz\/kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(b_prime,quantity<frequency_over_temperature>,5.878933e10*hertz/kelvin,1.0e15*hertz/kelvin)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c_1,quantity<power_area>,3.74177118e-16*watt*square_meters,1.9e-23*watt*square_meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c_1,quantity<power_area>,3.74177118e-16*watt*square_meters,1.9e-23*watt*square_meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c_1L,quantity<power_area_over_solid_angle>,1.191042759e-16*watt*square_meters\/steradian,5.9e-24*watt*square_meters\/steradian);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c_1L,quantity<power_area_over_solid_angle>,1.191042759e-16*watt*square_meters/steradian,5.9e-24*watt*square_meters/steradian)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c_2,quantity<length_temperature>,1.4387752e-2*meter*kelvin,2.5e-8*meter*kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c_2,quantity<length_temperature>,1.4387752e-2*meter*kelvin,2.5e-8*meter*kelvin)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(F,quantity<electric_charge_over_amount>,96485.3399*coulombs\/mole,2.4e-3*coulombs\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(F,quantity<electric_charge_over_amount>,96485.3399*coulombs/mole,2.4e-3*coulombs/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(k_B,quantity<energy_over_temperature>,1.3806504e-23*joules\/kelvin,2.4e-29*joules\/kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(k_B,quantity<energy_over_temperature>,1.3806504e-23*joules/kelvin,2.4e-29*joules/kelvin)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_u,quantity<mass>,1.660538782e-27*kilograms,8.3e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_u,quantity<mass>,1.660538782e-27*kilograms,8.3e-35*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(N_A,quantity<inverse_amount>,6.02214179e23\/mole,3.0e16\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(N_A,quantity<inverse_amount>,6.02214179e23/mole,3.0e16/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R,quantity<energy_over_temperature_amount>,8.314472*joules\/kelvin\/mole,1.5e-5*joules\/kelvin\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R,quantity<energy_over_temperature_amount>,8.314472*joules/kelvin/mole,1.5e-5*joules/kelvin/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(sigma_SB,quantity<power_over_area_temperature_4>,5.670400e-8*watts\/square_meter\/pow<4>(kelvin),4.0e-13*watts\/square_meter\/pow<4>(kelvin));$/;"	p	namespace:boost::units::si::constants::codata	signature:(sigma_SB,quantity<power_over_area_temperature_4>,5.670400e-8*watts/square_meter/pow<4>(kelvin),4.0e-13*watts/square_meter/pow<4>(kelvin))
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(e_over_m_p,quantity<electric_charge_over_mass>,9.57883392e7*coulombs\/kilogram,2.4e0*coulombs\/kilogram);$/;"	p	namespace:boost::units::si::constants::codata	signature:(e_over_m_p,quantity<electric_charge_over_mass>,9.57883392e7*coulombs/kilogram,2.4e0*coulombs/kilogram)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_p,quantity<frequency_over_magnetic_flux_density>,2.675222099e8\/second\/tesla,7.0e0\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_p,quantity<frequency_over_magnetic_flux_density>,2.675222099e8/second/tesla,7.0e0/second/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(gamma_p_prime,quantity<frequency_over_magnetic_flux_density>,2.675153362e8\/second\/tesla,7.3e0\/second\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(gamma_p_prime,quantity<frequency_over_magnetic_flux_density>,2.675153362e8/second/tesla,7.3e0/second/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_p,quantity<dimensionless>,5.585694713*dimensionless(),4.6e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_p,quantity<dimensionless>,5.585694713*dimensionless(),4.6e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_p,quantity<length>,1.3214098446e-15*meters,1.9e-24*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_p,quantity<length>,1.3214098446e-15*meters,1.9e-24*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p,quantity<energy_over_magnetic_flux_density>,1.410606662e-26*joules\/tesla,3.7e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p,quantity<energy_over_magnetic_flux_density>,1.410606662e-26*joules/tesla,3.7e-34*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_over_mu_B,quantity<dimensionless>,1.521032209e-3*dimensionless(),1.2e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_over_mu_B,quantity<dimensionless>,1.521032209e-3*dimensionless(),1.2e-11*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_over_mu_n,quantity<dimensionless>,-1.45989806*dimensionless(),3.4e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_over_mu_n,quantity<dimensionless>,-1.45989806*dimensionless(),3.4e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_over_mu_N,quantity<dimensionless>,2.792847356*dimensionless(),2.3e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_over_mu_N,quantity<dimensionless>,2.792847356*dimensionless(),2.3e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_prime,quantity<energy_over_magnetic_flux_density>,1.410570419e-26*joules\/tesla,3.8e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_prime,quantity<energy_over_magnetic_flux_density>,1.410570419e-26*joules/tesla,3.8e-34*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_prime_over_mu_B,quantity<dimensionless>,1.520993128e-3*dimensionless(),1.7e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_prime_over_mu_B,quantity<dimensionless>,1.520993128e-3*dimensionless(),1.7e-11*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_p_prime_over_mu_N,quantity<dimensionless>,2.792775598*dimensionless(),3.0e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_p_prime_over_mu_N,quantity<dimensionless>,2.792775598*dimensionless(),3.0e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p,quantity<mass>,1.672621637e-27*kilograms,8.3e-35*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p,quantity<mass>,1.672621637e-27*kilograms,8.3e-35*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_p,quantity<mass_over_amount>,1.00727646677e-3*kilograms\/mole,1.0e-13*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_p,quantity<mass_over_amount>,1.00727646677e-3*kilograms/mole,1.0e-13*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_e,quantity<dimensionless>,1836.15267247*dimensionless(),8.0e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_e,quantity<dimensionless>,1836.15267247*dimensionless(),8.0e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_mu,quantity<dimensionless>,8.88024339*dimensionless(),2.3e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_mu,quantity<dimensionless>,8.88024339*dimensionless(),2.3e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_n,quantity<dimensionless>,0.99862347824*dimensionless(),4.6e-10*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_n,quantity<dimensionless>,0.99862347824*dimensionless(),4.6e-10*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_p_over_m_tau,quantity<dimensionless>,0.528012*dimensionless(),8.6e-5*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_p_over_m_tau,quantity<dimensionless>,0.528012*dimensionless(),8.6e-5*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(R_p,quantity<length>,0.8768e-15*meters,6.9e-18*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(R_p,quantity<length>,0.8768e-15*meters,6.9e-18*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(sigma_p_prime,quantity<dimensionless>,25.694e-6*dimensionless(),1.4e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(sigma_p_prime,quantity<dimensionless>,25.694e-6*dimensionless(),1.4e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(lambda_C_tau,quantity<length>,0.69772e-15*meters,1.1e-19*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(lambda_C_tau,quantity<length>,0.69772e-15*meters,1.1e-19*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau,quantity<mass>,3.16777e-27*kilograms,5.2e-31*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau,quantity<mass>,3.16777e-27*kilograms,5.2e-31*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_tau,quantity<mass_over_amount>,1.90768e-3*kilograms\/mole,3.1e-7*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_tau,quantity<mass_over_amount>,1.90768e-3*kilograms/mole,3.1e-7*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_e,quantity<dimensionless>,3477.48*dimensionless(),5.7e-1*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_e,quantity<dimensionless>,3477.48*dimensionless(),5.7e-1*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_mu,quantity<dimensionless>,16.8183*dimensionless(),2.7e-3*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_mu,quantity<dimensionless>,16.8183*dimensionless(),2.7e-3*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_n,quantity<dimensionless>,1.89129*dimensionless(),3.1e-4*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_n,quantity<dimensionless>,1.89129*dimensionless(),3.1e-4*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_tau_over_m_p,quantity<dimensionless>,1.89390*dimensionless(),3.1e-4*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_tau_over_m_p,quantity<dimensionless>,1.89390*dimensionless(),3.1e-4*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(g_t,quantity<dimensionless>,5.957924896*dimensionless(),7.6e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(g_t,quantity<dimensionless>,5.957924896*dimensionless(),7.6e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t,quantity<energy_over_magnetic_flux_density>,1.504609361e-26*joules\/tesla,4.2e-34*joules\/tesla);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t,quantity<energy_over_magnetic_flux_density>,1.504609361e-26*joules/tesla,4.2e-34*joules/tesla)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_B,quantity<dimensionless>,1.622393657e-3*dimensionless(),2.1e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_B,quantity<dimensionless>,1.622393657e-3*dimensionless(),2.1e-11*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_e,quantity<dimensionless>,-1.620514423e-3*dimensionless(),2.1e-11*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_e,quantity<dimensionless>,-1.620514423e-3*dimensionless(),2.1e-11*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_n,quantity<dimensionless>,-1.55718553*dimensionless(),3.7e-7*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_n,quantity<dimensionless>,-1.55718553*dimensionless(),3.7e-7*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_N,quantity<dimensionless>,2.978962448*dimensionless(),3.8e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_N,quantity<dimensionless>,2.978962448*dimensionless(),3.8e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_t_over_mu_p,quantity<dimensionless>,1.066639908*dimensionless(),1.0e-8*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_t_over_mu_p,quantity<dimensionless>,1.066639908*dimensionless(),1.0e-8*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_t,quantity<mass>,5.00735588e-27*kilograms,2.5e-34*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_t,quantity<mass>,5.00735588e-27*kilograms,2.5e-34*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(M_t,quantity<mass_over_amount>,3.0155007134e-3*kilograms\/mole,2.5e-12*kilograms\/mole);$/;"	p	namespace:boost::units::si::constants::codata	signature:(M_t,quantity<mass_over_amount>,3.0155007134e-3*kilograms/mole,2.5e-12*kilograms/mole)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_t_over_m_e,quantity<dimensionless>,5496.9215269*dimensionless(),5.1e-6*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_t_over_m_e,quantity<dimensionless>,5496.9215269*dimensionless(),5.1e-6*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_t_over_m_p,quantity<dimensionless>,2.9937170309*dimensionless(),2.5e-9*dimensionless());$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_t_over_m_p,quantity<dimensionless>,2.9937170309*dimensionless(),2.5e-9*dimensionless())
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(c,quantity<velocity>,299792458.0*meters\/second,0.0*meters\/second);$/;"	p	namespace:boost::units::si::constants::codata	signature:(c,quantity<velocity>,299792458.0*meters/second,0.0*meters/second)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(epsilon_0,quantity<capacitance_over_length>,8.854187817620389850536563031710750260608e-12*farad\/meter,0.0*farad\/meter);$/;"	p	namespace:boost::units::si::constants::codata	signature:(epsilon_0,quantity<capacitance_over_length>,8.854187817620389850536563031710750260608e-12*farad/meter,0.0*farad/meter)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(G,quantity<volume_over_mass_time_squared>,6.67428e-11*cubic_meters\/kilogram\/second\/second,6.7e-15*cubic_meters\/kilogram\/second\/second);$/;"	p	namespace:boost::units::si::constants::codata	signature:(G,quantity<volume_over_mass_time_squared>,6.67428e-11*cubic_meters/kilogram/second/second,6.7e-15*cubic_meters/kilogram/second/second)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(h,quantity<energy_time>,6.62606896e-34*joule*seconds,3.3e-41*joule*seconds);$/;"	p	namespace:boost::units::si::constants::codata	signature:(h,quantity<energy_time>,6.62606896e-34*joule*seconds,3.3e-41*joule*seconds)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(hbar,quantity<energy_time>,1.054571628e-34*joule*seconds,5.3e-42*joule*seconds);$/;"	p	namespace:boost::units::si::constants::codata	signature:(hbar,quantity<energy_time>,1.054571628e-34*joule*seconds,5.3e-42*joule*seconds)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(l_P,quantity<length>,1.616252e-35*meters,8.1e-40*meters);$/;"	p	namespace:boost::units::si::constants::codata	signature:(l_P,quantity<length>,1.616252e-35*meters,8.1e-40*meters)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(mu_0,quantity<force_over_current_squared>,12.56637061435917295385057353311801153679e-7*newtons\/ampere\/ampere,0.0*newtons\/ampere\/ampere);$/;"	p	namespace:boost::units::si::constants::codata	signature:(mu_0,quantity<force_over_current_squared>,12.56637061435917295385057353311801153679e-7*newtons/ampere/ampere,0.0*newtons/ampere/ampere)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(m_P,quantity<mass>,2.17644e-8*kilograms,1.1e-12*kilograms);$/;"	p	namespace:boost::units::si::constants::codata	signature:(m_P,quantity<mass>,2.17644e-8*kilograms,1.1e-12*kilograms)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(T_P,quantity<temperature>,1.416785e32*kelvin,7.1e27*kelvin);$/;"	p	namespace:boost::units::si::constants::codata	signature:(T_P,quantity<temperature>,1.416785e32*kelvin,7.1e27*kelvin)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(t_P,quantity<time>,5.39124e-44*seconds,2.7e-48*seconds);$/;"	p	namespace:boost::units::si::constants::codata	signature:(t_P,quantity<time>,5.39124e-44*seconds,2.7e-48*seconds)
BOOST_UNITS_PHYSICAL_CONSTANT	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^BOOST_UNITS_PHYSICAL_CONSTANT(Z_0,quantity<resistance>,376.7303134617706554681984004203193082686*ohm,0.0*ohm);$/;"	p	namespace:boost::units::si::constants::codata	signature:(Z_0,quantity<resistance>,376.7303134617706554681984004203193082686*ohm,0.0*ohm)
BOOST_UNITS_SI_ABSORBED_DOSE_HPP	/usr/include/boost/units/systems/si/absorbed_dose.hpp	12;"	d
BOOST_UNITS_SI_ACCELERATION_HPP	/usr/include/boost/units/systems/si/acceleration.hpp	12;"	d
BOOST_UNITS_SI_ACTION_HPP	/usr/include/boost/units/systems/si/action.hpp	12;"	d
BOOST_UNITS_SI_ACTIVITY_HPP	/usr/include/boost/units/systems/si/activity.hpp	12;"	d
BOOST_UNITS_SI_AMOUNT_HPP	/usr/include/boost/units/systems/si/amount.hpp	12;"	d
BOOST_UNITS_SI_ANGULAR_ACCELERATION_HPP	/usr/include/boost/units/systems/si/angular_acceleration.hpp	12;"	d
BOOST_UNITS_SI_ANGULAR_MOMENTUM_HPP	/usr/include/boost/units/systems/si/angular_momentum.hpp	12;"	d
BOOST_UNITS_SI_ANGULAR_VELOCITY_HPP	/usr/include/boost/units/systems/si/angular_velocity.hpp	12;"	d
BOOST_UNITS_SI_AREA_HPP	/usr/include/boost/units/systems/si/area.hpp	12;"	d
BOOST_UNITS_SI_BASE_HPP	/usr/include/boost/units/systems/si/base.hpp	12;"	d
BOOST_UNITS_SI_CAPACITANCE_HPP	/usr/include/boost/units/systems/si/capacitance.hpp	12;"	d
BOOST_UNITS_SI_CATALYTIC_ACTIVITY_HPP	/usr/include/boost/units/systems/si/catalytic_activity.hpp	12;"	d
BOOST_UNITS_SI_CONDUCTANCE_HPP	/usr/include/boost/units/systems/si/conductance.hpp	12;"	d
BOOST_UNITS_SI_CONDUCTIVITY_HPP	/usr/include/boost/units/systems/si/conductivity.hpp	12;"	d
BOOST_UNITS_SI_CURRENT_HPP	/usr/include/boost/units/systems/si/current.hpp	12;"	d
BOOST_UNITS_SI_DIMENSIONLESS_HPP	/usr/include/boost/units/systems/si/dimensionless.hpp	12;"	d
BOOST_UNITS_SI_DOSE_EQUIVALENT_HPP	/usr/include/boost/units/systems/si/dose_equivalent.hpp	12;"	d
BOOST_UNITS_SI_DYNAMIC_VISCOSITY_HPP	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	12;"	d
BOOST_UNITS_SI_ELECTRIC_CHARGE_HPP	/usr/include/boost/units/systems/si/electric_charge.hpp	12;"	d
BOOST_UNITS_SI_ELECTRIC_POTENTIAL_HPP	/usr/include/boost/units/systems/si/electric_potential.hpp	12;"	d
BOOST_UNITS_SI_ENERGY_HPP	/usr/include/boost/units/systems/si/energy.hpp	12;"	d
BOOST_UNITS_SI_FORCE_HPP	/usr/include/boost/units/systems/si/force.hpp	12;"	d
BOOST_UNITS_SI_FREQUENCY_HPP	/usr/include/boost/units/systems/si/frequency.hpp	12;"	d
BOOST_UNITS_SI_HPP	/usr/include/boost/units/systems/si.hpp	12;"	d
BOOST_UNITS_SI_ILLUMINANCE_HPP	/usr/include/boost/units/systems/si/illuminance.hpp	12;"	d
BOOST_UNITS_SI_IMPEDANCE_HPP	/usr/include/boost/units/systems/si/impedance.hpp	12;"	d
BOOST_UNITS_SI_INDUCTANCE_HPP	/usr/include/boost/units/systems/si/inductance.hpp	12;"	d
BOOST_UNITS_SI_IO_HPP	/usr/include/boost/units/systems/si/io.hpp	12;"	d
BOOST_UNITS_SI_KINEMATIC_VISCOSITY_HPP	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	12;"	d
BOOST_UNITS_SI_LENGTH_HPP	/usr/include/boost/units/systems/si/length.hpp	12;"	d
BOOST_UNITS_SI_LUMINOUS_FLUX_HPP	/usr/include/boost/units/systems/si/luminous_flux.hpp	12;"	d
BOOST_UNITS_SI_LUMINOUS_INTENSITY_HPP	/usr/include/boost/units/systems/si/luminous_intensity.hpp	12;"	d
BOOST_UNITS_SI_MAGNETIC_FIELD_INTENSITY_HPP	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	12;"	d
BOOST_UNITS_SI_MAGNETIC_FLUX_DENSITY_HPP	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	12;"	d
BOOST_UNITS_SI_MAGNETIC_FLUX_HPP	/usr/include/boost/units/systems/si/magnetic_flux.hpp	12;"	d
BOOST_UNITS_SI_MASS_DENSITY_HPP	/usr/include/boost/units/systems/si/mass_density.hpp	12;"	d
BOOST_UNITS_SI_MASS_HPP	/usr/include/boost/units/systems/si/mass.hpp	12;"	d
BOOST_UNITS_SI_MOMENTUM_HPP	/usr/include/boost/units/systems/si/momentum.hpp	12;"	d
BOOST_UNITS_SI_MOMENT_OF_INERTIA_HPP	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	12;"	d
BOOST_UNITS_SI_PERMEABILITY_HPP	/usr/include/boost/units/systems/si/permeability.hpp	12;"	d
BOOST_UNITS_SI_PERMITTIVITY_HPP	/usr/include/boost/units/systems/si/permittivity.hpp	12;"	d
BOOST_UNITS_SI_PLANE_ANGLE_HPP	/usr/include/boost/units/systems/si/plane_angle.hpp	12;"	d
BOOST_UNITS_SI_POWER_HPP	/usr/include/boost/units/systems/si/power.hpp	12;"	d
BOOST_UNITS_SI_PREFIXES_HPP	/usr/include/boost/units/systems/si/prefixes.hpp	12;"	d
BOOST_UNITS_SI_PRESSURE_HPP	/usr/include/boost/units/systems/si/pressure.hpp	12;"	d
BOOST_UNITS_SI_RELUCTANCE_HPP	/usr/include/boost/units/systems/si/reluctance.hpp	12;"	d
BOOST_UNITS_SI_RESISTANCE_HPP	/usr/include/boost/units/systems/si/resistance.hpp	12;"	d
BOOST_UNITS_SI_RESISTIVITY_HPP	/usr/include/boost/units/systems/si/resistivity.hpp	12;"	d
BOOST_UNITS_SI_SOLID_ANGLE_HPP	/usr/include/boost/units/systems/si/solid_angle.hpp	12;"	d
BOOST_UNITS_SI_SURFACE_DENSITY_HPP	/usr/include/boost/units/systems/si/surface_density.hpp	12;"	d
BOOST_UNITS_SI_SURFACE_TENSION_HPP	/usr/include/boost/units/systems/si/surface_tension.hpp	12;"	d
BOOST_UNITS_SI_TEMPERATURE_HPP	/usr/include/boost/units/systems/si/temperature.hpp	12;"	d
BOOST_UNITS_SI_TIME_HPP	/usr/include/boost/units/systems/si/time.hpp	12;"	d
BOOST_UNITS_SI_TORQUE_HPP	/usr/include/boost/units/systems/si/torque.hpp	12;"	d
BOOST_UNITS_SI_VELOCITY_HPP	/usr/include/boost/units/systems/si/velocity.hpp	12;"	d
BOOST_UNITS_SI_VOLUME_HPP	/usr/include/boost/units/systems/si/volume.hpp	12;"	d
BOOST_UNITS_SI_WAVENUMBER_HPP	/usr/include/boost/units/systems/si/wavenumber.hpp	12;"	d
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/degrees.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degree,plane_angle);$/;"	p	namespace:boost::units::degree	signature:(degree,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/degrees.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degrees,plane_angle);$/;"	p	namespace:boost::units::degree	signature:(degrees,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/gradians.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gradian,plane_angle);$/;"	p	namespace:boost::units::gradian	signature:(gradian,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/gradians.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gradians,plane_angle);$/;"	p	namespace:boost::units::gradian	signature:(gradians,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/revolutions.hpp	/^BOOST_UNITS_STATIC_CONSTANT(revolution,plane_angle);$/;"	p	namespace:boost::units::revolution	signature:(revolution,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/angle/revolutions.hpp	/^BOOST_UNITS_STATIC_CONSTANT(revolutions,plane_angle);$/;"	p	namespace:boost::units::revolution	signature:(revolutions,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gal,acceleration);  $/;"	p	namespace:boost::units::cgs	signature:(gal,acceleration)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gals,acceleration); $/;"	p	namespace:boost::units::cgs	signature:(gals,acceleration)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimeter,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimeter,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimeters,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimeters,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimetre,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimetre,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_centimetres,area);$/;"	p	namespace:boost::units::cgs	signature:(square_centimetres,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(biot,current);$/;"	p	namespace:boost::units::cgs	signature:(biot,current)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(biots,current);$/;"	p	namespace:boost::units::cgs	signature:(biots,current)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/dimensionless.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cgs_dimensionless,dimensionless);$/;"	p	namespace:boost::units::cgs	signature:(cgs_dimensionless,dimensionless)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(poise,dynamic_viscosity);    $/;"	p	namespace:boost::units::cgs	signature:(poise,dynamic_viscosity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(erg,energy);$/;"	p	namespace:boost::units::cgs	signature:(erg,energy)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ergs,energy);$/;"	p	namespace:boost::units::cgs	signature:(ergs,energy)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(dyne,force);$/;"	p	namespace:boost::units::cgs	signature:(dyne,force)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(dynes,force);$/;"	p	namespace:boost::units::cgs	signature:(dynes,force)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(stoke,kinematic_viscosity);           $/;"	p	namespace:boost::units::cgs	signature:(stoke,kinematic_viscosity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(stokes,kinematic_viscosity);    $/;"	p	namespace:boost::units::cgs	signature:(stokes,kinematic_viscosity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeter,length); $/;"	p	namespace:boost::units::cgs	signature:(centimeter,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeters,length);    $/;"	p	namespace:boost::units::cgs	signature:(centimeters,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetre,length); $/;"	p	namespace:boost::units::cgs	signature:(centimetre,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetres,length);    $/;"	p	namespace:boost::units::cgs	signature:(centimetres,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gram,mass); $/;"	p	namespace:boost::units::cgs	signature:(gram,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gramme,mass);   $/;"	p	namespace:boost::units::cgs	signature:(gramme,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(grammes,mass);  $/;"	p	namespace:boost::units::cgs	signature:(grammes,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(grams,mass);    $/;"	p	namespace:boost::units::cgs	signature:(grams,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(barye,pressure);    $/;"	p	namespace:boost::units::cgs	signature:(barye,pressure)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(baryes,pressure);   $/;"	p	namespace:boost::units::cgs	signature:(baryes,pressure)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(second,time);   $/;"	p	namespace:boost::units::cgs	signature:(second,time)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(seconds,time);  $/;"	p	namespace:boost::units::cgs	signature:(seconds,time)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeters_per_second,velocity);   $/;"	p	namespace:boost::units::cgs	signature:(centimeters_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimeter_per_second,velocity);    $/;"	p	namespace:boost::units::cgs	signature:(centimeter_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetres_per_second,velocity);   $/;"	p	namespace:boost::units::cgs	signature:(centimetres_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(centimetre_per_second,velocity);    $/;"	p	namespace:boost::units::cgs	signature:(centimetre_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimeter,volume);   $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimeter,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimeters,volume);  $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimeters,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimetre,volume);   $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimetre,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_centimetres,volume);  $/;"	p	namespace:boost::units::cgs	signature:(cubic_centimetres,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kayser,wavenumber); $/;"	p	namespace:boost::units::cgs	signature:(kayser,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kaysers,wavenumber);    $/;"	p	namespace:boost::units::cgs	signature:(kaysers,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimeter,wavenumber);  $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimeter,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimeters,wavenumber); $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimeters,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimetre,wavenumber);  $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimetre,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_centimetres,wavenumber); $/;"	p	namespace:boost::units::cgs	signature:(reciprocal_centimetres,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^BOOST_UNITS_STATIC_CONSTANT(gray,absorbed_dose);  $/;"	p	namespace:boost::units::si	signature:(gray,absorbed_dose)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^BOOST_UNITS_STATIC_CONSTANT(grays,absorbed_dose); $/;"	p	namespace:boost::units::si	signature:(grays,absorbed_dose)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meters_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(meters_per_second_squared,acceleration)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meter_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(meter_per_second_squared,acceleration)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metres_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(metres_per_second_squared,acceleration)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/acceleration.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metre_per_second_squared,acceleration);$/;"	p	namespace:boost::units::si	signature:(metre_per_second_squared,acceleration)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(becquerel,activity);$/;"	p	namespace:boost::units::si	signature:(becquerel,activity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(becquerels,activity);$/;"	p	namespace:boost::units::si	signature:(becquerels,activity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/amount.hpp	/^BOOST_UNITS_STATIC_CONSTANT(mole,amount);$/;"	p	namespace:boost::units::si	signature:(mole,amount)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/amount.hpp	/^BOOST_UNITS_STATIC_CONSTANT(moles,amount);$/;"	p	namespace:boost::units::si	signature:(moles,amount)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radians_per_second,angular_velocity);    $/;"	p	namespace:boost::units::si	signature:(radians_per_second,angular_velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radian_per_second,angular_velocity); $/;"	p	namespace:boost::units::si	signature:(radian_per_second,angular_velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_meter,area);$/;"	p	namespace:boost::units::si	signature:(square_meter,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_meters,area);$/;"	p	namespace:boost::units::si	signature:(square_meters,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_metre,area);$/;"	p	namespace:boost::units::si	signature:(square_metre,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/area.hpp	/^BOOST_UNITS_STATIC_CONSTANT(square_metres,area);$/;"	p	namespace:boost::units::si	signature:(square_metres,area)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/capacitance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(farad,capacitance);$/;"	p	namespace:boost::units::si	signature:(farad,capacitance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/capacitance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(farads,capacitance);$/;"	p	namespace:boost::units::si	signature:(farads,capacitance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(katal,catalytic_activity);$/;"	p	namespace:boost::units::si	signature:(katal,catalytic_activity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(katals,catalytic_activity);$/;"	p	namespace:boost::units::si	signature:(katals,catalytic_activity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(mho,conductance);   $/;"	p	namespace:boost::units::si	signature:(mho,conductance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(mhos,conductance);  $/;"	p	namespace:boost::units::si	signature:(mhos,conductance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(siemen,conductance);    $/;"	p	namespace:boost::units::si	signature:(siemen,conductance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/conductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(siemens,conductance);   $/;"	p	namespace:boost::units::si	signature:(siemens,conductance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ampere,current);$/;"	p	namespace:boost::units::si	signature:(ampere,current)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/current.hpp	/^BOOST_UNITS_STATIC_CONSTANT(amperes,current);$/;"	p	namespace:boost::units::si	signature:(amperes,current)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/dimensionless.hpp	/^BOOST_UNITS_STATIC_CONSTANT(si_dimensionless,dimensionless);$/;"	p	namespace:boost::units::si	signature:(si_dimensionless,dimensionless)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^BOOST_UNITS_STATIC_CONSTANT(sievert,dose_equivalent);  $/;"	p	namespace:boost::units::si	signature:(sievert,dose_equivalent)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^BOOST_UNITS_STATIC_CONSTANT(sieverts,dose_equivalent); $/;"	p	namespace:boost::units::si	signature:(sieverts,dose_equivalent)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_charge.hpp	/^BOOST_UNITS_STATIC_CONSTANT(coulomb,electric_charge);   $/;"	p	namespace:boost::units::si	signature:(coulomb,electric_charge)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_charge.hpp	/^BOOST_UNITS_STATIC_CONSTANT(coulombs,electric_charge);  $/;"	p	namespace:boost::units::si	signature:(coulombs,electric_charge)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_potential.hpp	/^BOOST_UNITS_STATIC_CONSTANT(volt,electric_potential);   $/;"	p	namespace:boost::units::si	signature:(volt,electric_potential)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/electric_potential.hpp	/^BOOST_UNITS_STATIC_CONSTANT(volts,electric_potential);  $/;"	p	namespace:boost::units::si	signature:(volts,electric_potential)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(joule,energy);  $/;"	p	namespace:boost::units::si	signature:(joule,energy)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/energy.hpp	/^BOOST_UNITS_STATIC_CONSTANT(joules,energy); $/;"	p	namespace:boost::units::si	signature:(joules,energy)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton,force);  $/;"	p	namespace:boost::units::si	signature:(newton,force)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/force.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newtons,force); $/;"	p	namespace:boost::units::si	signature:(newtons,force)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/frequency.hpp	/^BOOST_UNITS_STATIC_CONSTANT(hertz,frequency);   $/;"	p	namespace:boost::units::si	signature:(hertz,frequency)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/illuminance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(lux,illuminance); $/;"	p	namespace:boost::units::si	signature:(lux,illuminance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/inductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(henry,inductance);  $/;"	p	namespace:boost::units::si	signature:(henry,inductance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/inductance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(henrys,inductance); $/;"	p	namespace:boost::units::si	signature:(henrys,inductance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meter,length);  $/;"	p	namespace:boost::units::si	signature:(meter,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meters,length); $/;"	p	namespace:boost::units::si	signature:(meters,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metre,length);  $/;"	p	namespace:boost::units::si	signature:(metre,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/length.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metres,length); $/;"	p	namespace:boost::units::si	signature:(metres,length)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(lumen,luminous_flux); $/;"	p	namespace:boost::units::si	signature:(lumen,luminous_flux)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(lumens,luminous_flux);    $/;"	p	namespace:boost::units::si	signature:(lumens,luminous_flux)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(candela,luminous_intensity); $/;"	p	namespace:boost::units::si	signature:(candela,luminous_intensity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(candelas,luminous_intensity);    $/;"	p	namespace:boost::units::si	signature:(candelas,luminous_intensity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(weber,magnetic_flux);   $/;"	p	namespace:boost::units::si	signature:(weber,magnetic_flux)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^BOOST_UNITS_STATIC_CONSTANT(webers,magnetic_flux);  $/;"	p	namespace:boost::units::si	signature:(webers,magnetic_flux)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(tesla,magnetic_flux_density);   $/;"	p	namespace:boost::units::si	signature:(tesla,magnetic_flux_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(teslas,magnetic_flux_density);  $/;"	p	namespace:boost::units::si	signature:(teslas,magnetic_flux_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogram,mass); $/;"	p	namespace:boost::units::si	signature:(kilogram,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogramme,mass);   $/;"	p	namespace:boost::units::si	signature:(kilogramme,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogrammes,mass);  $/;"	p	namespace:boost::units::si	signature:(kilogrammes,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilograms,mass);    $/;"	p	namespace:boost::units::si	signature:(kilograms,mass)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogrammes_per_cubic_metre,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilogrammes_per_cubic_metre,mass_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogramme_per_cubic_metre,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilogramme_per_cubic_metre,mass_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilograms_per_cubic_meter,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilograms_per_cubic_meter,mass_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/mass_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogram_per_cubic_meter,mass_density);$/;"	p	namespace:boost::units::si	signature:(kilogram_per_cubic_meter,mass_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/plane_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radian,plane_angle); $/;"	p	namespace:boost::units::si	signature:(radian,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/plane_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(radians,plane_angle);    $/;"	p	namespace:boost::units::si	signature:(radians,plane_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/power.hpp	/^BOOST_UNITS_STATIC_CONSTANT(watt,power);    $/;"	p	namespace:boost::units::si	signature:(watt,power)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/power.hpp	/^BOOST_UNITS_STATIC_CONSTANT(watts,power);   $/;"	p	namespace:boost::units::si	signature:(watts,power)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(pascal,pressure);   $/;"	p	namespace:boost::units::si	signature:(pascal,pressure)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/pressure.hpp	/^BOOST_UNITS_STATIC_CONSTANT(pascals,pressure);  $/;"	p	namespace:boost::units::si	signature:(pascals,pressure)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/resistance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ohm,resistance);    $/;"	p	namespace:boost::units::si	signature:(ohm,resistance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/resistance.hpp	/^BOOST_UNITS_STATIC_CONSTANT(ohms,resistance);   $/;"	p	namespace:boost::units::si	signature:(ohms,resistance)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/solid_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(steradian,solid_angle); $/;"	p	namespace:boost::units::si	signature:(steradian,solid_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/solid_angle.hpp	/^BOOST_UNITS_STATIC_CONSTANT(steradians,solid_angle);    $/;"	p	namespace:boost::units::si	signature:(steradians,solid_angle)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogrammes_per_square_metre,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilogrammes_per_square_metre,surface_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogramme_per_square_metre,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilogramme_per_square_metre,surface_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilograms_per_square_meter,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilograms_per_square_meter,surface_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_density.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kilogram_per_square_meter,surface_density);$/;"	p	namespace:boost::units::si	signature:(kilogram_per_square_meter,surface_density)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_tension.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newtons_per_meter,surface_tension); $/;"	p	namespace:boost::units::si	signature:(newtons_per_meter,surface_tension)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/surface_tension.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton_per_meter,surface_tension);  $/;"	p	namespace:boost::units::si	signature:(newton_per_meter,surface_tension)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/temperature.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kelvin,temperature);    $/;"	p	namespace:boost::units::si	signature:(kelvin,temperature)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/temperature.hpp	/^BOOST_UNITS_STATIC_CONSTANT(kelvins,temperature);   $/;"	p	namespace:boost::units::si	signature:(kelvins,temperature)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(second,time);   $/;"	p	namespace:boost::units::si	signature:(second,time)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/time.hpp	/^BOOST_UNITS_STATIC_CONSTANT(seconds,time);  $/;"	p	namespace:boost::units::si	signature:(seconds,time)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/torque.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton_meter,torque);  $/;"	p	namespace:boost::units::si	signature:(newton_meter,torque)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/torque.hpp	/^BOOST_UNITS_STATIC_CONSTANT(newton_meters,torque); $/;"	p	namespace:boost::units::si	signature:(newton_meters,torque)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meters_per_second,velocity);    $/;"	p	namespace:boost::units::si	signature:(meters_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(meter_per_second,velocity); $/;"	p	namespace:boost::units::si	signature:(meter_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metres_per_second,velocity);    $/;"	p	namespace:boost::units::si	signature:(metres_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/velocity.hpp	/^BOOST_UNITS_STATIC_CONSTANT(metre_per_second,velocity); $/;"	p	namespace:boost::units::si	signature:(metre_per_second,velocity)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_meter,volume);    $/;"	p	namespace:boost::units::si	signature:(cubic_meter,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_meters,volume);   $/;"	p	namespace:boost::units::si	signature:(cubic_meters,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_metre,volume);    $/;"	p	namespace:boost::units::si	signature:(cubic_metre,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/volume.hpp	/^BOOST_UNITS_STATIC_CONSTANT(cubic_metres,volume);   $/;"	p	namespace:boost::units::si	signature:(cubic_metres,volume)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_meter,wavenumber);   $/;"	p	namespace:boost::units::si	signature:(reciprocal_meter,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_meters,wavenumber);  $/;"	p	namespace:boost::units::si	signature:(reciprocal_meters,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_metre,wavenumber);   $/;"	p	namespace:boost::units::si	signature:(reciprocal_metre,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/si/wavenumber.hpp	/^BOOST_UNITS_STATIC_CONSTANT(reciprocal_metres,wavenumber);  $/;"	p	namespace:boost::units::si	signature:(reciprocal_metres,wavenumber)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/celsius.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degree,temperature);$/;"	p	namespace:boost::units::celsius	signature:(degree,temperature)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/celsius.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degrees,temperature);$/;"	p	namespace:boost::units::celsius	signature:(degrees,temperature)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degree,temperature);$/;"	p	namespace:boost::units::fahrenheit	signature:(degree,temperature)
BOOST_UNITS_STATIC_CONSTANT	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^BOOST_UNITS_STATIC_CONSTANT(degrees,temperature);$/;"	p	namespace:boost::units::fahrenheit	signature:(degrees,temperature)
BOOST_UNITS_TEMPERATURE_CELSIUS_HPP	/usr/include/boost/units/systems/temperature/celsius.hpp	12;"	d
BOOST_UNITS_TEMPERATURE_FAHRENHEIT_HPP	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	12;"	d
BOOST_UTF8_BEGIN_NAMESPACE	/usr/include/boost/filesystem/detail/utf8_codecvt_facet.hpp	12;"	d
BOOST_UTF8_BEGIN_NAMESPACE	/usr/include/boost/filesystem/detail/utf8_codecvt_facet.hpp	20;"	d
BOOST_UTF8_DECL	/usr/include/boost/filesystem/detail/utf8_codecvt_facet.hpp	16;"	d
BOOST_UTF8_DECL	/usr/include/boost/filesystem/detail/utf8_codecvt_facet.hpp	22;"	d
BOOST_UTF8_END_NAMESPACE	/usr/include/boost/filesystem/detail/utf8_codecvt_facet.hpp	15;"	d
BOOST_UTF8_END_NAMESPACE	/usr/include/boost/filesystem/detail/utf8_codecvt_facet.hpp	21;"	d
BOOST_W32_REGEX_TRAITS_HPP_INCLUDED	/usr/include/boost/regex/v4/w32_regex_traits.hpp	20;"	d
BOOST_WAVE_FILESYSTEM_COMPATIBILITY_MAR_09_2009_0142PM	/usr/include/boost/wave/util/filesystem_compatibility.hpp	12;"	d
BOOST_WINDOWS_API	/usr/include/boost/system/api_config.hpp	37;"	d
BOOST_WINDOWS_ERROR_HPP	/usr/include/boost/system/windows_error.hpp	11;"	d
BOOST_XPRESSIVE_ACTIONS_HPP_EAN_03_22_2007	/usr/include/boost/xpressive/regex_actions.hpp	10;"	d
BOOST_XPRESSIVE_ALGORITHMS_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_algorithms.hpp	10;"	d
BOOST_XPRESSIVE_BASIC_REGEX_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/basic_regex.hpp	11;"	d
BOOST_XPRESSIVE_BUGGY_CTYPE_FACET	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	39;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_REGEX_BYREF_MATCHER_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_REGEX_MATCHER_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_REGEX_DOMAIN_HPP_EAN_12_12_2009	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	10;"	d
BOOST_XPRESSIVE_DETAIL_CORE_REGEX_IMPL_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	9;"	d
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s0, 0);$/;"	p	namespace:boost::xpressive	signature:(s0, 0)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s1, 1);$/;"	p	namespace:boost::xpressive	signature:(s1, 1)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s2, 2);$/;"	p	namespace:boost::xpressive	signature:(s2, 2)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s3, 3);$/;"	p	namespace:boost::xpressive	signature:(s3, 3)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s4, 4);$/;"	p	namespace:boost::xpressive	signature:(s4, 4)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s5, 5);$/;"	p	namespace:boost::xpressive	signature:(s5, 5)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s6, 6);$/;"	p	namespace:boost::xpressive	signature:(s6, 6)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s7, 7);$/;"	p	namespace:boost::xpressive	signature:(s7, 7)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s8, 8);$/;"	p	namespace:boost::xpressive	signature:(s8, 8)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s9, 9);$/;"	p	namespace:boost::xpressive	signature:(s9, 9)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	/usr/include/boost/xpressive/regex_primitives.hpp	577;"	d
BOOST_XPRESSIVE_REGEX_COMPILER_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_compiler.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_CONSTANTS_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_constants.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_ERROR_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_error.hpp	10;"	d
BOOST_XPRESSIVE_REGEX_ITERATOR_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_iterator.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_PRIMITIVES_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_primitives.hpp	10;"	d
BOOST_XPRESSIVE_REGEX_TOKEN_ITERATOR_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_token_iterator.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_TRAITS_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/regex_traits.hpp	11;"	d
BOOST_XPRESSIVE_TRAITS_CPP_REGEX_TRAITS_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	12;"	d
BOOST_XPRESSIVE_TRAITS_C_REGEX_TRAITS_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	12;"	d
BOOST_XPRESSIVE_TRAITS_NULL_REGEX_TRAITS_HPP_EAN_10_04_2005	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	12;"	d
BOOST_XPR_ENSURE_	/usr/include/boost/xpressive/regex_error.hpp	108;"	d
BOOST_XPR_NONDEDUCED_TYPE_	/usr/include/boost/xpressive/regex_algorithms.hpp	34;"	d
bos	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bos_matcher>::type const bos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
bound_type	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef typename selector::template rebind<I> bound_type;$/;"	t	struct:boost::is_random_access_iterator	access:private
bow	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_begin>::type const bow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
branch_path	/usr/include/boost/filesystem/path.hpp	/^    path   branch_path() const      { return parent_path(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
branch_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path branch_path(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
broken_pipe	/usr/include/boost/system/error_code.hpp	/^        broken_pipe = EPIPE,$/;"	e	enum:boost::system::errc::errc_t
broken_pipe	/usr/include/boost/system/windows_error.hpp	/^        broken_pipe = ERROR_BROKEN_PIPE,$/;"	e	enum:boost::system::windows_error::windows_error_code
bubble_down_one	/usr/include/boost/regex/v4/basic_regex.hpp	/^void bubble_down_one(I first, I last)$/;"	f	namespace:boost::re_detail	signature:(I first, I last)
buffer	/usr/include/boost/filesystem/operations.hpp	/^    void*            buffer;  \/\/ see dir_itr_increment implementation$/;"	m	struct:boost::filesystem::detail::dir_itr_imp	access:public
buffer_overflow	/usr/include/boost/system/windows_error.hpp	/^        buffer_overflow = ERROR_BUFFER_OVERFLOW,$/;"	e	enum:boost::system::windows_error::windows_error_code
busy	/usr/include/boost/system/windows_error.hpp	/^        busy = ERROR_BUSY,$/;"	e	enum:boost::system::windows_error::windows_error_code
by_ref	/usr/include/boost/xpressive/regex_primitives.hpp	/^by_ref(basic_regex<BidiIter> const &rex)$/;"	f	class:boost::xpressive::proto::terminal	signature:(basic_regex<BidiIter> const &rex)
cached_blocks	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   unsigned cached_blocks;$/;"	m	struct:boost::re_detail::mem_block_cache	access:public
calculate_backstep	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   int calculate_backstep(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
calculate_backstep	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^int basic_regex_creator<charT, traits>::calculate_backstep(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
calendar_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename date_type::calendar_type calendar_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
call	/usr/include/boost/regex/v4/protected_call.hpp	/^   virtual bool call()const = 0;$/;"	p	class:boost::re_detail::abstract_protected_call	access:private	signature:() const
call	/usr/include/boost/regex/v4/protected_call.hpp	/^   virtual bool call()const;$/;"	p	class:boost::re_detail::concrete_protected_call	access:private	signature:() const
call	/usr/include/boost/regex/v4/protected_call.hpp	/^bool concrete_protected_call<T>::call()const$/;"	f	class:boost::re_detail::concrete_protected_call	signature:() const
cancel_violation	/usr/include/boost/system/windows_error.hpp	/^        cancel_violation = ERROR_CANCEL_VIOLATION,$/;"	e	enum:boost::system::windows_error::windows_error_code
cannot_make	/usr/include/boost/system/windows_error.hpp	/^        cannot_make = ERROR_CANNOT_MAKE,$/;"	e	enum:boost::system::windows_error::windows_error_code
canonical	/usr/include/boost/filesystem/operations.hpp	/^    path canonical(const path& p, const path& base, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, const path& base, system::error_code* ec=0)
canonical	/usr/include/boost/filesystem/operations.hpp	/^  path canonical(const path& p, const path& base, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const path& base, system::error_code& ec)
canonical	/usr/include/boost/filesystem/operations.hpp	/^  path canonical(const path& p, const path& base=current_path())$/;"	f	namespace:boost::filesystem	signature:(const path& p, const path& base=current_path())
canonical	/usr/include/boost/filesystem/operations.hpp	/^  path canonical(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
can_be_null	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool can_be_null()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
can_be_null	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool can_be_null()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
can_be_null	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int    can_be_null;         \/\/ true if we match a NULL string$/;"	m	struct:boost::re_detail::re_alt	access:public
can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(char c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(char c, const unsigned char* map, unsigned char mask)
can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(charT c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(charT c, const unsigned char* map, unsigned char mask)
can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(signed char c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(signed char c, const unsigned char* map, unsigned char mask)
can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(unsigned char c, const unsigned char* map, unsigned char mask)
can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(unsigned int c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(unsigned int c, const unsigned char* map, unsigned char mask)
can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(unsigned short c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(unsigned short c, const unsigned char* map, unsigned char mask)
can_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline bool can_start(wchar_t c, const unsigned char* map, unsigned char mask)$/;"	f	namespace:boost::re_detail	signature:(wchar_t c, const unsigned char* map, unsigned char mask)
capacitance	/usr/include/boost/units/systems/si/capacitance.hpp	/^typedef unit<capacitance_dimension,si::system>    capacitance;$/;"	t	namespace:boost::units::si
capacitance_over_length	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<capacitance,length>::type capacitance_over_length;$/;"	t	namespace:boost::units::si::constants::codata
capacity	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t capacity;$/;"	m	struct:boost::filesystem::space_info	access:public
capacity	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   size_type BOOST_REGEX_CALL capacity()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
captures	/usr/include/boost/regex/v4/match_results.hpp	/^   const capture_sequence_type& captures(int i)const$/;"	f	class:boost::match_results	access:public	signature:(int i) const
captures	/usr/include/boost/regex/v4/sub_match.hpp	/^   const capture_sequence_type& captures()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
capture_sequence_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename sub_match<BidiIterator>::capture_sequence_type capture_sequence_type;$/;"	t	class:boost::match_results	access:public
capture_sequence_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef std::vector<sub_match<BidiIterator> > capture_sequence_type;$/;"	t	struct:boost::sub_match	access:public
cast	/usr/include/boost/xpressive/regex_actions.hpp	/^            reference cast(void *pv) const$/;"	f	struct:boost::xpressive::detail::action_arg	access:public	signature:(void *pv) const
cat	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef typename std::iterator_traits<I>::iterator_category cat;$/;"	t	struct:boost::detail::is_random_imp	access:private
catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static std::string catalog_name(const std::string& name);$/;"	p	class:boost::cpp_regex_traits	access:public	signature:(const std::string& name)
catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::string cpp_regex_traits<charT>::catalog_name(const std::string& name)$/;"	f	class:boost::cpp_regex_traits	signature:(const std::string& name)
catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static std::string catalog_name(const std::string& name);$/;"	p	class:boost::w32_regex_traits	access:public	signature:(const std::string& name)
catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^std::string w32_regex_traits<charT>::catalog_name(const std::string& name)$/;"	f	class:boost::w32_regex_traits	signature:(const std::string& name)
catalytic_activity	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^typedef unit<si::catalytic_activity_dim,si::system>                                    catalytic_activity;$/;"	t	namespace:boost::units::si
catalytic_activity_dim	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^typedef derived_dimension<time_base_dimension,-1,amount_base_dimension,1>::type                             catalytic_activity_dim;    $/;"	t	namespace:boost::units::si
category	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef typename base_type::category               category;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
category	/usr/include/boost/system/error_code.hpp	/^      const error_category &  category() const { return *m_cat; }$/;"	f	class:boost::system::error_code	access:public	signature:() const
category	/usr/include/boost/system/error_code.hpp	/^      const error_category &  category() const { return *m_cat; }$/;"	f	class:boost::system::error_condition	access:public	signature:() const
cat_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^typedef ::boost::shared_ptr<void> cat_type; \/\/ placeholder for dll HANDLE.$/;"	t	namespace:boost::re_detail
cclasses	/usr/include/boost/regex/v4/states.hpp	/^   mask_type               cclasses;$/;"	m	struct:boost::re_detail::re_set_long	access:public
celsius	/usr/include/boost/units/systems/temperature/celsius.hpp	/^namespace celsius {$/;"	n	namespace:boost::units
cequivalents	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int            csingles, cranges, cequivalents;$/;"	m	struct:boost::re_detail::re_set_long	access:public
cgs	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/area.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/base.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/current.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/dimensionless.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/energy.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/force.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/frequency.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/length.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/mass.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/mass_density.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/momentum.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/power.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/pressure.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/time.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/velocity.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/volume.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
cgs	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^namespace cgs {$/;"	n	namespace:boost::units
change_extension	/usr/include/boost/filesystem/convenience.hpp	/^    inline path change_extension( const path & p, const path & new_extension )$/;"	f	namespace:boost::filesystem	signature:( const path & p, const path & new_extension )
channel_range	/usr/include/boost/system/linux_error.hpp	/^        channel_range = ECHRNG,$/;"	e	enum:boost::system::linux_error::linux_errno
character_file	/usr/include/boost/filesystem/operations.hpp	/^    character_file,$/;"	e	enum:boost::filesystem::file_type
character_pointer_range	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^struct character_pointer_range$/;"	s	namespace:boost::re_detail
char_architype	/usr/include/boost/regex/concepts.hpp	/^   char_architype();$/;"	p	struct:boost::char_architype	access:public	signature:()
char_architype	/usr/include/boost/regex/concepts.hpp	/^   char_architype(const char_architype&);$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&)
char_architype	/usr/include/boost/regex/concepts.hpp	/^   char_architype(unsigned long val);$/;"	p	struct:boost::char_architype	access:public	signature:(unsigned long val)
char_architype	/usr/include/boost/regex/concepts.hpp	/^struct char_architype$/;"	s	namespace:boost
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 16);$/;"	m	class:boost::u16_to_u32_iterator	access:private
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 32);$/;"	m	class:boost::u32_to_u16_iterator	access:private
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 32);$/;"	m	class:boost::u32_to_u8_iterator	access:private
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(base_value_type)*CHAR_BIT == 8);$/;"	m	class:boost::u8_to_u32_iterator	access:private
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U16Type)*CHAR_BIT == 16);$/;"	m	class:boost::u32_to_u16_iterator	access:private
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U32Type)*CHAR_BIT == 32);$/;"	m	class:boost::u16_to_u32_iterator	access:private
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U32Type)*CHAR_BIT == 32);$/;"	m	class:boost::u8_to_u32_iterator	access:private
CHAR_BIT	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BOOST_STATIC_ASSERT(sizeof(U8Type)*CHAR_BIT == 8);$/;"	m	class:boost::u32_to_u8_iterator	access:private
char_class	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_pair const &char_class(std::size_t j)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(std::size_t j)
char_class_alnum	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_alnum=char_class_alpha|char_class_digit, $/;"	e	enum:boost::re_detail::__anon2
char_class_alpha	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_alpha=1<<5, $/;"	e	enum:boost::re_detail::__anon2
char_class_blank	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_blank=1<<9,$/;"	e	enum:boost::re_detail::__anon2
char_class_cntrl	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_cntrl=1<<2, $/;"	e	enum:boost::re_detail::__anon2
char_class_digit	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_digit=1<<6, $/;"	e	enum:boost::re_detail::__anon2
char_class_graph	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_graph=char_class_alnum|char_class_punct,$/;"	e	enum:boost::re_detail::__anon2
char_class_horizontal_space	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_horizontal_space=1<<12,$/;"	e	enum:boost::re_detail::__anon2
char_class_lower	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_lower=1<<4,$/;"	e	enum:boost::re_detail::__anon2
char_class_pair	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct char_class_pair$/;"	s	struct:boost::xpressive::cpp_regex_traits	access:private
char_class_print	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_print=1<<1, $/;"	e	enum:boost::re_detail::__anon2
char_class_punct	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_punct=1<<7, $/;"	e	enum:boost::re_detail::__anon2
char_class_space	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_space=1<<0, $/;"	e	enum:boost::re_detail::__anon2
char_class_type	/usr/include/boost/regex/concepts.hpp	/^   typedef bitmask_archetype char_class_type;$/;"	t	struct:boost::regex_traits_architype	access:public
char_class_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::char_class_type char_class_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
char_class_type	/usr/include/boost/regex/icu.hpp	/^   typedef boost::uint64_t              char_class_type;$/;"	t	class:boost::icu_regex_traits	access:public
char_class_type	/usr/include/boost/regex/icu.hpp	/^   typedef boost::uint_least32_t        char_class_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
char_class_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::bitset<64>              char_class_type;$/;"	t	class:boost::icu_regex_traits	access:public
char_class_type	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   typedef typename traits::char_class_type char_class_type;$/;"	t	class:boost::re_detail::basic_regex_parser	access:private
char_class_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef boost::uint_least32_t        char_class_type;$/;"	t	class:boost::cpp_regex_traits	access:public
char_class_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename cpp_regex_traits<charT>::char_class_type char_class_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
char_class_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef boost::uint32_t char_class_type;$/;"	t	struct:boost::c_regex_traits	access:public
char_class_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef boost::uint_least32_t         char_class_type;$/;"	t	class:boost::w32_regex_traits	access:public
char_class_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef typename w32_regex_traits<charT>::char_class_type char_class_type;$/;"	t	class:boost::re_detail::w32_regex_traits_implementation	access:public
char_class_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename traits_type::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
char_class_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::umaskex_t char_class_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
char_class_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef typename detail::char_class_impl<Char>::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
char_class_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef int char_class_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
char_class_unicode	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_unicode=1<<11,$/;"	e	enum:boost::re_detail::__anon2
char_class_upper	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_upper=1<<3, $/;"	e	enum:boost::re_detail::__anon2
char_class_vertical_space	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_vertical_space=1<<13$/;"	e	enum:boost::re_detail::__anon2
char_class_word	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_word=1<<10,$/;"	e	enum:boost::re_detail::__anon2
char_class_xdigit	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_xdigit=1<<8,$/;"	e	enum:boost::re_detail::__anon2
char_less	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline bool char_less(char t1, char t2)$/;"	f	namespace:boost::re_detail	signature:(char t1, char t2)
char_less	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline bool char_less(signed char t1, signed char t2)$/;"	f	namespace:boost::re_detail	signature:(signed char t1, signed char t2)
char_less	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^inline bool char_less(T t1, T t2)$/;"	f	namespace:boost::re_detail	signature:(T t1, T t2)
char_regex_traits_i	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^class char_regex_traits_i : public regex_traits<charT> {};$/;"	c	namespace:boost::deprecated	inherits:regex_traits
char_regex_traits_i	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^class char_regex_traits_i<char> : public regex_traits<char>$/;"	c	namespace:boost::deprecated	inherits:regex_traits
char_regex_traits_i	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^class char_regex_traits_i<wchar_t> : public regex_traits<wchar_t>$/;"	c	namespace:boost::deprecated	inherits:regex_traits
char_traits	/usr/include/boost/regex/concepts.hpp	/^   template<> struct char_traits<boost::char_architype>$/;"	s	namespace:std
char_type	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                typedef BOOST_STRING_TYPENAME StringT::value_type char_type;$/;"	t	struct:boost::algorithm::detail::regex_formatF	access:private
char_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef typename base_type::char_type              char_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
char_type	/usr/include/boost/regex/concepts.hpp	/^      typedef boost::char_architype char_type;$/;"	t	struct:std::char_traits	access:public
char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef charT char_type;$/;"	t	struct:boost::regex_traits_architype	access:public
char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename M::char_type char_type;$/;"	t	struct:boost::functor1	access:public
char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename M::char_type char_type;$/;"	t	struct:boost::functor1b	access:public
char_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::char_type char_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
char_type	/usr/include/boost/regex/icu.hpp	/^   typedef UChar32                      char_type;$/;"	t	class:boost::icu_regex_traits	access:public
char_type	/usr/include/boost/regex/icu.hpp	/^   typedef UChar32                      char_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
char_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef charT                                 char_type;$/;"	t	class:boost::basic_regex	access:public
char_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef char char_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
char_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef wchar_t char_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
char_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef charT                        char_type;$/;"	t	class:boost::cpp_regex_traits	access:public
char_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef charT char_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
char_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::char_type char_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
char_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef char char_type;$/;"	t	struct:boost::c_regex_traits	access:public
char_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef unsigned short char_type;$/;"	t	struct:boost::c_regex_traits	access:public
char_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef wchar_t char_type;$/;"	t	struct:boost::c_regex_traits	access:public
char_type	/usr/include/boost/regex/v4/match_results.hpp	/^                                    BidiIterator>::value_type               char_type;$/;"	t	class:boost::match_results	access:public
char_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename traits::char_type char_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
char_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef charT char_type;$/;"	t	struct:boost::re_detail::trivial_format_traits	access:public
char_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename traits::char_type char_type;$/;"	t	class:boost::re_detail::basic_regex_formatter	access:public
char_type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef typename BaseT::char_type char_type;$/;"	t	struct:boost::re_detail::default_wrapper	access:public
char_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef charT                         char_type;$/;"	t	class:boost::w32_regex_traits	access:public
char_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef charT char_type;$/;"	t	class:boost::re_detail::w32_regex_traits_implementation	access:public
char_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
char_type	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::regex_impl	access:public
char_type	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::traits_holder	access:public
char_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
char_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
char_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
char_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
char_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef Elem char_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
check	/usr/include/boost/xpressive/regex_actions.hpp	/^    proto::terminal<detail::check_tag>::type const check = {{}};$/;"	m	class:boost::xpressive::proto::terminal
check_insert_return	/usr/include/boost/xpressive/regex_actions.hpp	/^                static no_type check_insert_return(std::pair<typename cont_type::iterator, bool>);$/;"	p	struct:boost::xpressive::op::insert::result	access:public	signature:(std::pair<typename cont_type::iterator, bool>)
check_insert_return	/usr/include/boost/xpressive/regex_actions.hpp	/^                static yes_type check_insert_return(typename cont_type::iterator);$/;"	p	struct:boost::xpressive::op::insert::result	access:public	signature:(typename cont_type::iterator)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^binary_type check_is_formatter(T const &, U const &, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(T const &, U const &, ternary_type)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^binary_type check_is_formatter(unary_type, T const &, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(unary_type, T const &, ternary_type)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^no_type check_is_formatter(unary_type, binary_type, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(unary_type, binary_type, ternary_type)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(T const &, binary_type, U const &);$/;"	p	namespace:boost::re_detail	signature:(T const &, binary_type, U const &)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(T const &, U const &, V const &);$/;"	p	namespace:boost::re_detail	signature:(T const &, U const &, V const &)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(unary_type, binary_type, T const &);$/;"	p	namespace:boost::re_detail	signature:(unary_type, binary_type, T const &)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^ternary_type check_is_formatter(unary_type, T const &, U const &);$/;"	p	namespace:boost::re_detail	signature:(unary_type, T const &, U const &)
check_is_formatter	/usr/include/boost/regex/v4/regex_format.hpp	/^unary_type check_is_formatter(T const &, binary_type, ternary_type);$/;"	p	namespace:boost::re_detail	signature:(T const &, binary_type, ternary_type)
check_null_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool check_null_repeat(const BidiIterator& pos, std::size_t max)$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:(const BidiIterator& pos, std::size_t max)
check_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct check_system : mpl::false_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::false_
check_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct check_system<heterogeneous_system<heterogeneous_system_impl<System, Dimension, Scale> >, Dimension> : mpl::true_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::true_
check_system	/usr/include/boost/units/homogeneous_system.hpp	/^struct check_system<homogeneous_system<L>, Dimensions> : mpl::true_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::true_
check_system	/usr/include/boost/units/homogeneous_system.hpp	/^struct check_system<homogeneous_system<L>, Dimensions> :$/;"	s	namespace:boost::units::detail	inherits:boost::mpl::not_
check_tag	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct check_tag$/;"	s	namespace:boost::xpressive::detail
chrono	/usr/include/boost/chrono/system_clocks.hpp	/^namespace chrono {$/;"	n	namespace:boost
classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type classes()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
class_name_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        char_type const *class_name_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
class_type_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        char_class_type class_type_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
clear	/usr/include/boost/filesystem/path.hpp	/^    void   clear()             { m_pathname.clear(); }$/;"	f	class:boost::filesystem::path	access:public	signature:()
clear	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void BOOST_REGEX_CALL clear()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
clear	/usr/include/boost/system/error_code.hpp	/^      void clear()$/;"	f	class:boost::system::error_code	access:public	signature:()
clear	/usr/include/boost/system/error_code.hpp	/^      void clear()$/;"	f	class:boost::system::error_condition	access:public	signature:()
clock_string	/usr/include/boost/chrono/system_clocks.hpp	/^  struct clock_string<steady_clock, CharT>$/;"	s	namespace:boost::chrono
clock_string	/usr/include/boost/chrono/system_clocks.hpp	/^  struct clock_string<system_clock, CharT>$/;"	s	namespace:boost::chrono
close	/usr/include/boost/regex/v4/fileiter.hpp	/^   void close();$/;"	p	class:boost::re_detail::mapfile	access:public	signature:()
cmatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<const char*> cmatch;$/;"	t	namespace:boost
cnclasses	/usr/include/boost/regex/v4/states.hpp	/^   mask_type               cnclasses;$/;"	m	struct:boost::re_detail::re_set_long	access:public
cntrl	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const cntrl = {{"cntrl", false}};$/;"	m	class:boost::xpressive::proto::terminal
codata	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
codata	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace codata {$/;"	n	namespace:boost::units::si::constants
code	/usr/include/boost/regex/pattern_except.hpp	/^   regex_constants::error_type code()const$/;"	f	class:boost::regex_error	access:public	signature:() const
code	/usr/include/boost/system/system_error.hpp	/^      const error_code &  code() const throw() { return m_error_code; }$/;"	f	class:boost::system::system_error	access:public	signature:() const
code	/usr/include/boost/xpressive/regex_error.hpp	/^    regex_constants::error_type code() const$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:() const
codecvt	/usr/include/boost/filesystem/path.hpp	/^    static const        codecvt_type& codecvt();$/;"	p	class:boost::filesystem::path	access:public	signature:()
codecvt_error_category	/usr/include/boost/filesystem/path_traits.hpp	/^  BOOST_FILESYSTEM_DECL const system::error_category& codecvt_error_category();$/;"	p	namespace:boost::filesystem	signature:()
codecvt_type	/usr/include/boost/filesystem/path.hpp	/^                         std::mbstate_t>   codecvt_type;$/;"	t	class:boost::filesystem::path	access:public
codecvt_type	/usr/include/boost/filesystem/path_traits.hpp	/^  typedef std::codecvt<wchar_t, char, std::mbstate_t> codecvt_type;$/;"	t	namespace:boost::filesystem::path_traits
code_	/usr/include/boost/xpressive/regex_error.hpp	/^    regex_constants::error_type code_;$/;"	m	struct:boost::xpressive::regex_error	access:private
collate	/usr/include/boost/regex/v4/regbase.hpp	/^      collate = 1 << 21,                                \/\/ use locale specific collation$/;"	e	enum:boost::regbase::flag_type_
collate	/usr/include/boost/regex/v4/regbase.hpp	/^      collate = ::boost::regbase::collate,$/;"	e	enum:boost::regex_constants::flag_type_
collate	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::collate;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
collate	/usr/include/boost/xpressive/regex_constants.hpp	/^    collate     = 1 << 4,   \/\/\/< Specifies that character ranges of the form "[a-b]" should be$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
communication_error	/usr/include/boost/system/linux_error.hpp	/^        communication_error = ECOMM,$/;"	e	enum:boost::system::linux_error::linux_errno
compare	/usr/include/boost/filesystem/path.hpp	/^    int compare(const std::string& s) const { return compare(path(s)); }$/;"	f	class:boost::filesystem::path	access:public	signature:(const std::string& s) const
compare	/usr/include/boost/filesystem/path.hpp	/^    int compare(const value_type* s) const  { return compare(path(s)); }$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* s) const
compare	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int BOOST_REGEX_CALL compare(const basic_regex& that) const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that) const
compare	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool compare(const regex_iterator_implementation& that)$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:(const regex_iterator_implementation& that)
compare	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool compare(const regex_token_iterator_implementation& that)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_token_iterator_implementation& that)
compare	/usr/include/boost/regex/v4/sub_match.hpp	/^   int compare(const std::basic_string<value_type>& s)const$/;"	f	struct:boost::sub_match	access:public	signature:(const std::basic_string<value_type>& s) const
compare	/usr/include/boost/regex/v4/sub_match.hpp	/^   int compare(const sub_match& s)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& s) const
compare	/usr/include/boost/regex/v4/sub_match.hpp	/^   int compare(const value_type* p)const$/;"	f	struct:boost::sub_match	access:public	signature:(const value_type* p) const
compare	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool compare(const u32regex_iterator_implementation& that)$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:(const u32regex_iterator_implementation& that)
compare	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool compare(const u32regex_token_iterator_implementation& that)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const u32regex_token_iterator_implementation& that)
compare_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static bool compare_(char_type const *name, FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(char_type const *name, FwdIter begin, FwdIter end)
compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, std::size_t len, flag_type flags)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, std::size_t len, flag_type flags)
compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
compile	/usr/include/boost/xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile(char_type const *begin, std::size_t size, flag_type flags)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, std::size_t size, flag_type flags)
compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
compile	/usr/include/boost/xpressive/regex_compiler.hpp	/^    compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
compile_	/usr/include/boost/xpressive/basic_regex.hpp	/^    void compile_(Expr const &, mpl::false_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &, mpl::false_)
compile_	/usr/include/boost/xpressive/basic_regex.hpp	/^    void compile_(Expr const &expr, mpl::true_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &expr, mpl::true_)
compile_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)
compile_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)
complete	/usr/include/boost/filesystem/operations.hpp	/^  path complete(const path& p)$/;"	f	namespace:boost::filesystem	signature:(const path& p)
complete	/usr/include/boost/filesystem/operations.hpp	/^  path complete(const path& p, const path& base)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const path& base)
complete_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p)
complete_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p, boost::filesystem::path const& base)
compute_functor_type	/usr/include/boost/regex/v4/regex_format.hpp	/^struct compute_functor_type$/;"	s	namespace:boost::re_detail
compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base$/;"	s	namespace:boost::re_detail
compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base<BaseT, false>$/;"	s	namespace:boost::re_detail
compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base<c_regex_traits<char>, false>$/;"	s	namespace:boost::re_detail
compute_wrapper_base	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct compute_wrapper_base<c_regex_traits<wchar_t>, false>$/;"	s	namespace:boost::re_detail
concat	/usr/include/boost/filesystem/path.hpp	/^    path& concat(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
concat	/usr/include/boost/filesystem/path.hpp	/^    path& concat(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
concat	/usr/include/boost/filesystem/path.hpp	/^    path& concat(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
concrete_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^   concrete_protected_call(T* o, proc_type p)$/;"	f	class:boost::re_detail::concrete_protected_call	access:public	signature:(T* o, proc_type p)
concrete_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^class concrete_protected_call$/;"	c	namespace:boost::re_detail	inherits:abstract_protected_call
conductance	/usr/include/boost/units/systems/si/conductance.hpp	/^typedef unit<conductance_dimension,si::system>    conductance;$/;"	t	namespace:boost::units::si
conductivity	/usr/include/boost/units/systems/si/conductivity.hpp	/^typedef unit<conductivity_dimension,si::system>    conductivity;$/;"	t	namespace:boost::units::si
connection_aborted	/usr/include/boost/system/error_code.hpp	/^        connection_aborted = ECONNABORTED,$/;"	e	enum:boost::system::errc::errc_t
connection_already_in_progress	/usr/include/boost/system/error_code.hpp	/^        connection_already_in_progress = EALREADY,$/;"	e	enum:boost::system::errc::errc_t
connection_refused	/usr/include/boost/system/error_code.hpp	/^        connection_refused = ECONNREFUSED,$/;"	e	enum:boost::system::errc::errc_t
connection_reset	/usr/include/boost/system/error_code.hpp	/^        connection_reset = ECONNRESET,$/;"	e	enum:boost::system::errc::errc_t
constant	/usr/include/boost/units/systems/detail/constants.hpp	/^struct constant $/;"	s	namespace:boost::units
constants	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constants	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace constants {$/;"	n	namespace:boost::units::si
constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::BaseRegexConcept	access:public	signature:()
constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::BitmaskConcept	access:public	signature:()
constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::BoostRegexConcept	access:public	signature:()
constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::RegexConcept	access:public	signature:()
constraints	/usr/include/boost/regex/concepts.hpp	/^   void constraints() $/;"	f	struct:boost::RegexTraitsConcept	access:public	signature:()
construct	/usr/include/boost/regex/concepts.hpp	/^   void construct(pointer, const_reference);$/;"	p	class:allocator_architype	access:public	signature:(pointer, const_reference)
construct	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct construct$/;"	s	namespace:boost::xpressive::op
construct_init	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void construct_init(const basic_regex<char_type, traits>& e, match_flag_type f);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const basic_regex<char_type, traits>& e, match_flag_type f)
construct_init	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::construct_init(const basic_regex<char_type, traits>& e, match_flag_type f)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const basic_regex<char_type, traits>& e, match_flag_type f)
const_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct const_cast_$/;"	s	namespace:boost::xpressive::op
const_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^    const_cast_(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
const_iterator	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::const_iterator const_iterator;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
const_iterator	/usr/include/boost/filesystem/path.hpp	/^    typedef iterator const_iterator;$/;"	t	class:boost::filesystem::path	access:public
const_iterator	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::const_iterator const_iterator;$/;"	t	struct:boost::BoostRegexConcept	access:public
const_iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const charT*                          const_iterator;$/;"	t	class:boost::basic_regex	access:public
const_iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const charT*                          const_iterator;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
const_iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::vector<name>::const_iterator const_iterator;$/;"	t	class:boost::re_detail::named_subexpressions	access:public
const_iterator	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename vector_type::const_iterator                             const_iterator;$/;"	t	class:boost::match_results	access:public
const_iterator	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          BidiIterator                                                     const_iterator;$/;"	t	struct:boost::sub_match	access:public
const_pointer	/usr/include/boost/regex/concepts.hpp	/^   typedef const T* const_pointer;$/;"	t	class:allocator_architype	access:public
const_pointer_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct const_pointer_iterator_traits$/;"	s	namespace:boost::re_detail
const_reference	/usr/include/boost/regex/concepts.hpp	/^   typedef const T& const_reference;$/;"	t	class:allocator_architype	access:public
const_reference	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const charT&                          const_reference;$/;"	t	class:boost::basic_regex	access:public
const_reference	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          const value_type&                                       const_reference;$/;"	t	class:boost::match_results	access:public
const_reference	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename Allocator::const_reference                              const_reference;$/;"	t	class:boost::match_results	access:public
cont	/usr/include/boost/regex/pending/object_cache.hpp	/^      list_type   cont;$/;"	m	struct:boost::object_cache::data	access:public
cont_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Cont) cont_type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from, const char* from_end, std::string & to,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const char* from, const char* from_end, std::string & to, const codecvt_type&)
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const char* from, std::string & to, const codecvt_type&)
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const char* from, std::wstring & to, const codecvt_type& cvt)
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const char* from,$/;"	p	namespace:boost::filesystem::path_traits	signature:(const char* from, const char* from_end, std::wstring & to, const codecvt_type& cvt)
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from, const wchar_t* from_end, std::wstring & to,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, const wchar_t* from_end, std::wstring & to, const codecvt_type&)
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, std::string & to, const codecvt_type& cvt)
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from,$/;"	f	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, std::wstring & to, const codecvt_type&)
convert	/usr/include/boost/filesystem/path_traits.hpp	/^  void convert(const wchar_t* from,$/;"	p	namespace:boost::filesystem::path_traits	signature:(const wchar_t* from, const wchar_t* from_end, std::string & to, const codecvt_type& cvt)
coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    struct coordinate_system$/;"	s	namespace:boost::geometry::core_dispatch
coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    struct coordinate_system<point_tag, P>$/;"	s	namespace:boost::geometry::core_dispatch
coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^struct coordinate_system$/;"	s	namespace:boost::geometry
coordinate_system	/usr/include/boost/geometry/core/coordinate_system.hpp	/^struct coordinate_system$/;"	s	namespace:boost::geometry::traits
copy	/usr/include/boost/filesystem/operations.hpp	/^    void copy(const path& from, const path& to, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& from, const path& to, system::error_code* ec=0)
copy	/usr/include/boost/filesystem/operations.hpp	/^  void copy(const path& from, const path& to) {detail::copy(from, to);}$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to)
copy	/usr/include/boost/filesystem/operations.hpp	/^  void copy(const path& from, const path& to, system::error_code& ec) $/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, system::error_code& ec)
copy	/usr/include/boost/regex/v4/regex_workaround.hpp	/^   inline OutputIterator copy($/;"	f	namespace:boost::re_detail	signature:( InputIterator first, InputIterator last, OutputIterator dest )
copy_directory	/usr/include/boost/filesystem/operations.hpp	/^    void copy_directory(const path& from, const path& to, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& from, const path& to, system::error_code* ec=0)
copy_directory	/usr/include/boost/filesystem/operations.hpp	/^  void copy_directory(const path& from, const path& to)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to)
copy_directory	/usr/include/boost/filesystem/operations.hpp	/^  void copy_directory(const path& from, const path& to, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, system::error_code& ec)
copy_file	/usr/include/boost/filesystem/operations.hpp	/^    void copy_file(const path& from, const path& to,$/;"	p	namespace:boost::filesystem::detail	signature:(const path& from, const path& to, BOOST_SCOPED_ENUM(copy_option) option, system::error_code* ec=0)
copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to)
copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to,   \/\/ See ticket #2925$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, BOOST_SCOPED_ENUM(copy_option) option)
copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to,   \/\/ See ticket #2925$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, BOOST_SCOPED_ENUM(copy_option) option, system::error_code& ec)
copy_file	/usr/include/boost/filesystem/operations.hpp	/^  void copy_file(const path& from, const path& to, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& from, const path& to, system::error_code& ec)
copy_results	/usr/include/boost/regex/icu.hpp	/^void copy_results(MR1& out, MR2 const& in)$/;"	f	namespace:boost::re_detail	signature:(MR1& out, MR2 const& in)
copy_symlink	/usr/include/boost/filesystem/operations.hpp	/^    void copy_symlink(const path& existing_symlink, const path& new_symlink, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& existing_symlink, const path& new_symlink, system::error_code* ec=0)
copy_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void copy_symlink(const path& existing_symlink, const path& new_symlink) {detail::copy_symlink(existing_symlink, new_symlink);}$/;"	f	namespace:boost::filesystem	signature:(const path& existing_symlink, const path& new_symlink)
copy_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void copy_symlink(const path& existing_symlink, const path& new_symlink, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& existing_symlink, const path& new_symlink, system::error_code& ec)
core_dispatch	/usr/include/boost/geometry/core/coordinate_system.hpp	/^namespace core_dispatch$/;"	n	namespace:boost::geometry
count	/usr/include/boost/regex/v4/fileiter.hpp	/^   long count;$/;"	m	struct:boost::re_detail::file_iterator_ref	access:public
count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::size_t count;        \/\/ the number of iterations so far$/;"	m	class:boost::re_detail::repeater_count	access:private
count	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   repeater_count<BidiIterator> count;$/;"	m	struct:boost::re_detail::saved_repeater	access:public
count	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   std::size_t count;$/;"	m	struct:boost::re_detail::saved_single_repeat	access:public
counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    counted_time_rep(const date_type& d, const time_duration_type& time_of_day) $/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:(const date_type& d, const time_duration_type& time_of_day)
counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    explicit counted_time_rep(impl_type count) :$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:(impl_type count)
counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    explicit counted_time_rep(int_type count) :$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:(int_type count)
counted_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^  struct counted_time_rep$/;"	s	namespace:boost::date_time
counted_time_system	/usr/include/boost/date_time/time_system_counted.hpp	/^  class counted_time_system$/;"	c	namespace:boost::date_time
count_chars	/usr/include/boost/regex/v4/primary_transform.hpp	/^unsigned count_chars(const S& s, charT c)$/;"	f	namespace:boost::re_detail	signature:(const S& s, charT c)
cow	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   void cow()$/;"	f	class:boost::regex_iterator	access:private	signature:()
cow	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   void cow()$/;"	f	class:boost::regex_token_iterator	access:private	signature:()
cow	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   void cow()$/;"	f	class:boost::u32regex_iterator	access:private	signature:()
cow	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   void cow()$/;"	f	class:boost::u32regex_token_iterator	access:private	signature:()
cpp_regex_traits	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits()$/;"	f	class:boost::cpp_regex_traits	access:public	signature:()
cpp_regex_traits	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class cpp_regex_traits$/;"	c	namespace:boost
cpp_regex_traits	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    cpp_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
cpp_regex_traits	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^struct cpp_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::cpp_regex_traits_base
cpp_regex_traits_base	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_base(const std::locale& l)$/;"	f	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const std::locale& l)
cpp_regex_traits_base	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^struct cpp_regex_traits_base$/;"	s	namespace:boost::re_detail
cpp_regex_traits_base	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
cpp_regex_traits_base	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer(const cpp_regex_traits_base<char>& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(const cpp_regex_traits_base<char>& l)
cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer(const cpp_regex_traits_base<charT>& b)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(const cpp_regex_traits_base<charT>& b)
cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer(const std::locale& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(const std::locale& l)
cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class BOOST_REGEX_DECL cpp_regex_traits_char_layer<char> : public cpp_regex_traits_base<char>$/;"	c	namespace:boost::re_detail	inherits:cpp_regex_traits_base
cpp_regex_traits_char_layer	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class cpp_regex_traits_char_layer : public cpp_regex_traits_base<charT>$/;"	c	namespace:boost::re_detail	inherits:cpp_regex_traits_base
cpp_regex_traits_implementation	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation(const cpp_regex_traits_base<charT>& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const cpp_regex_traits_base<charT>& l)
cpp_regex_traits_implementation	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation(const std::locale& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const std::locale& l)
cpp_regex_traits_implementation	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class cpp_regex_traits_implementation : public cpp_regex_traits_char_layer<charT>$/;"	c	namespace:boost::re_detail	inherits:cpp_regex_traits_char_layer
cranges	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int            csingles, cranges, cequivalents;$/;"	m	struct:boost::re_detail::re_set_long	access:public
crc	/usr/include/boost/system/windows_error.hpp	/^        crc = ERROR_CRC,$/;"	e	enum:boost::system::windows_error::windows_error_code
create_directories	/usr/include/boost/filesystem/operations.hpp	/^    bool create_directories(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
create_directories	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directories(const path& p) {return detail::create_directories(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
create_directories	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directories(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
create_directory	/usr/include/boost/filesystem/operations.hpp	/^    bool create_directory(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
create_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directory(const path& p) {return detail::create_directory(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
create_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool create_directory(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
create_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^    void create_directory_symlink(const path& to, const path& from,$/;"	p	namespace:boost::filesystem::detail	signature:(const path& to, const path& from, system::error_code* ec=0)
create_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_directory_symlink(const path& to, const path& from)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& from)
create_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_directory_symlink(const path& to, const path& from, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& from, system::error_code& ec)
create_hard_link	/usr/include/boost/filesystem/operations.hpp	/^    void create_hard_link(const path& to, const path& from, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& to, const path& from, system::error_code* ec=0)
create_hard_link	/usr/include/boost/filesystem/operations.hpp	/^  void create_hard_link(const path& to, const path& new_hard_link) {detail::create_hard_link(to, new_hard_link);}$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_hard_link)
create_hard_link	/usr/include/boost/filesystem/operations.hpp	/^  void create_hard_link(const path& to, const path& new_hard_link, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_hard_link, system::error_code& ec)
create_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path create_path(String const& p)$/;"	f	namespace:boost::wave::util	signature:(String const& p)
create_startmap	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
create_startmap	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
create_startmaps	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void create_startmaps(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
create_startmaps	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::create_startmaps(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
create_symlink	/usr/include/boost/filesystem/operations.hpp	/^    void create_symlink(const path& to, const path& from, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& to, const path& from, system::error_code* ec=0)
create_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_symlink(const path& to, const path& new_symlink) {detail::create_symlink(to, new_symlink);}$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_symlink)
create_symlink	/usr/include/boost/filesystem/operations.hpp	/^  void create_symlink(const path& to, const path& new_symlink, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& to, const path& new_symlink, system::error_code& ec)
cref	/usr/include/boost/xpressive/regex_actions.hpp	/^    reference<T const> const cref(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
cregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<const char*> cregex_iterator;$/;"	t	namespace:boost
cregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<const char*> cregex_token_iterator;$/;"	t	namespace:boost
cross_device_link	/usr/include/boost/system/error_code.hpp	/^        cross_device_link = EXDEV,$/;"	e	enum:boost::system::errc::errc_t
csingles	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int            csingles, cranges, cequivalents;$/;"	m	struct:boost::re_detail::re_set_long	access:public
csub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<const char*> csub_match;$/;"	t	namespace:boost
ctype_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    std::ctype<char_type> const *ctype_;$/;"	m	class:boost::xpressive::cpp_regex_traits::std	access:private
ctype_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::ctype<charT>            ctype_type;$/;"	t	class:boost::cpp_regex_traits	access:private
current	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<current_dimension,system>               current;                \/\/\/< abstract unit of current$/;"	t	namespace:boost::units::abstract
current	/usr/include/boost/units/systems/cgs/current.hpp	/^typedef unit<current_dimension,cgs::system>   current;$/;"	t	namespace:boost::units::cgs
current	/usr/include/boost/units/systems/si/current.hpp	/^typedef unit<current_dimension,si::system>   current;$/;"	t	namespace:boost::units::si
current_directory	/usr/include/boost/system/windows_error.hpp	/^        current_directory = ERROR_CURRENT_DIRECTORY,$/;"	e	enum:boost::system::windows_error::windows_error_code
current_over_energy	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<current,energy>::type current_over_energy;$/;"	t	namespace:boost::units::si::constants::codata
current_path	/usr/include/boost/filesystem/operations.hpp	/^    path current_path(system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(system::error_code* ec=0)
current_path	/usr/include/boost/filesystem/operations.hpp	/^    void current_path(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
current_path	/usr/include/boost/filesystem/operations.hpp	/^  path current_path()                  {return detail::current_path();}$/;"	f	namespace:boost::filesystem	signature:()
current_path	/usr/include/boost/filesystem/operations.hpp	/^  path current_path();  \/\/ fwd declaration$/;"	p	namespace:boost::filesystem	signature:()
current_path	/usr/include/boost/filesystem/operations.hpp	/^  path current_path(system::error_code& ec) {return detail::current_path(&ec);}$/;"	f	namespace:boost::filesystem	signature:(system::error_code& ec)
current_path	/usr/include/boost/filesystem/operations.hpp	/^  void current_path(const path& p)     {detail::current_path(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
current_path	/usr/include/boost/filesystem/operations.hpp	/^  void current_path(const path& p, system::error_code& ec) {detail::current_path(p, &ec);}$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
current_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path current_path()$/;"	f	namespace:boost::wave::util	signature:()
current_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct current_unit_tag : base_unit<current_unit_tag, current_dimension, -27> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
cygwin_errno	/usr/include/boost/system/cygwin_error.hpp	/^      enum cygwin_errno$/;"	g	namespace:boost::system::cygwin_error
cygwin_error	/usr/include/boost/system/cygwin_error.hpp	/^    namespace cygwin_error$/;"	n	namespace:boost::system
cygwin_error	/usr/include/boost/system/cygwin_error.hpp	/^   namespace cygwin_error$/;"	n	namespace:boost::system
c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   c_regex_traits(){}$/;"	f	struct:boost::c_regex_traits	access:public	signature:()
c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   c_regex_traits(const c_regex_traits&);$/;"	p	struct:boost::c_regex_traits	access:private	signature:(const c_regex_traits&)
c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^struct BOOST_REGEX_DECL c_regex_traits<char>$/;"	s	namespace:boost
c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^struct BOOST_REGEX_DECL c_regex_traits<unsigned short>$/;"	s	namespace:boost
c_regex_traits	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^struct BOOST_REGEX_DECL c_regex_traits<wchar_t>$/;"	s	namespace:boost
c_regex_traits	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    c_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
c_regex_traits	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^struct c_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::c_regex_traits_base
c_regex_traits_base	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
c_regex_traits_base	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
c_regex_traits_base	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<wchar_t, SizeOfChar>$/;"	s	namespace:boost::xpressive::detail
c_str	/usr/include/boost/filesystem/path.hpp	/^    const value_type*   c_str() const  { return m_pathname.c_str(); }  \/\/ Throws: nothing$/;"	f	class:boost::filesystem::path	access:public	signature:() const
c_tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    Char c_tolower(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
c_tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline char c_tolower(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
c_tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_tolower(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
c_toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    Char c_toupper(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
c_toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline char c_toupper(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
c_toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_toupper(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
data	/usr/include/boost/regex/pending/object_cache.hpp	/^   struct data$/;"	s	class:boost::object_cache	access:private
data	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_data* data() { return &(ref->_data); }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
data	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_data* data() { return &(ref->_data); }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:()
data	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* BOOST_REGEX_CALL data()const$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:() const
date	/usr/include/boost/date_time/time_system_counted.hpp	/^    date_type date() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
date_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename date_type::duration_type date_duration_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
date_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::date_duration_type date_duration_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
date_duration_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::date_duration_type date_duration_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
date_time	/usr/include/boost/date_time/time_system_counted.hpp	/^namespace date_time {$/;"	n	namespace:boost
date_time	/usr/include/boost/date_time/time_system_split.hpp	/^namespace date_time {$/;"	n	namespace:boost
DATE_TIME_TIME_SYSTEM_COUNTED_HPP	/usr/include/boost/date_time/time_system_counted.hpp	2;"	d
DATE_TIME_TIME_SYSTEM_SPLIT_HPP	/usr/include/boost/date_time/time_system_split.hpp	2;"	d
date_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::date_type  date_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
date_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::date_type date_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
date_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::date_type     date_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
day_count	/usr/include/boost/date_time/time_system_counted.hpp	/^    unsigned long day_count() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
deallocate	/usr/include/boost/regex/concepts.hpp	/^   void deallocate(pointer, size_type);$/;"	p	class:allocator_architype	access:public	signature:(pointer, size_type)
decrement	/usr/include/boost/filesystem/path.hpp	/^    void decrement() { m_path_iterator_decrement(*this); }$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:()
decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:()
decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:()
decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:()
decrement	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void decrement()$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:()
default_error_condition	/usr/include/boost/system/error_code.hpp	/^      error_condition         default_error_condition() const  { return m_cat->default_error_condition(value()); }$/;"	f	class:boost::system::error_code	access:public	signature:() const
default_error_condition	/usr/include/boost/system/error_code.hpp	/^      virtual error_condition  default_error_condition( int ev ) const;$/;"	p	class:boost::system::error_category	access:public	signature:( int ev ) const
default_error_condition	/usr/include/boost/system/error_code.hpp	/^    inline error_condition error_category::default_error_condition( int ev ) const$/;"	f	class:boost::system::error_category	signature:( int ev ) const
default_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct default_wrapper : public BaseT$/;"	s	namespace:boost::re_detail	inherits:BaseT
degree	/usr/include/boost/units/systems/angle/degrees.hpp	/^namespace degree {$/;"	n	namespace:boost::units
deprecated	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^namespace deprecated{$/;"	n	namespace:boost
dereference	/usr/include/boost/filesystem/operations.hpp	/^      boost::single_pass_traversal_tag >::reference dereference() const $/;"	f	class:boost::filesystem::directory_iterator	access:private	signature:() const
dereference	/usr/include/boost/filesystem/operations.hpp	/^    dereference() const $/;"	f	class:boost::filesystem::recursive_directory_iterator	access:private	signature:() const
dereference	/usr/include/boost/filesystem/path.hpp	/^    const path& dereference() const { return m_element; }$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:() const
dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:() const
dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:() const
dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:() const
dereference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^      dereference()const$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:() const
destination_address_required	/usr/include/boost/system/error_code.hpp	/^        destination_address_required = EDESTADDRREQ,$/;"	e	enum:boost::system::errc::errc_t
destroy	/usr/include/boost/regex/concepts.hpp	/^   void destroy(pointer);$/;"	p	class:allocator_architype	access:public	signature:(pointer)
destroy_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void destroy_single_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
destroy_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::destroy_single_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
detail	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^        namespace detail {$/;"	n	namespace:boost::algorithm
detail	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^        namespace detail {$/;"	n	namespace:boost::algorithm
detail	/usr/include/boost/detail/win/system.hpp	/^namespace detail {$/;"	n	namespace:boost
detail	/usr/include/boost/filesystem/operations.hpp	/^  namespace detail$/;"	n	namespace:boost::filesystem
detail	/usr/include/boost/filesystem/operations.hpp	/^namespace detail$/;"	n	namespace:boost::filesystem
detail	/usr/include/boost/filesystem/path.hpp	/^  namespace detail$/;"	n	namespace:boost::filesystem
detail	/usr/include/boost/iostreams/detail/system_failure.hpp	/^namespace boost { namespace iostreams { namespace detail {$/;"	n	namespace:boost::iostreams
detail	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^namespace detail{$/;"	n	namespace:boost
detail	/usr/include/boost/regex/v4/iterator_category.hpp	/^namespace detail{$/;"	n	namespace:boost
detail	/usr/include/boost/system/error_code.hpp	/^  namespace detail { inline system::error_code * throws() { return 0; } }$/;"	n	namespace:boost
detail	/usr/include/boost/units/heterogeneous_system.hpp	/^namespace detail {$/;"	n	namespace:boost::units
detail	/usr/include/boost/units/homogeneous_system.hpp	/^namespace detail {$/;"	n	namespace:boost::units
detail	/usr/include/boost/units/make_system.hpp	/^namespace detail {$/;"	n	namespace:boost::units
detail	/usr/include/boost/xpressive/basic_regex.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/regex_actions.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/regex_algorithms.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/regex_error.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/regex_primitives.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
device_or_resource_busy	/usr/include/boost/system/error_code.hpp	/^        device_or_resource_busy = EBUSY,$/;"	e	enum:boost::system::errc::errc_t
difference_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::difference_type difference_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
difference_type	/usr/include/boost/regex/concepts.hpp	/^   typedef int difference_type;$/;"	t	class:allocator_architype	access:public
difference_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
difference_type	/usr/include/boost/regex/mfc.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
difference_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   difference_type;$/;"	t	class:boost::utf16_output_iterator	access:public
difference_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   difference_type;$/;"	t	class:boost::utf8_output_iterator	access:public
difference_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::ptrdiff_t                        difference_type;$/;"	t	class:boost::basic_regex	access:public
difference_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::ptrdiff_t                        difference_type;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
difference_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::ptrdiff_t            difference_type;$/;"	t	class:boost::re_detail::directory_iterator	access:public
difference_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::ptrdiff_t            difference_type;$/;"	t	class:boost::re_detail::file_iterator	access:public
difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef std::ptrdiff_t                difference_type;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
difference_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::difference_type   difference_type;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
difference_type	/usr/include/boost/regex/v4/match_results.hpp	/^                                    BidiIterator>::difference_type          difference_type;$/;"	t	class:boost::match_results	access:public
difference_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename regex_iterator_traits<BidiIterator>::difference_type difference_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
difference_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
difference_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::regex_iterator	access:public
difference_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::regex_token_iterator	access:public
difference_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          std::ptrdiff_t                                                   difference_type;$/;"	t	struct:boost::sub_match	access:public
difference_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef typename re_detail::regex_iterator_traits<BidiIterator>::difference_type  difference_type;$/;"	t	struct:boost::sub_match	access:public
difference_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::u32regex_iterator	access:public
difference_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^                                                                            difference_type;$/;"	t	class:boost::u32regex_token_iterator	access:public
difference_type	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
difference_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
digit	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const digit = {{"digit", false}};$/;"	m	class:boost::xpressive::proto::terminal
digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph() : std::pair<charT, charT>(0, 0){}$/;"	f	struct:boost::re_detail::digraph	access:public	signature:()
digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(charT c1) : std::pair<charT, charT>(c1, 0){}$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(charT c1)
digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(charT c1, charT c2) : std::pair<charT, charT>(c1, c2)$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(charT c1, charT c2)
digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(const digraph<charT>& d) : std::pair<charT, charT>(d.first, d.second){}$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(const digraph<charT>& d)
digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   digraph(const Seq& s) : std::pair<charT, charT>()$/;"	f	struct:boost::re_detail::digraph	access:public	signature:(const Seq& s)
digraph	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^struct digraph : public std::pair<charT, charT>$/;"	s	namespace:boost::re_detail	inherits:std::pair
digraph_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef digraph<charT>                   digraph_type;$/;"	t	class:boost::re_detail::basic_char_set	access:public
dimensionless	/usr/include/boost/units/systems/angle/degrees.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::degree
dimensionless	/usr/include/boost/units/systems/angle/gradians.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::gradian
dimensionless	/usr/include/boost/units/systems/angle/revolutions.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::revolution
dimensionless	/usr/include/boost/units/systems/cgs/base.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::cgs
dimensionless	/usr/include/boost/units/systems/si/base.hpp	/^typedef unit<dimensionless_type,system>         dimensionless;$/;"	t	namespace:boost::units::si
dimensions	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Dimensions dimensions;$/;"	t	struct:boost::units::heterogeneous_system_impl	access:public
directory_entry	/usr/include/boost/filesystem/operations.hpp	/^  directory_entry() {}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:()
directory_entry	/usr/include/boost/filesystem/operations.hpp	/^  explicit directory_entry(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st = file_status(), file_status symlink_st=file_status())
directory_entry	/usr/include/boost/filesystem/operations.hpp	/^class BOOST_FILESYSTEM_DECL directory_entry$/;"	c	namespace:boost::filesystem
directory_file	/usr/include/boost/filesystem/operations.hpp	/^    directory_file,$/;"	e	enum:boost::filesystem::file_type
directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    directory_iterator(){}  \/\/ creates the "end" iterator$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:()
directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    directory_iterator(const path& p, system::error_code& ec)$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:(const path& p, system::error_code& ec)
directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    explicit directory_iterator(const path& p)$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:(const path& p)
directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^  class directory_iterator$/;"	c	namespace:boost::filesystem	inherits:boost::iterator_facade
directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator();$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:()
directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator(const char* wild);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(const char* wild)
directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator(const directory_iterator& other);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(const directory_iterator& other)
directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^class BOOST_REGEX_DECL directory_iterator$/;"	c	namespace:boost::re_detail
directory_iterator_construct	/usr/include/boost/filesystem/operations.hpp	/^    friend BOOST_FILESYSTEM_DECL void detail::directory_iterator_construct(directory_iterator& it,$/;"	p	class:boost::filesystem::directory_iterator::detail	access:friend	signature:(directory_iterator& it, const path& p, system::error_code* ec)
directory_iterator_construct	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_FILESYSTEM_DECL void directory_iterator_construct(directory_iterator& it,$/;"	p	namespace:boost::filesystem::detail	signature:(directory_iterator& it, const path& p, system::error_code* ec)
directory_iterator_increment	/usr/include/boost/filesystem/operations.hpp	/^    friend BOOST_FILESYSTEM_DECL void detail::directory_iterator_increment(directory_iterator& it,$/;"	p	class:boost::filesystem::directory_iterator::detail	access:friend	signature:(directory_iterator& it, system::error_code* ec)
directory_iterator_increment	/usr/include/boost/filesystem/operations.hpp	/^  BOOST_FILESYSTEM_DECL void directory_iterator_increment(directory_iterator& it,$/;"	p	namespace:boost::filesystem::detail	signature:(directory_iterator& it, system::error_code* ec)
directory_not_empty	/usr/include/boost/system/error_code.hpp	/^        directory_not_empty = ENOTEMPTY,$/;"	e	enum:boost::system::errc::errc_t
directory_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string directory_string() const          { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
dir_entry	/usr/include/boost/filesystem/operations.hpp	/^    directory_entry  dir_entry;$/;"	m	struct:boost::filesystem::detail::dir_itr_imp	access:public
dir_itr_close	/usr/include/boost/filesystem/operations.hpp	/^    system::error_code dir_itr_close(\/\/ never throws()$/;"	p	namespace:boost::filesystem::detail	signature:( void *& handle , void *& buffer )
dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^    dir_itr_imp() : handle(0)$/;"	f	struct:boost::filesystem::detail::dir_itr_imp	access:public	signature:()
dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^  struct dir_itr_imp$/;"	s	namespace:boost::filesystem::detail
disk_full	/usr/include/boost/system/windows_error.hpp	/^        disk_full= ERROR_DISK_FULL,$/;"	e	enum:boost::system::windows_error::windows_error_code
dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^      dispatch(const Container & c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const Container & c, U& to, const codecvt_type& cvt)
dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::string& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::string& c, U& to, const codecvt_type& cvt)
dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::vector<char>& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::vector<char>& c, U& to, const codecvt_type& cvt)
dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::vector<wchar_t>& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::vector<wchar_t>& c, U& to, const codecvt_type& cvt)
dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^    void dispatch(const std::wstring& c, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const std::wstring& c, U& to, const codecvt_type& cvt)
dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^  void dispatch(const directory_entry & de,$/;"	p	namespace:boost::filesystem::path_traits	signature:(const directory_entry & de, std::wstring & to, const codecvt_type&)
dispatch	/usr/include/boost/filesystem/path_traits.hpp	/^  void dispatch(T * const & c_str, U& to, const codecvt_type& cvt)$/;"	f	namespace:boost::filesystem::path_traits	signature:(T * const & c_str, U& to, const codecvt_type& cvt)
distance	/usr/include/boost/regex/v4/regex_workaround.hpp	/^std::ptrdiff_t distance(const T& x, const T& y)$/;"	f	namespace:boost::re_detail	signature:(const T& x, const T& y)
divides_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct divides_impl<boost::units::heterogeneous_system_dim_tag, boost::units::detail::static_rational_tag>$/;"	s	namespace:boost::mpl
divide_systems	/usr/include/boost/units/heterogeneous_system.hpp	/^struct divide_systems$/;"	s	namespace:boost::units::detail
dont_care	/usr/include/boost/regex/v4/states.hpp	/^   dont_care = 1,$/;"	e	enum:boost::re_detail::__anon16
dose_equivalent	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^typedef unit<dose_equivalent_dimension,si::system>     dose_equivalent;$/;"	t	namespace:boost::units::si
dot_dot_error	/usr/include/boost/system/linux_error.hpp	/^        dot_dot_error = EDOTDOT,$/;"	e	enum:boost::system::linux_error::linux_errno
do_assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& do_assign(const charT* p1,$/;"	p	class:boost::basic_regex	access:private	signature:(const charT* p1, const charT* p2, flag_type f)
do_assign	/usr/include/boost/regex/v4/basic_regex.hpp	/^basic_regex<charT, traits>& basic_regex<charT, traits>::do_assign(const charT* p1,$/;"	f	class:boost::basic_regex	signature:(const charT* p1, const charT* p2, flag_type f)
do_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^    void do_filter(const vector_type& src, vector_type& dest)$/;"	f	class:boost::iostreams::basic_regex_filter	access:private	signature:(const vector_type& src, vector_type& dest)
do_format_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline OutputIter do_format_string(const S* s, OutputIter i)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const S* s, OutputIter i)
do_format_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter do_format_string(const S& s, OutputIter i)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const S& s, OutputIter i)
do_get	/usr/include/boost/regex/pending/object_cache.hpp	/^   static boost::shared_ptr<Object const> do_get(const Key& k, size_type l_max_cache_size);$/;"	p	class:boost::object_cache	access:private	signature:(const Key& k, size_type l_max_cache_size)
do_get	/usr/include/boost/regex/pending/object_cache.hpp	/^boost::shared_ptr<Object const> object_cache<Key, Object>::do_get(const Key& k, size_type l_max_cache_size)$/;"	f	class:boost::object_cache	signature:(const Key& k, size_type l_max_cache_size)
do_global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL do_global_lower(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
do_global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL unsigned short BOOST_REGEX_CALL do_global_lower(unsigned short c);$/;"	p	namespace:boost::re_detail	signature:(unsigned short c)
do_global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL do_global_lower(wchar_t c);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c)
do_global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL do_global_upper(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
do_global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL unsigned short BOOST_REGEX_CALL do_global_upper(unsigned short c);$/;"	p	namespace:boost::re_detail	signature:(unsigned short c)
do_global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL do_global_upper(wchar_t c);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c)
do_make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex do_make_u32regex(InputIterator i, $/;"	f	namespace:boost::re_detail	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt, const boost::mpl::int_<1>*)
do_make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex do_make_u32regex(InputIterator i, $/;"	f	namespace:boost::re_detail	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt, const boost::mpl::int_<2>*)
do_make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex do_make_u32regex(InputIterator i, $/;"	f	namespace:boost::re_detail	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt, const boost::mpl::int_<4>*)
do_regex_match	/usr/include/boost/regex/icu.hpp	/^bool do_regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, boost::mpl::int_<1> const*)
do_regex_match	/usr/include/boost/regex/icu.hpp	/^bool do_regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, boost::mpl::int_<2> const*)
do_regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool do_regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, boost::mpl::int_<4> const*)
do_regex_replace	/usr/include/boost/regex/icu.hpp	/^OutputIterator do_regex_replace(OutputIterator out,$/;"	f	namespace:boost::re_detail	signature:(OutputIterator out, std::pair<I1, I1> const& in, const u32regex& e, const std::pair<I2, I2>& fmt, match_flag_type flags )
do_regex_search	/usr/include/boost/regex/icu.hpp	/^bool do_regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base, boost::mpl::int_<1> const*)
do_regex_search	/usr/include/boost/regex/icu.hpp	/^bool do_regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base, boost::mpl::int_<2> const*)
do_regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool do_regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost::re_detail	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base, boost::mpl::int_<4> const*)
do_toi	/usr/include/boost/regex/v4/sub_match.hpp	/^int do_toi(BidiIterator i, BidiIterator j, char c, int radix)$/;"	f	namespace:boost::re_detail	signature:(BidiIterator i, BidiIterator j, char c, int radix)
do_toi	/usr/include/boost/regex/v4/sub_match.hpp	/^int do_toi(I& i, I j, charT c)$/;"	f	namespace:boost::re_detail	signature:(I& i, I j, charT c)
do_transform	/usr/include/boost/regex/icu.hpp	/^   string_type do_transform(const char_type* p1, const char_type* p2, const U_NAMESPACE_QUALIFIER Collator* pcoll) const;$/;"	p	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const char_type* p1, const char_type* p2, const U_NAMESPACE_QUALIFIER Collator* pcoll) const
dup_name	/usr/include/boost/system/windows_error.hpp	/^        dup_name = ERROR_DUP_NAME,$/;"	e	enum:boost::system::windows_error::windows_error_code
duration	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef BOOST_SYSTEM_CLOCK_DURATION          duration;$/;"	t	class:boost::chrono::system_clock	access:public
duration	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef nanoseconds                          duration;$/;"	t	class:boost::chrono::steady_clock	access:public
dynamic_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct dynamic_cast_$/;"	s	namespace:boost::xpressive::op
dynamic_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^    dynamic_cast_(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
dynamic_viscosity	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^typedef unit<dynamic_viscosity_dimension,cgs::system>     dynamic_viscosity;$/;"	t	namespace:boost::units::cgs
dynamic_viscosity	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	/^typedef unit<dynamic_viscosity_dimension,si::system>     dynamic_viscosity;$/;"	t	namespace:boost::units::si
ECMAScript	/usr/include/boost/regex/v4/regbase.hpp	/^      ECMAScript = normal,$/;"	e	enum:boost::regbase::flag_type_
ECMAScript	/usr/include/boost/regex/v4/regbase.hpp	/^      ECMAScript = normal,$/;"	e	enum:boost::regex_constants::flag_type_
ECMAScript	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ECMAScript;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
ECMAScript	/usr/include/boost/xpressive/regex_constants.hpp	/^    ECMAScript  = 0,        \/\/\/< Specifies that the grammar recognized by the regular expression$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
eflags	/usr/include/boost/regex/v4/cregex.hpp	/^   match_flag_type eflags;           \/* none of your business :-) *\/$/;"	m	struct:boost::__anon4	access:public
eflags	/usr/include/boost/regex/v4/cregex.hpp	/^   match_flag_type eflags;        \/* none of your business :-) *\/$/;"	m	struct:boost::__anon3	access:public
egrep	/usr/include/boost/regex/v4/regbase.hpp	/^      egrep = ::boost::regbase::egrep,$/;"	e	enum:boost::regex_constants::flag_type_
egrep	/usr/include/boost/regex/v4/regbase.hpp	/^      egrep = extended | newline_alt,$/;"	e	enum:boost::regbase::flag_type_
electric_charge	/usr/include/boost/units/systems/si/electric_charge.hpp	/^typedef unit<electric_charge_dimension,si::system>    electric_charge;$/;"	t	namespace:boost::units::si
electric_charge_over_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<electric_charge,amount>::type electric_charge_over_amount;$/;"	t	namespace:boost::units::si::constants::codata
electric_charge_over_mass	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<electric_charge,mass>::type electric_charge_over_mass;$/;"	t	namespace:boost::units::si::constants::codata
electric_potential	/usr/include/boost/units/systems/si/electric_potential.hpp	/^typedef unit<electric_potential_dimension,si::system>    electric_potential;$/;"	t	namespace:boost::units::si
element_type	/usr/include/boost/filesystem/operations.hpp	/^      typedef directory_iterator element_type;$/;"	t	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
emacs	/usr/include/boost/regex/v4/regbase.hpp	/^      emacs = ::boost::regbase::emacs,$/;"	e	enum:boost::regex_constants::flag_type_
emacs	/usr/include/boost/regex/v4/regbase.hpp	/^      emacs = basic_syntax_group | collate | emacs_ex | bk_vbar,$/;"	e	enum:boost::regbase::flag_type_
emacs_ex	/usr/include/boost/regex/v4/regbase.hpp	/^      emacs_ex = 1 << 12,                         \/\/ enables emacs extensions$/;"	e	enum:boost::regbase::flag_type_
empty	/usr/include/boost/filesystem/path.hpp	/^    bool empty() const               { return m_pathname.empty(); } \/\/ name consistent with std containers$/;"	f	class:boost::filesystem::path	access:public	signature:() const
empty	/usr/include/boost/filesystem/path_traits.hpp	/^      empty(const Container & c)$/;"	f	namespace:boost::filesystem::path_traits	signature:(const Container & c)
empty	/usr/include/boost/filesystem/path_traits.hpp	/^    bool empty(T * const & c_str)$/;"	f	namespace:boost::filesystem::path_traits	signature:(T * const & c_str)
empty	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL empty()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
empty	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool empty()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
empty	/usr/include/boost/regex/v4/match_results.hpp	/^   bool empty() const$/;"	f	class:boost::match_results	access:public	signature:() const
empty_locale	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    struct empty_locale$/;"	s	namespace:boost::xpressive::detail
empty_padding	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct empty_padding{};$/;"	s	namespace:boost::re_detail
end	/usr/include/boost/filesystem/path.hpp	/^    iterator end() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
end	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL end()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
end	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL end()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
end	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* end(){ return _last; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
end	/usr/include/boost/regex/v4/match_results.hpp	/^   const_iterator end() const$/;"	f	class:boost::match_results	access:public	signature:() const
end	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state *base, *end;$/;"	m	struct:boost::re_detail::saved_extra_block	access:public
end	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   BidirectionalIterator                end;   \/\/ end of sequence$/;"	m	class:boost::regex_iterator_implementation	access:private
end	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   pointer last, start, end;$/;"	m	class:boost::re_detail::raw_storage	access:private
end	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   BidirectionalIterator                end;    \/\/ end of search area$/;"	m	class:boost::regex_token_iterator_implementation	access:private
end	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   BidirectionalIterator                end;   \/\/ end of sequence$/;"	m	class:boost::u32regex_iterator_implementation	access:private
end	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   BidirectionalIterator                end;    \/\/ end of search area$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
end	/usr/include/boost/xpressive/regex_algorithms.hpp	/^      , BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) end$/;"	m	namespace:boost::xpressive::detail
energy	/usr/include/boost/units/systems/cgs/energy.hpp	/^typedef unit<energy_dimension,cgs::system>   energy;$/;"	t	namespace:boost::units::cgs
energy	/usr/include/boost/units/systems/si/energy.hpp	/^typedef unit<energy_dimension,si::system>    energy;$/;"	t	namespace:boost::units::si
energy_over_magnetic_flux_density	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<energy,magnetic_flux_density>::type energy_over_magnetic_flux_density;$/;"	t	namespace:boost::units::si::constants::codata
energy_over_temperature	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<energy,temperature>::type energy_over_temperature;$/;"	t	namespace:boost::units::si::constants::codata
energy_over_temperature_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<energy_over_temperature,amount>::type energy_over_temperature_amount;$/;"	t	namespace:boost::units::si::constants::codata
energy_time	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef multiply_typeof_helper<energy,time>::type energy_time;$/;"	t	namespace:boost::units::si::constants::codata
ensure_	/usr/include/boost/xpressive/regex_error.hpp	/^    inline bool ensure_($/;"	f	namespace:boost::xpressive::detail	signature:( bool cond , regex_constants::error_type code , char const *msg , char const *fun , char const *file , unsigned long line )
eol	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eol_placeholder>::type const eol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
eos	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eos_matcher>::type const eos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
eow	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_end>::type const eow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
epsilon	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const epsilon = {{}};$/;"	m	class:boost::xpressive::proto::terminal
equal	/usr/include/boost/filesystem/operations.hpp	/^    bool equal(const directory_iterator& rhs) const$/;"	f	class:boost::filesystem::directory_iterator	access:private	signature:(const directory_iterator& rhs) const
equal	/usr/include/boost/filesystem/operations.hpp	/^    bool equal(const recursive_directory_iterator& rhs) const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:private	signature:(const recursive_directory_iterator& rhs) const
equal	/usr/include/boost/filesystem/path.hpp	/^    bool equal(const iterator & rhs) const$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:(const iterator & rhs) const
equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u16_to_u32_iterator& that)const$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:(const u16_to_u32_iterator& that) const
equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u32_to_u16_iterator& that)const$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:(const u32_to_u16_iterator& that) const
equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u32_to_u8_iterator& that)const$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:(const u32_to_u8_iterator& that) const
equal	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   bool equal(const u8_to_u32_iterator& that)const$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:(const u8_to_u32_iterator& that) const
equal	/usr/include/boost/regex/v4/regex_workaround.hpp	/^   inline bool equal($/;"	f	namespace:boost::re_detail	signature:( InputIterator1 first, InputIterator1 last, InputIterator2 with )
equal_range	/usr/include/boost/regex/v4/basic_regex.hpp	/^   range_type equal_range(const charT* i, const charT* j)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(const charT* i, const charT* j) const
equal_range	/usr/include/boost/regex/v4/basic_regex.hpp	/^   range_type equal_range(int h)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(int h) const
equal_to	/usr/include/boost/xpressive/regex_iterator.hpp	/^    bool equal_to(regex_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:(regex_iterator_impl<BidiIter> const &that) const
equal_to	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    bool equal_to(regex_token_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:(regex_token_iterator_impl<BidiIter> const &that) const
equivalent	/usr/include/boost/filesystem/operations.hpp	/^    bool equivalent(const path& p1, const path& p2, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p1, const path& p2, system::error_code* ec=0)
equivalent	/usr/include/boost/filesystem/operations.hpp	/^  bool equivalent(const path& p1, const path& p2) {return detail::equivalent(p1, p2);}$/;"	f	namespace:boost::filesystem	signature:(const path& p1, const path& p2)
equivalent	/usr/include/boost/filesystem/operations.hpp	/^  bool equivalent(const path& p1, const path& p2, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p1, const path& p2, system::error_code& ec)
equivalent	/usr/include/boost/system/error_code.hpp	/^      virtual bool             equivalent( const error_code & code,$/;"	p	class:boost::system::error_category	access:public	signature:( const error_code & code, int condition ) const
equivalent	/usr/include/boost/system/error_code.hpp	/^      virtual bool             equivalent( int code, $/;"	p	class:boost::system::error_category	access:public	signature:( int code, const error_condition & condition ) const
equivalent	/usr/include/boost/system/error_code.hpp	/^    inline bool error_category::equivalent( const error_code & code,$/;"	f	class:boost::system::error_category	signature:( const error_code & code, int condition ) const
equivalent	/usr/include/boost/system/error_code.hpp	/^    inline bool error_category::equivalent( int code,$/;"	f	class:boost::system::error_category	signature:( int code, const error_condition & condition ) const
equivalents_begin	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator equivalents_begin()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
equivalents_end	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator equivalents_end()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
erase_all_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void erase_all_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
erase_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT erase_all_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
erase_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT erase_all_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
erase_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void erase_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
erase_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT erase_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
erase_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT erase_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
errc	/usr/include/boost/system/error_code.hpp	/^    namespace errc$/;"	n	namespace:boost::system
errc_t	/usr/include/boost/system/error_code.hpp	/^      enum errc_t$/;"	g	namespace:boost::system::errc
errno_ecat	/usr/include/boost/system/error_code.hpp	/^    static const error_category &  errno_ecat     = generic_category();$/;"	m	namespace:boost::system
error_backref	/usr/include/boost/regex/v4/error_type.hpp	/^   error_backref = 6,$/;"	e	enum:boost::regex_constants::error_type
error_badarg	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badarg,               \/\/\/< An argument to an action was unbound.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badattr	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badattr,              \/\/\/< Tried to read from an uninitialized attribute.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badbrace	/usr/include/boost/regex/v4/error_type.hpp	/^   error_badbrace = 10,$/;"	e	enum:boost::regex_constants::error_type
error_badbrace	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badbrace,             \/\/\/< The expression contained an invalid range in a {} expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badlookbehind	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badlookbehind,        \/\/\/< An attempt to create a variable-width look-behind assertion$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badmark	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badmark,              \/\/\/< An invalid use of a named capture.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badref	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badref,               \/\/\/< An nested regex is uninitialized.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badrepeat	/usr/include/boost/regex/v4/error_type.hpp	/^   error_badrepeat = 13,$/;"	e	enum:boost::regex_constants::error_type
error_badrepeat	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badrepeat,            \/\/\/< One of *?+{ was not preceded by a valid regular expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badrule	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_badrule,              \/\/\/< An invalid use of a rule was detected.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_bad_pattern	/usr/include/boost/regex/v4/error_type.hpp	/^   error_bad_pattern = 2,$/;"	e	enum:boost::regex_constants::error_type
error_brace	/usr/include/boost/regex/v4/error_type.hpp	/^   error_brace = 9,$/;"	e	enum:boost::regex_constants::error_type
error_brace	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_brace,                \/\/\/< The expression contained mismatched { and }.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_brack	/usr/include/boost/regex/v4/error_type.hpp	/^   error_brack = 7,$/;"	e	enum:boost::regex_constants::error_type
error_brack	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_brack,                \/\/\/< The expression contained mismatched [ and ].$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_category	/usr/include/boost/system/error_code.hpp	/^    class error_category : public noncopyable$/;"	c	namespace:boost::system	inherits:noncopyable
error_code	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL error_code()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
error_code	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int error_code()const;$/;"	p	class:boost::RegEx	access:public	signature:() const
error_code	/usr/include/boost/system/error_code.hpp	/^        error_code(ErrorCodeEnum e,$/;"	f	class:boost::system::error_code	access:public	signature:(ErrorCodeEnum e, typename boost::enable_if<is_error_code_enum<ErrorCodeEnum> >::type* = 0)
error_code	/usr/include/boost/system/error_code.hpp	/^      error_code( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}$/;"	f	class:boost::system::error_code	access:public	signature:( int val, const error_category & cat )
error_code	/usr/include/boost/system/error_code.hpp	/^      error_code() : m_val(0), m_cat(&system_category()) {}$/;"	f	class:boost::system::error_code	access:public	signature:()
error_code	/usr/include/boost/system/error_code.hpp	/^    class error_code$/;"	c	namespace:boost::system
error_collate	/usr/include/boost/regex/v4/error_type.hpp	/^   error_collate = 3,$/;"	e	enum:boost::regex_constants::error_type
error_collate	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_collate,              \/\/\/< The expression contained an invalid collating element name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_complexity	/usr/include/boost/regex/v4/error_type.hpp	/^   error_complexity = 18,$/;"	e	enum:boost::regex_constants::error_type
error_complexity	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_complexity,           \/\/\/< The complexity of an attempted match against a regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_condition	/usr/include/boost/system/error_code.hpp	/^        error_condition(ErrorConditionEnum e,$/;"	f	class:boost::system::error_condition	access:public	signature:(ErrorConditionEnum e, typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum> >::type* = 0)
error_condition	/usr/include/boost/system/error_code.hpp	/^      error_condition( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}$/;"	f	class:boost::system::error_condition	access:public	signature:( int val, const error_category & cat )
error_condition	/usr/include/boost/system/error_code.hpp	/^      error_condition() : m_val(0), m_cat(&generic_category()) {}$/;"	f	class:boost::system::error_condition	access:public	signature:()
error_condition	/usr/include/boost/system/error_code.hpp	/^    class error_condition$/;"	c	namespace:boost::system
error_ctype	/usr/include/boost/regex/v4/error_type.hpp	/^   error_ctype = 4,$/;"	e	enum:boost::regex_constants::error_type
error_ctype	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_ctype,                \/\/\/< The expression contained an invalid character class name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_empty	/usr/include/boost/regex/v4/error_type.hpp	/^   error_empty = 17,$/;"	e	enum:boost::regex_constants::error_type
error_end	/usr/include/boost/regex/v4/error_type.hpp	/^   error_end = 14,    \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
error_escape	/usr/include/boost/regex/v4/error_type.hpp	/^   error_escape = 5,$/;"	e	enum:boost::regex_constants::error_type
error_escape	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_escape,               \/\/\/< The expression contained an invalid escaped character,$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_internal	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_internal              \/\/\/< An internal error has occurred.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_no_match	/usr/include/boost/regex/v4/error_type.hpp	/^   error_no_match = 1,   \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
error_ok	/usr/include/boost/regex/v4/error_type.hpp	/^   error_ok = 0,         \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
error_paren	/usr/include/boost/regex/v4/error_type.hpp	/^   error_paren = 8,$/;"	e	enum:boost::regex_constants::error_type
error_paren	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_paren,                \/\/\/< The expression contained mismatched ( and ).$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_perl_extension	/usr/include/boost/regex/v4/error_type.hpp	/^   error_perl_extension = 20,$/;"	e	enum:boost::regex_constants::error_type
error_range	/usr/include/boost/regex/v4/error_type.hpp	/^   error_range = 11,$/;"	e	enum:boost::regex_constants::error_type
error_range	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_range,                \/\/\/< The expression contained an invalid character range, for$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_right_paren	/usr/include/boost/regex/v4/error_type.hpp	/^   error_right_paren = 16,  \/* not used *\/$/;"	e	enum:boost::regex_constants::error_type
error_size	/usr/include/boost/regex/v4/error_type.hpp	/^   error_size = 15,$/;"	e	enum:boost::regex_constants::error_type
error_space	/usr/include/boost/regex/v4/error_type.hpp	/^   error_space = 12,$/;"	e	enum:boost::regex_constants::error_type
error_space	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_space,                \/\/\/< There was insufficient memory to convert the expression into a$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_stack	/usr/include/boost/regex/v4/error_type.hpp	/^   error_stack = 19,$/;"	e	enum:boost::regex_constants::error_type
error_stack	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_stack,                \/\/\/< There was insufficient memory to determine whether the regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_string	/usr/include/boost/regex/icu.hpp	/^   std::string error_string(::boost::regex_constants::error_type n) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(::boost::regex_constants::error_type n) const
error_string	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(regex_constants::error_type n) const
error_string	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(regex_constants::error_type n) const
error_string	/usr/include/boost/regex/v4/regex_traits.hpp	/^   std::string error_string(::boost::regex_constants::error_type e)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(::boost::regex_constants::error_type e) const
error_string	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(regex_constants::error_type n) const
error_string	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::string error_string(regex_constants::error_type n) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(regex_constants::error_type n) const
error_subreg	/usr/include/boost/xpressive/regex_constants.hpp	/^    error_subreg,               \/\/\/< The expression contained an invalid back-reference.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_type	/usr/include/boost/regex/v4/error_type.hpp	/^enum error_type{$/;"	g	namespace:boost::regex_constants
error_type	/usr/include/boost/xpressive/regex_constants.hpp	/^enum error_type$/;"	g	namespace:boost::xpressive::regex_constants
error_unknown	/usr/include/boost/regex/v4/error_type.hpp	/^   error_unknown = 21$/;"	e	enum:boost::regex_constants::error_type
escape_syntax_type	/usr/include/boost/regex/icu.hpp	/^   ::boost::regex_constants::escape_syntax_type escape_syntax_type(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
escape_syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(char c) const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(char c) const
escape_syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
escape_syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(charT c) const
escape_syntax_type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   ::boost::regex_constants::escape_syntax_type escape_syntax_type(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
escape_syntax_type	/usr/include/boost/regex/v4/syntax_type.hpp	/^typedef syntax_type escape_syntax_type;$/;"	t	namespace:boost::regex_constants
escape_syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(char c) const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(char c) const
escape_syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(charT c) const
escape_syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::escape_syntax_type escape_syntax_type(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
escape_type_ascii_control	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_ascii_control = 35;$/;"	m	namespace:boost::regex_constants
escape_type_backref	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_backref = syntax_digit;$/;"	m	namespace:boost::regex_constants
escape_type_C	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_C = 50;                            \/\/ for \\C$/;"	m	namespace:boost::regex_constants
escape_type_class	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_class = 22; $/;"	m	namespace:boost::regex_constants
escape_type_control_a	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_a = 28;                    \/\/ for \\a$/;"	m	namespace:boost::regex_constants
escape_type_control_f	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_f = 29;$/;"	m	namespace:boost::regex_constants
escape_type_control_n	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_n = 30;$/;"	m	namespace:boost::regex_constants
escape_type_control_r	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_r = 31;$/;"	m	namespace:boost::regex_constants
escape_type_control_t	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_t = 32;$/;"	m	namespace:boost::regex_constants
escape_type_control_v	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_control_v = 33;$/;"	m	namespace:boost::regex_constants
escape_type_decimal	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_decimal = syntax_digit; \/\/ not used$/;"	m	namespace:boost::regex_constants
escape_type_e	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_e = 38;                            \/\/ for \\e$/;"	m	namespace:boost::regex_constants
escape_type_E	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_E = 47;                            \/\/ for \\Q\\E$/;"	m	namespace:boost::regex_constants
escape_type_end_buffer	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_end_buffer = 25;                   \/\/ for \\'$/;"	m	namespace:boost::regex_constants
escape_type_extended_backref	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_extended_backref = 57;             \/\/ for \\g$/;"	m	namespace:boost::regex_constants
escape_type_G	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_G = 52;                            \/\/ for \\G$/;"	m	namespace:boost::regex_constants
escape_type_hex	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_hex = 34;$/;"	m	namespace:boost::regex_constants
escape_type_identity	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_identity = 0; \/\/ not used$/;"	m	namespace:boost::regex_constants
escape_type_left_word	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_left_word = 20;$/;"	m	namespace:boost::regex_constants
escape_type_line_ending	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_line_ending = 59;                  \/\/ for \\R$/;"	m	namespace:boost::regex_constants
escape_type_named_char	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_named_char = 56;                   \/\/ for \\N$/;"	m	namespace:boost::regex_constants
escape_type_not_class	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_not_class = 23; $/;"	m	namespace:boost::regex_constants
escape_type_not_property	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_not_property = 55;                 \/\/ for \\P$/;"	m	namespace:boost::regex_constants
escape_type_not_word_assert	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_not_word_assert = 19;$/;"	m	namespace:boost::regex_constants
escape_type_property	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_property = 54;                     \/\/ for \\p$/;"	m	namespace:boost::regex_constants
escape_type_Q	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_Q = 48;                            \/\/ for \\Q\\E$/;"	m	namespace:boost::regex_constants
escape_type_reset_start_mark	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_reset_start_mark = 58;             \/\/ for \\K$/;"	m	namespace:boost::regex_constants
escape_type_right_word	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_right_word = 21;$/;"	m	namespace:boost::regex_constants
escape_type_start_buffer	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_start_buffer = 24;                 \/\/ for \\`$/;"	m	namespace:boost::regex_constants
escape_type_unicode	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_unicode = 0; \/\/ not used$/;"	m	namespace:boost::regex_constants
escape_type_word_assert	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_word_assert = 18;$/;"	m	namespace:boost::regex_constants
escape_type_X	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_X = 49;                            \/\/ for \\X$/;"	m	namespace:boost::regex_constants
escape_type_Z	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type escape_type_Z = 51;                            \/\/ for \\Z$/;"	m	namespace:boost::regex_constants
escape_value	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef detail::escape_value<char_type, char_class_type> escape_value;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void estimate_max_state_count(std::random_access_iterator_tag*);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(std::random_access_iterator_tag*)
estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void estimate_max_state_count(void*);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(void*)
estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::estimate_max_state_count(void*)$/;"	f	class:boost::re_detail::perl_matcher	signature:(void*)
estimate_max_state_count	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::estimate_max_state_count(std::random_access_iterator_tag*)$/;"	f	class:boost::re_detail::perl_matcher	signature:(std::random_access_iterator_tag*)
exchange_full	/usr/include/boost/system/linux_error.hpp	/^        exchange_full = EXFULL,$/;"	e	enum:boost::system::linux_error::linux_errno
executable_format_error	/usr/include/boost/system/error_code.hpp	/^        executable_format_error = ENOEXEC,$/;"	e	enum:boost::system::errc::errc_t
execute	/usr/include/boost/regex/v4/protected_call.hpp	/^   bool BOOST_REGEX_CALL execute()const;$/;"	p	class:boost::re_detail::abstract_protected_call	access:public	signature:() const
exists	/usr/include/boost/filesystem/operations.hpp	/^  bool exists(const path& p)           {return exists(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
exists	/usr/include/boost/filesystem/operations.hpp	/^  bool exists(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
exists	/usr/include/boost/filesystem/operations.hpp	/^  inline bool exists(file_status f)       { return f.type() != status_error$/;"	f	namespace:boost::filesystem	signature:(file_status f)
exponents	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef typename calculate_base_unit_exponents<typename System::type, Dimensions>::type exponents;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const charT* BOOST_REGEX_CALL expression()const $/;"	f	class:boost::basic_regex	access:public	signature:() const
expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const_iterator BOOST_REGEX_CALL expression()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
Expression	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string Expression()const;$/;"	p	class:boost::RegEx	access:public	signature:() const
extend	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* BOOST_REGEX_CALL extend(size_type n)$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:(size_type n)
extended	/usr/include/boost/regex/v4/regbase.hpp	/^      extended = ::boost::regbase::extended,$/;"	e	enum:boost::regex_constants::flag_type_
extended	/usr/include/boost/regex/v4/regbase.hpp	/^      extended = no_bk_refs | collate | no_perl_ex | no_escape_in_lists,$/;"	e	enum:boost::regbase::flag_type_
extend_stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void extend_stack();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
extend_stack	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::extend_stack()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
extension	/usr/include/boost/filesystem/convenience.hpp	/^    inline std::string extension(const path & p)$/;"	f	namespace:boost::filesystem	signature:(const path & p)
extension	/usr/include/boost/filesystem/path.hpp	/^    path  extension() const;         \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
external_directory_string	/usr/include/boost/filesystem/path.hpp	/^    const string_type external_directory_string() const { return native(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
external_file_string	/usr/include/boost/filesystem/path.hpp	/^    const string_type external_file_string() const      { return native(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u16_to_u32_iterator	access:private	signature:() const
extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u32_to_u16_iterator	access:private	signature:() const
extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u32_to_u8_iterator	access:private	signature:() const
extract_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void extract_current()const$/;"	f	class:boost::u8_to_u32_iterator	access:private	signature:() const
extract_output_base	/usr/include/boost/regex/icu.hpp	/^inline BaseIterator extract_output_base(const utf16_output_iterator<BaseIterator>& b)$/;"	f	namespace:boost::re_detail	signature:(const utf16_output_iterator<BaseIterator>& b)
extract_output_base	/usr/include/boost/regex/icu.hpp	/^inline BaseIterator extract_output_base(const utf8_output_iterator<BaseIterator>& b)$/;"	f	namespace:boost::re_detail	signature:(const utf8_output_iterator<BaseIterator>& b)
extract_output_base	/usr/include/boost/regex/icu.hpp	/^inline const BaseIterator& extract_output_base(const BaseIterator& b)$/;"	f	namespace:boost::re_detail	signature:(const BaseIterator& b)
f	/usr/include/boost/regex/v4/regex_format.hpp	/^   static formatter_wrapper<typename unwrap_reference<F>::type> f;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
fahrenheit	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^namespace fahrenheit {$/;"	n	namespace:boost::units
fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void fail(regex_constants::error_type error_code, std::ptrdiff_t position);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_constants::error_type error_code, std::ptrdiff_t position)
fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void fail(regex_constants::error_type error_code, std::ptrdiff_t position, const std::string& message)$/;"	f	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_constants::error_type error_code, std::ptrdiff_t position, const std::string& message)
fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void fail(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos)
fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::fail(regex_constants::error_type error_code, std::ptrdiff_t position)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(regex_constants::error_type error_code, std::ptrdiff_t position)
fail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::fail(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos)
failbit	/usr/include/boost/regex/v4/regbase.hpp	/^      failbit = 1 << 19,                                \/\/ error flag$/;"	e	enum:boost::regbase::flag_type_
failbit	/usr/include/boost/regex/v4/regbase.hpp	/^      failbit = ::boost::regbase::failbit,$/;"	e	enum:boost::regex_constants::flag_type_
fifo_file	/usr/include/boost/filesystem/operations.hpp	/^    fifo_file,$/;"	e	enum:boost::filesystem::file_type
filebuf	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_filebuf<char> filebuf;$/;"	t	namespace:boost::filesystem
filename	/usr/include/boost/filesystem/path.hpp	/^    path  filename() const;          \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
filename_too_long	/usr/include/boost/system/error_code.hpp	/^        filename_too_long = ENAMETOOLONG,$/;"	e	enum:boost::system::errc::errc_t
filesystem	/usr/include/boost/filesystem/convenience.hpp	/^  namespace filesystem$/;"	n	namespace:boost
filesystem	/usr/include/boost/filesystem/fstream.hpp	/^namespace filesystem$/;"	n	namespace:boost
filesystem	/usr/include/boost/filesystem/operations.hpp	/^  namespace filesystem$/;"	n	namespace:boost
filesystem	/usr/include/boost/filesystem/path.hpp	/^namespace filesystem$/;"	n	namespace:boost
filesystem	/usr/include/boost/filesystem/path_traits.hpp	/^namespace boost { namespace filesystem {$/;"	n	namespace:boost
filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    filesystem_error($/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:( const std::string & what_arg, const path& path1_arg, const path& path2_arg, system::error_code ec)
filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    filesystem_error($/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:( const std::string & what_arg, const path& path1_arg, system::error_code ec)
filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    filesystem_error($/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:( const std::string & what_arg, system::error_code ec)
filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^  class BOOST_SYMBOL_VISIBLE filesystem_error : public system::system_error$/;"	c	namespace:boost::filesystem	inherits:system::system_error
file_exists	/usr/include/boost/system/error_code.hpp	/^        file_exists = EEXIST,$/;"	e	enum:boost::system::errc::errc_t
file_exists	/usr/include/boost/system/windows_error.hpp	/^        file_exists = ERROR_FILE_EXISTS,$/;"	e	enum:boost::system::windows_error::windows_error_code
file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator();$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:()
file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator(const char* wild);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(const char* wild)
file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator(const file_iterator&);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(const file_iterator&)
file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^class BOOST_REGEX_DECL file_iterator $/;"	c	namespace:boost::re_detail
file_iterator_ref	/usr/include/boost/regex/v4/fileiter.hpp	/^struct file_iterator_ref$/;"	s	namespace:boost::re_detail
file_not_found	/usr/include/boost/filesystem/operations.hpp	/^    file_not_found,$/;"	e	enum:boost::filesystem::file_type
file_not_found	/usr/include/boost/system/windows_error.hpp	/^        file_not_found = ERROR_FILE_NOT_FOUND,$/;"	e	enum:boost::system::windows_error::windows_error_code
file_size	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t file_size(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
file_size	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t file_size(const path& p) {return detail::file_size(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
file_size	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t file_size(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
file_status	/usr/include/boost/filesystem/operations.hpp	/^             file_status()            : m_value(status_error), m_perms(perms_not_known) {}$/;"	f	class:boost::filesystem::file_status	access:public	signature:()
file_status	/usr/include/boost/filesystem/operations.hpp	/^    explicit file_status(file_type v, perms prms = perms_not_known)$/;"	f	class:boost::filesystem::file_status	access:public	signature:(file_type v, perms prms = perms_not_known)
file_status	/usr/include/boost/filesystem/operations.hpp	/^  class BOOST_FILESYSTEM_DECL file_status$/;"	c	namespace:boost::filesystem
file_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string file_string() const               { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
file_too_large	/usr/include/boost/system/error_code.hpp	/^        file_too_large = EFBIG,$/;"	e	enum:boost::system::errc::errc_t
file_type	/usr/include/boost/filesystem/operations.hpp	/^  enum file_type$/;"	g	namespace:boost::filesystem
finalize	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void finalize(const charT* p1, const charT* p2);$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(const charT* p1, const charT* p2)
finalize	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::finalize(const charT* p1, const charT* p2)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(const charT* p1, const charT* p2)
find	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find();$/;"	p	class:boost::re_detail::perl_matcher	access:public	signature:()
find	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::find()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
finder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct finder$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
finder_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<finder<BidiIter> > finder_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
FindFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int FindFiles(FindFilesCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(FindFilesCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default)
FindFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int FindFiles(FindFilesCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default) { return FindFiles(cb, files.c_str(), recurse, flags); }$/;"	f	class:boost::RegEx	access:public	signature:(FindFilesCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default)
FindFilesCallback	/usr/include/boost/regex/v4/cregex.hpp	/^typedef bool (__cdecl *FindFilesCallback)(const char* file);$/;"	t	namespace:boost
find_all_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceSequenceT& find_all_regex($/;"	f	namespace:boost::algorithm	signature:( SequenceSequenceT& Result, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
find_imp	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_imp();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
find_imp	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_imp()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
find_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        find_regex( $/;"	f	namespace:boost::algorithm	signature:( RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
find_regexF	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                find_regexF( regex_reference_type Rx, match_flag_type MatchFlags = match_default ) : $/;"	f	struct:boost::algorithm::detail::find_regexF	access:public	signature:( regex_reference_type Rx, match_flag_type MatchFlags = match_default )
find_regexF	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^            struct find_regexF$/;"	s	namespace:boost::algorithm::detail
find_restart_any	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_any();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
find_restart_any	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_any()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
find_restart_buf	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_buf();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
find_restart_buf	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_buf()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
find_restart_line	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_line();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
find_restart_line	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_line()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
find_restart_lit	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_lit();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
find_restart_lit	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_lit()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
find_restart_word	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool find_restart_word();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
find_restart_word	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_word()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
find_sort_syntax	/usr/include/boost/regex/v4/primary_transform.hpp	/^unsigned find_sort_syntax(const traits* pt, charT* delim)$/;"	f	namespace:boost::re_detail	signature:(const traits* pt, charT* delim)
first	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct first$/;"	s	namespace:boost::xpressive::op
first	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::first>::type const first = {{}};$/;"	m	class:boost::xpressive::function
fixup_pointers	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void fixup_pointers(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
fixup_pointers	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::fixup_pointers(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
fixup_recursions	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void fixup_recursions(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
fixup_recursions	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::fixup_recursions(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
flags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type BOOST_REGEX_CALL flags()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
flags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type BOOST_REGEX_CALL flags()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
flags	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   regbase::flag_type flags()$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:()
flags	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void flags(regbase::flag_type f)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(regbase::flag_type f)
flags	/usr/include/boost/regex/v4/regex_format.hpp	/^   static boost::regex_constants::match_flag_type flags;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
flags	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   match_flag_type                      flags; \/\/ flags for matching$/;"	m	class:boost::regex_iterator_implementation	access:private
flags	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   match_flag_type                      flags;  \/\/ match flags$/;"	m	class:boost::regex_token_iterator_implementation	access:private
flags	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   match_flag_type                      flags; \/\/ flags for matching$/;"	m	class:boost::u32regex_iterator_implementation	access:private
flags	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   match_flag_type                      flags;  \/\/ match flags$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
flags_	/usr/include/boost/iostreams/filter/regex.hpp	/^    flag_type   flags_;$/;"	m	class:boost::iostreams::basic_regex_filter	access:private
flags_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_constants::match_flag_type const flags_;$/;"	m	class:boost::xpressive::detail::regex_iterator_impl::regex_constants	access:public
flag_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef regex_constants::match_flag_type           flag_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
flag_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::flag_type flag_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
flag_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::flag_type flag_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
flag_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::flag_type flag_type;$/;"	t	struct:boost::RegexConcept	access:public
flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef regex_constants::syntax_option_type   flag_type;$/;"	t	class:boost::basic_regex	access:public
flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef regex_constants::syntax_option_type   flag_type;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef regex_constants::syntax_option_type   flag_type;$/;"	t	struct:boost::re_detail::regex_data	access:public
flag_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename basic_regex<charT, traits>::flag_type flag_type;$/;"	t	class:boost::reg_expression	access:public
flag_type	/usr/include/boost/regex/v4/regbase.hpp	/^   typedef unsigned int flag_type;$/;"	t	class:boost::regbase	access:public
flag_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
flag_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
flag_type_	/usr/include/boost/regex/v4/regbase.hpp	/^   enum flag_type_$/;"	g	class:boost::regbase	access:public
flag_type_	/usr/include/boost/regex/v4/regbase.hpp	/^   enum flag_type_$/;"	g	namespace:boost::regex_constants
fmt_	/usr/include/boost/iostreams/filter/regex.hpp	/^        string_type  fmt_;$/;"	m	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public
fmt_flags_	/usr/include/boost/iostreams/filter/regex.hpp	/^        flag_type    fmt_flags_;$/;"	m	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public
fold_case	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
fold_case	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch) const
force	/usr/include/boost/units/systems/cgs/force.hpp	/^typedef unit<force_dimension,cgs::system>        force;$/;"	t	namespace:boost::units::cgs
force	/usr/include/boost/units/systems/si/force.hpp	/^typedef unit<force_dimension,si::system>     force;$/;"	t	namespace:boost::units::si
force_newline	/usr/include/boost/regex/v4/states.hpp	/^   force_newline = 2,$/;"	e	enum:boost::re_detail::__anon16
force_not_newline	/usr/include/boost/regex/v4/states.hpp	/^   force_not_newline = 0,$/;"	e	enum:boost::re_detail::__anon16
force_over_current_squared	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<divide_typeof_helper<force,current>::type,current>::type force_over_current_squared;$/;"	t	namespace:boost::units::si::constants::codata
fork_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
fork_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
format	/usr/include/boost/regex/v4/match_results.hpp	/^   OutputIterator format(OutputIterator out,$/;"	f	class:boost::match_results	access:public	signature:(OutputIterator out, Functor fmt, match_flag_type flags = format_default) const
format	/usr/include/boost/regex/v4/match_results.hpp	/^   OutputIterator format(OutputIterator out,$/;"	f	class:boost::match_results	access:public	signature:(OutputIterator out, Functor fmt, match_flag_type flags, const RegexT& re) const
format	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type format(Functor fmt, match_flag_type flags = format_default) const$/;"	f	class:boost::match_results	access:public	signature:(Functor fmt, match_flag_type flags = format_default) const
format	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type format(Functor fmt,$/;"	f	class:boost::match_results	access:public	signature:(Functor fmt, match_flag_type flags, const RegexT& re) const
format	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIterator format(ForwardIter p1, ForwardIter p2, match_flag_type f);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:public	signature:(ForwardIter p1, ForwardIter p2, match_flag_type f)
format	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIterator format(ForwardIter p1, match_flag_type f)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:public	signature:(ForwardIter p1, match_flag_type f)
format	/usr/include/boost/regex/v4/regex_format.hpp	/^OutputIterator basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format(ForwardIter p1, ForwardIter p2, match_flag_type f)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(ForwardIter p1, ForwardIter p2, match_flag_type f)
formatter	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef function1<string_type, const match_type&>  formatter;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^   formatter_wrapper(){}$/;"	f	struct:boost::re_detail::formatter_wrapper	access:public	signature:()
formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^struct formatter_wrapper$/;"	s	namespace:boost::re_detail	inherits:Formatter,unary_binary_ternary
formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^struct formatter_wrapper<Formatter *, false>$/;"	s	namespace:boost::re_detail	inherits:unary_binary_ternary
formatter_wrapper	/usr/include/boost/regex/v4/regex_format.hpp	/^struct formatter_wrapper<Formatter, true>$/;"	s	namespace:boost::re_detail	inherits:unary_binary_ternary
format_all	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_all = format_sed << 1,                     \/* enable all extentions to sytax. *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_all	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_all();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
format_all	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_all()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
format_all	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_all              = 1 << 18   \/\/\/< Specifies that all syntax extensions are enabled,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_conditional	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_conditional();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
format_conditional	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_conditional()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
format_default	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_default = 0,                               \/* ditto. *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_default	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_default          = 0,        \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_escape	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_escape();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
format_escape	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_escape()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
format_first_only	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_first_only = format_no_copy << 1,          \/* Only replace first occurance. *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_first_only	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_first_only       = 1 << 16,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_functor1	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor1(Base b) : func(b) {}$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(Base b)
format_functor1	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor1(const format_functor1&);$/;"	p	struct:boost::re_detail::format_functor1	access:private	signature:(const format_functor1&)
format_functor1	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor1$/;"	s	namespace:boost::re_detail
format_functor2	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor2(Base b) : func(b) {}$/;"	f	struct:boost::re_detail::format_functor2	access:public	signature:(Base b)
format_functor2	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor2(const format_functor2&);$/;"	p	struct:boost::re_detail::format_functor2	access:private	signature:(const format_functor2&)
format_functor2	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor2$/;"	s	namespace:boost::re_detail
format_functor3	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor3(Base b) : func(b) {}$/;"	f	struct:boost::re_detail::format_functor3	access:public	signature:(Base b)
format_functor3	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor3(const format_functor3&);$/;"	p	struct:boost::re_detail::format_functor3	access:private	signature:(const format_functor3&)
format_functor3	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor3$/;"	s	namespace:boost::re_detail
format_functor_container	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_container(const Container& c) : func(c) {}$/;"	f	struct:boost::re_detail::format_functor_container	access:public	signature:(const Container& c)
format_functor_container	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_container(const format_functor_container&);$/;"	p	struct:boost::re_detail::format_functor_container	access:private	signature:(const format_functor_container&)
format_functor_container	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor_container$/;"	s	namespace:boost::re_detail
format_functor_c_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_c_string(const charT* ps) : func(ps) {}$/;"	f	struct:boost::re_detail::format_functor_c_string	access:public	signature:(const charT* ps)
format_functor_c_string	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_c_string(const format_functor_c_string&);$/;"	p	struct:boost::re_detail::format_functor_c_string	access:private	signature:(const format_functor_c_string&)
format_functor_c_string	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_functor_c_string$/;"	s	namespace:boost::re_detail
format_is_if	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_is_if = format_first_only << 1,            \/* internal use only. *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_literal	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_literal = format_is_if << 1                \/* treat string as a literal *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_literal	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_literal          = 1 << 17,  \/\/\/< Treat the format string as a literal.$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_no_copy	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_no_copy = format_all << 1,                 \/* don't copy non-matching segments. *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_no_copy	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_no_copy          = 1 << 15,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_perl	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_perl = 0,                                  \/* perl style replacement *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_perl	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_perl();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
format_perl	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_perl()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
format_perl	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_perl             = 1 << 14,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_sed	/usr/include/boost/regex/v4/match_flags.hpp	/^   format_sed = match_max << 1,                      \/* sed style replacement. *\/$/;"	e	enum:boost::regex_constants::_match_flags
format_sed	/usr/include/boost/xpressive/regex_constants.hpp	/^    format_sed              = 1 << 13,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_traits	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_traits$/;"	s	namespace:boost::re_detail
format_traits_imp	/usr/include/boost/regex/v4/regex_format.hpp	/^struct format_traits_imp$/;"	s	namespace:boost::re_detail
format_until_scope_end	/usr/include/boost/regex/v4/regex_format.hpp	/^   void format_until_scope_end();$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:()
format_until_scope_end	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::format_until_scope_end()$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:()
fractional_seconds_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_duration_type::fractional_seconds_type fractional_seconds_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
frac_sec_per_day	/usr/include/boost/date_time/time_system_counted.hpp	/^    static int_type frac_sec_per_day()$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:()
free	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t free;      \/\/ <= capacity$/;"	m	struct:boost::filesystem::space_info	access:public
frequency	/usr/include/boost/units/systems/cgs/frequency.hpp	/^typedef unit<frequency_dimension,cgs::system>        frequency;$/;"	t	namespace:boost::units::cgs
frequency	/usr/include/boost/units/systems/si/frequency.hpp	/^typedef unit<frequency_dimension,si::system>     frequency;$/;"	t	namespace:boost::units::si
frequency_over_electric_potential	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<frequency,electric_potential>::type frequency_over_electric_potential;$/;"	t	namespace:boost::units::si::constants::codata
frequency_over_magnetic_flux_density	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<frequency,magnetic_flux_density>::type frequency_over_magnetic_flux_density;$/;"	t	namespace:boost::units::si::constants::codata
frequency_over_temperature	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<frequency,temperature>::type frequency_over_temperature;$/;"	t	namespace:boost::units::si::constants::codata
front	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct front$/;"	s	namespace:boost::xpressive::op
front	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::front>::type const front = {{}};$/;"	m	class:boost::xpressive::function
fstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_fstream<char> fstream;$/;"	t	namespace:boost::filesystem
func	/usr/include/boost/regex/v4/regex_format.hpp	/^   Base func;$/;"	m	struct:boost::re_detail::format_functor1	access:private
func	/usr/include/boost/regex/v4/regex_format.hpp	/^   Base func;$/;"	m	struct:boost::re_detail::format_functor2	access:private
func	/usr/include/boost/regex/v4/regex_format.hpp	/^   Base func;$/;"	m	struct:boost::re_detail::format_functor3	access:private
func	/usr/include/boost/regex/v4/regex_format.hpp	/^   const charT* func;$/;"	m	struct:boost::re_detail::format_functor_c_string	access:private
func	/usr/include/boost/regex/v4/regex_format.hpp	/^   const Container& func;$/;"	m	struct:boost::re_detail::format_functor_container	access:private
function	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct function$/;"	s	namespace:boost::xpressive
function_not_supported	/usr/include/boost/system/error_code.hpp	/^        function_not_supported = ENOSYS,$/;"	e	enum:boost::system::errc::errc_t
functor1	/usr/include/boost/regex/concepts.hpp	/^struct functor1$/;"	s	namespace:boost
functor1b	/usr/include/boost/regex/concepts.hpp	/^struct functor1b$/;"	s	namespace:boost
functor2	/usr/include/boost/regex/concepts.hpp	/^struct functor2$/;"	s	namespace:boost
functor3	/usr/include/boost/regex/concepts.hpp	/^struct functor3$/;"	s	namespace:boost
generic_category	/usr/include/boost/system/error_code.hpp	/^    BOOST_SYSTEM_DECL const error_category &  generic_category();$/;"	p	namespace:boost::system	signature:()
generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string   generic_string() const { return generic_string(codecvt()); } $/;"	f	class:boost::filesystem::path	access:public	signature:() const
generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string   generic_string(const codecvt_type& cvt) const; $/;"	p	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  generic_string() const  { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
generic_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  generic_string(const codecvt_type&) const  { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
generic_string	/usr/include/boost/filesystem/path.hpp	/^    String generic_string() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
generic_string	/usr/include/boost/filesystem/path.hpp	/^    String generic_string(const codecvt_type& cvt) const;$/;"	p	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::generic_string<std::string>() const$/;"	f	class:boost::filesystem::path	signature:() const
generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::generic_string<std::string>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::generic_string<std::wstring>() const$/;"	f	class:boost::filesystem::path	signature:() const
generic_string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::generic_string<std::wstring>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring() const { return wstring(codecvt()); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring(const codecvt_type& cvt) const { return wstring(cvt); }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
generic_wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  generic_wstring(const codecvt_type&) const { return generic_wstring(); };$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
gen_failure	/usr/include/boost/system/windows_error.hpp	/^        gen_failure = ERROR_GEN_FAILURE,$/;"	e	enum:boost::system::windows_error::windows_error_code
geometry	/usr/include/boost/geometry/core/coordinate_system.hpp	/^namespace boost { namespace geometry$/;"	n	namespace:boost
get	/usr/include/boost/regex/pending/object_cache.hpp	/^   static boost::shared_ptr<Object const> get(const Key& k, size_type l_max_cache_size);$/;"	p	class:boost::object_cache	access:public	signature:(const Key& k, size_type l_max_cache_size)
get	/usr/include/boost/regex/pending/object_cache.hpp	/^boost::shared_ptr<Object const> object_cache<Key, Object>::get(const Key& k, size_type l_max_cache_size)$/;"	f	class:boost::object_cache	signature:(const Key& k, size_type l_max_cache_size)
get	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   void* get()$/;"	f	struct:boost::re_detail::mem_block_cache	access:public	signature:()
get	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   const sub_match<BidiIterator>& get() { return sub; }$/;"	f	class:boost::re_detail::backup_subex	access:public	signature:()
get	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const match_results<BidirectionalIterator>& get()$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:()
get	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const value_type& get()$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:()
get	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const match_results<BidirectionalIterator>& get()$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:()
get	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const value_type& get()$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:()
get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T &get() const$/;"	f	struct:boost::xpressive::reference	access:public	signature:() const
get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::local	access:public	signature:() const
get	/usr/include/boost/xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::value	access:public	signature:() const
getaddress	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* getaddress(std::ptrdiff_t off)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(std::ptrdiff_t off)
getaddress	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* getaddress(std::ptrdiff_t off, void* base)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(std::ptrdiff_t off, void* base)
getflags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type BOOST_REGEX_CALL getflags()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
getloc	/usr/include/boost/regex/concepts.hpp	/^   locale_type getloc()const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:() const
getloc	/usr/include/boost/regex/icu.hpp	/^   locale_type getloc()const$/;"	f	class:boost::icu_regex_traits	access:public	signature:() const
getloc	/usr/include/boost/regex/icu.hpp	/^   U_NAMESPACE_QUALIFIER Locale getloc()const$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:() const
getloc	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL getloc()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
getloc	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL getloc()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
getloc	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   locale_type getloc()const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:() const
getloc	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   locale_type getloc()const$/;"	f	struct:boost::c_regex_traits	access:public	signature:() const
getloc	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   locale_type getloc()const$/;"	f	class:boost::w32_regex_traits	access:public	signature:() const
getloc	/usr/include/boost/xpressive/regex_compiler.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:() const
getloc	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:() const
getloc	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:()
getloc	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:()
getnext	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   const charT* getnext() { return this->gptr(); }$/;"	f	class:boost::re_detail::parser_buf	access:public	signature:()
getoffset	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::ptrdiff_t getoffset(const void* addr, const void* base)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(const void* addr, const void* base)
getoffset	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::ptrdiff_t getoffset(void* addr)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(void* addr)
GetSystemInfo	/usr/include/boost/detail/win/system.hpp	/^extern "C" __declspec(dllimport) void __stdcall GetSystemInfo (struct system_info *);$/;"	p	signature:(struct system_info *)
get_allocator	/usr/include/boost/regex/v4/match_results.hpp	/^   allocator_type get_allocator() const$/;"	f	class:boost::match_results	access:public	signature:() const
get_captures	/usr/include/boost/regex/v4/sub_match.hpp	/^   capture_sequence_type& get_captures()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
get_catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static std::string get_catalog_name();$/;"	p	class:boost::cpp_regex_traits	access:public	signature:()
get_catalog_name	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::string cpp_regex_traits<charT>::get_catalog_name()$/;"	f	class:boost::cpp_regex_traits	signature:()
get_catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static std::string get_catalog_name();$/;"	p	class:boost::w32_regex_traits	access:public	signature:()
get_catalog_name	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^std::string w32_regex_traits<charT>::get_catalog_name()$/;"	f	class:boost::w32_regex_traits	signature:()
get_catalog_name_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static std::string& get_catalog_name_inst();$/;"	p	class:boost::cpp_regex_traits	access:private	signature:()
get_catalog_name_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::string& cpp_regex_traits<charT>::get_catalog_name_inst()$/;"	f	class:boost::cpp_regex_traits	signature:()
get_catalog_name_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static std::string& get_catalog_name_inst();$/;"	p	class:boost::w32_regex_traits	access:private	signature:()
get_catalog_name_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^std::string& w32_regex_traits<charT>::get_catalog_name_inst()$/;"	f	class:boost::w32_regex_traits	signature:()
get_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::size_t get_count() { return count; }$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
get_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const regex_data<charT, traits>& get_data()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
get_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const re_detail::regex_data<charT, traits>& get_data()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
get_date	/usr/include/boost/date_time/time_system_counted.hpp	/^    static date_type get_date(const time_rep_type& val)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& val)
get_date	/usr/include/boost/date_time/time_system_split.hpp	/^    static date_type get_date(const time_rep_type& val)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& val)
get_default_class_id	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^int get_default_class_id(const charT* p1, const charT* p2)$/;"	f	namespace:boost::re_detail	signature:(const charT* p1, const charT* p2)
get_default_error_string	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL const char* BOOST_REGEX_CALL get_default_error_string(regex_constants::error_type n);$/;"	p	namespace:boost::re_detail	signature:(regex_constants::error_type n)
get_default_escape_syntax_type	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL regex_constants::escape_syntax_type BOOST_REGEX_CALL get_default_escape_syntax_type(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
get_default_expression	/usr/include/boost/regex/v4/regex_split.hpp	/^const basic_regex<charT>& get_default_expression(charT)$/;"	f	namespace:boost::re_detail	signature:(charT)
get_default_message	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	signature:(regex_constants::syntax_type i)
get_default_message	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type get_default_message(regex_constants::syntax_type);$/;"	p	class:boost::re_detail::cpp_regex_traits_char_layer	access:private	signature:(regex_constants::syntax_type)
get_default_message	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type get_default_message(regex_constants::syntax_type);$/;"	p	class:boost::re_detail::w32_regex_traits_char_layer	access:private	signature:(regex_constants::syntax_type)
get_default_message	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	signature:(regex_constants::syntax_type i)
get_default_syntax	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL const char* BOOST_REGEX_CALL get_default_syntax(regex_constants::syntax_type n);$/;"	p	namespace:boost::re_detail	signature:(regex_constants::syntax_type n)
get_default_syntax_type	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL regex_constants::syntax_type BOOST_REGEX_CALL get_default_syntax_type(char c);$/;"	p	namespace:boost::re_detail	signature:(char c)
get_escape_R_string	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline const char* get_escape_R_string<char>()$/;"	f	namespace:boost::re_detail	signature:()
get_escape_R_string	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline const charT* get_escape_R_string()$/;"	f	namespace:boost::re_detail	signature:()
get_first_state	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const re_detail::re_syntax_base* get_first_state()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
get_first_state	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const re_detail::re_syntax_base* get_first_state()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
get_generic_category	/usr/include/boost/system/error_code.hpp	/^    inline const error_category &  get_generic_category() { return generic_category(); }$/;"	f	namespace:boost::system	signature:()
get_icu_regex_traits_implementation	/usr/include/boost/regex/icu.hpp	/^inline boost::shared_ptr<icu_regex_traits_implementation> get_icu_regex_traits_implementation(const U_NAMESPACE_QUALIFIER Locale& loc)$/;"	f	namespace:boost::re_detail	signature:(const U_NAMESPACE_QUALIFIER Locale& loc)
get_id	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int get_id(const charT* i, const charT* j)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(const charT* i, const charT* j) const
get_id	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int get_id(int h)const$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(int h) const
get_id	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   int get_id() { return state_id; }$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
get_last_closed_paren	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference get_last_closed_paren()const$/;"	f	class:boost::match_results	access:public	signature:() const
get_map	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const unsigned char* get_map()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
get_map	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const unsigned char* get_map()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
get_mark_number	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline int get_mark_number(int i)$/;"	f	namespace:boost::xpressive::detail	signature:(int i)
get_mem_block	/usr/include/boost/regex/config.hpp	/^BOOST_REGEX_DECL void* BOOST_REGEX_CALL get_mem_block();$/;"	p	namespace:boost::re_detail	signature:()
get_mutex_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static static_mutex& get_mutex_inst();$/;"	p	class:boost::cpp_regex_traits	access:private	signature:()
get_mutex_inst	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^static_mutex& cpp_regex_traits<charT>::get_mutex_inst()$/;"	f	class:boost::cpp_regex_traits	signature:()
get_mutex_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static static_mutex& get_mutex_inst();$/;"	p	class:boost::w32_regex_traits	access:private	signature:()
get_mutex_inst	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^static_mutex& w32_regex_traits<charT>::get_mutex_inst()$/;"	f	class:boost::w32_regex_traits	signature:()
get_named_sub	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline typename Results::value_type const& get_named_sub(ForwardIter i, ForwardIter j)$/;"	f	class:boost::re_detail::basic_regex_formatter::Results	access:private	signature:(ForwardIter i, ForwardIter j)
get_named_sub	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline typename Results::value_type const& get_named_sub(ForwardIter i, ForwardIter j, const mpl::false_&)$/;"	f	class:boost::re_detail::basic_regex_formatter::Results	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::false_&)
get_named_sub	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline typename Results::value_type const& get_named_sub(ForwardIter i, ForwardIter j, const mpl::true_&)$/;"	f	class:boost::re_detail::basic_regex_formatter::Results	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::true_&)
get_named_subs	/usr/include/boost/regex/v4/basic_regex.hpp	/^   boost::shared_ptr<re_detail::named_subexpressions > get_named_subs()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
get_named_sub_index	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int get_named_sub_index(ForwardIter i, ForwardIter j)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter i, ForwardIter j)
get_named_sub_index	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int get_named_sub_index(ForwardIter i, ForwardIter j, const mpl::false_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::false_&)
get_named_sub_index	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int get_named_sub_index(ForwardIter i, ForwardIter j, const mpl::true_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter i, ForwardIter j, const mpl::true_&)
get_next_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   digraph<charT> get_next_set_literal(basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(basic_char_set<charT, traits>& char_set)
get_next_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^digraph<charT> basic_regex_parser<charT, traits>::get_next_set_literal(basic_char_set<charT, traits>& char_set)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(basic_char_set<charT, traits>& char_set)
get_posix_category	/usr/include/boost/system/error_code.hpp	/^    inline const error_category &  get_posix_category() { return generic_category(); }$/;"	f	namespace:boost::system	signature:()
get_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    impl_type get_rep()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
get_repeat_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   syntax_element_type get_repeat_type(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
get_repeat_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^syntax_element_type basic_regex_creator<charT, traits>::get_repeat_type(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
get_restart_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned get_restart_type()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
get_restart_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned get_restart_type()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
get_restart_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   unsigned get_restart_type(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
get_restart_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^unsigned basic_regex_creator<charT, traits>::get_restart_type(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
get_scale_list	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list<heterogeneous_system<T> >$/;"	s	namespace:boost::units
get_scale_list	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list<heterogeneous_system_dim<Unit, Exponent> >$/;"	s	namespace:boost::units
get_scale_list_of_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list_of_heterogeneous_system_impl$/;"	s	namespace:boost::units::detail
get_scale_list_of_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct get_scale_list_of_heterogeneous_system_impl<0>$/;"	s	namespace:boost::units::detail
get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system {};$/;"	s	namespace:boost::units
get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system< absolute<Unit> >$/;"	s	namespace:boost::units
get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system< quantity<Unit,Y> >$/;"	s	namespace:boost::units
get_system	/usr/include/boost/units/get_system.hpp	/^struct get_system< unit<Dim,System> >$/;"	s	namespace:boost::units
get_system_category	/usr/include/boost/system/error_code.hpp	/^    inline const error_category &  get_system_category() { return system_category(); }$/;"	f	namespace:boost::system	signature:()
get_time_of_day	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_duration_type get_time_of_day(const time_rep_type& val)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& val)
get_time_of_day	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_duration_type get_time_of_day(const time_rep_type& val)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& val)
get_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type get_time_rep(const date_type& day,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const date_type& day, const time_duration_type& tod, date_time::dst_flags dst=not_dst)
get_time_rep	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type get_time_rep(special_values sv)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(special_values sv)
get_time_rep	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type get_time_rep(const date_type& day,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const date_type& day, const time_duration_type& tod, date_time::dst_flags = not_dst)
get_time_rep	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type get_time_rep(special_values sv)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(special_values sv)
get_traits	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const ::boost::regex_traits_wrapper<traits>& get_traits()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
get_traits	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const ::boost::regex_traits_wrapper<traits>& get_traits()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
global_constraints	/usr/include/boost/regex/concepts.hpp	/^   void global_constraints()$/;"	f	struct:boost::BaseRegexConcept	access:public	signature:()
global_length	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline std::ptrdiff_t global_length<char>(const char* p)$/;"	f	namespace:boost::re_detail	signature:(const char* p)
global_length	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline std::ptrdiff_t global_length<wchar_t>(const wchar_t* p)$/;"	f	namespace:boost::re_detail	signature:(const wchar_t* p)
global_length	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^std::ptrdiff_t global_length(const charT* p)$/;"	f	namespace:boost::re_detail	signature:(const charT* p)
global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline charT BOOST_REGEX_CALL global_lower(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline char BOOST_REGEX_CALL global_lower<char>(char c){ return do_global_lower(c); }$/;"	f	namespace:boost::re_detail	signature:(char c)
global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline unsigned short BOOST_REGEX_CALL global_lower<unsigned short>(unsigned short c){ return do_global_lower(c); }$/;"	f	namespace:boost::re_detail	signature:(unsigned short c)
global_lower	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline wchar_t BOOST_REGEX_CALL global_lower<wchar_t>(wchar_t c){ return do_global_lower(c); }$/;"	f	namespace:boost::re_detail	signature:(wchar_t c)
global_toi	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^int global_toi(const charT*& p1, const charT* p2, int radix, const traits& t)$/;"	f	namespace:boost::re_detail	signature:(const charT*& p1, const charT* p2, int radix, const traits& t)
global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline charT BOOST_REGEX_CALL global_upper(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline char BOOST_REGEX_CALL global_upper<char>(char c){ return do_global_upper(c); }$/;"	f	namespace:boost::re_detail	signature:(char c)
global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline unsigned short BOOST_REGEX_CALL global_upper<unsigned short>(unsigned short c){ return do_global_upper(c); }$/;"	f	namespace:boost::re_detail	signature:(unsigned short c)
global_upper	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^template<> inline wchar_t BOOST_REGEX_CALL global_upper<wchar_t>(wchar_t c){ return do_global_upper(c); }$/;"	f	namespace:boost::re_detail	signature:(wchar_t c)
global_value	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^int global_value(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
gradian	/usr/include/boost/units/systems/angle/gradians.hpp	/^namespace gradian {$/;"	n	namespace:boost::units
graph	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const graph = {{"graph", false}};$/;"	m	class:boost::xpressive::proto::terminal
greedy	/usr/include/boost/regex/v4/states.hpp	/^   bool          greedy;    \/\/ True if this is a greedy repeat$/;"	m	struct:boost::re_detail::re_repeat	access:public
Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(GrepCallback cb, const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(GrepCallback cb, const char* p, match_flag_type flags = match_default)
Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(GrepCallback cb, const std::string& s, match_flag_type flags = match_default) { return Grep(cb, s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(GrepCallback cb, const std::string& s, match_flag_type flags = match_default)
Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::size_t>& v, const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(std::vector<std::size_t>& v, const char* p, match_flag_type flags = match_default)
Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::size_t>& v, const std::string& s, match_flag_type flags = match_default) { return Grep(v, s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(std::vector<std::size_t>& v, const std::string& s, match_flag_type flags = match_default)
Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::string>& v, const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(std::vector<std::string>& v, const char* p, match_flag_type flags = match_default)
Grep	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int Grep(std::vector<std::string>& v, const std::string& s, match_flag_type flags = match_default) { return Grep(v, s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(std::vector<std::string>& v, const std::string& s, match_flag_type flags = match_default)
grep	/usr/include/boost/regex/v4/regbase.hpp	/^      grep = ::boost::regbase::grep,$/;"	e	enum:boost::regex_constants::flag_type_
grep	/usr/include/boost/regex/v4/regbase.hpp	/^      grep = basic | newline_alt,$/;"	e	enum:boost::regbase::flag_type_
GrepCallback	/usr/include/boost/regex/v4/cregex.hpp	/^typedef bool (__cdecl *GrepCallback)(const RegEx& expression);$/;"	t	namespace:boost
GrepFileCallback	/usr/include/boost/regex/v4/cregex.hpp	/^typedef bool (__cdecl *GrepFileCallback)(const char* file, const RegEx& expression);$/;"	t	namespace:boost
GrepFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int GrepFiles(GrepFileCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(GrepFileCallback cb, const char* files, bool recurse = false, match_flag_type flags = match_default)
GrepFiles	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int GrepFiles(GrepFileCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default) { return GrepFiles(cb, files.c_str(), recurse, flags); }$/;"	f	class:boost::RegEx	access:public	signature:(GrepFileCallback cb, const std::string& files, bool recurse = false, match_flag_type flags = match_default)
group_all	/usr/include/boost/filesystem/operations.hpp	/^    group_all = 070,    \/\/ S_IRWXG, Read, write, execute\/search by group$/;"	e	enum:boost::filesystem::perms
group_exe	/usr/include/boost/filesystem/operations.hpp	/^    group_exe = 010,    \/\/ S_IXGRP, Execute\/search permission, group$/;"	e	enum:boost::filesystem::perms
group_read	/usr/include/boost/filesystem/operations.hpp	/^    group_read = 040,   \/\/ S_IRGRP, Read permission, group$/;"	e	enum:boost::filesystem::perms
group_write	/usr/include/boost/filesystem/operations.hpp	/^    group_write = 020,  \/\/ S_IWGRP, Write permission, group$/;"	e	enum:boost::filesystem::perms
guts	/usr/include/boost/regex/v4/cregex.hpp	/^   void* guts;                   \/* none of your business :-) *\/$/;"	m	struct:boost::__anon4	access:public
guts	/usr/include/boost/regex/v4/cregex.hpp	/^   void* guts;                \/* none of your business :-) *\/$/;"	m	struct:boost::__anon3	access:public
handle	/usr/include/boost/filesystem/operations.hpp	/^    void*            handle;$/;"	m	struct:boost::filesystem::detail::dir_itr_imp	access:public
handle_disk_full	/usr/include/boost/system/windows_error.hpp	/^        handle_disk_full= ERROR_HANDLE_DISK_FULL,$/;"	e	enum:boost::system::windows_error::windows_error_code
handle_eof	/usr/include/boost/system/windows_error.hpp	/^        handle_eof = ERROR_HANDLE_EOF,$/;"	e	enum:boost::system::windows_error::windows_error_code
handle_perl_verb	/usr/include/boost/regex/v4/regex_format.hpp	/^   bool handle_perl_verb(bool have_brace);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(bool have_brace)
handle_perl_verb	/usr/include/boost/regex/v4/regex_format.hpp	/^bool basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::handle_perl_verb(bool have_brace)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(bool have_brace)
hard_link_count	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t hard_link_count(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
hard_link_count	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t hard_link_count(const path& p) {return detail::hard_link_count(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
hard_link_count	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t hard_link_count(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
hash	/usr/include/boost/regex/v4/basic_regex.hpp	/^      int hash;$/;"	m	struct:boost::re_detail::named_subexpressions::name	access:public
hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(char ch)
hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<signed char>::hash(signed char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(signed char ch)
hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<unsigned char>::hash(unsigned char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(unsigned char ch)
hash	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(wchar_t ch)
hash	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
hash	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
hash	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch)
hash	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
hash_value	/usr/include/boost/filesystem/path.hpp	/^  inline std::size_t hash_value(const path& x)$/;"	f	namespace:boost::filesystem	signature:(const path& x)
hash_value	/usr/include/boost/regex/concepts.hpp	/^inline long hash_value(char_architype val)$/;"	f	namespace:boost	signature:(char_architype val)
hash_value	/usr/include/boost/system/error_code.hpp	/^    inline std::size_t hash_value( const error_code & ec )$/;"	f	namespace:boost::system	signature:( const error_code & ec )
hash_value_from_capture_name	/usr/include/boost/regex/v4/basic_regex.hpp	/^inline int hash_value_from_capture_name(Iterator i, Iterator j)$/;"	f	namespace:boost::re_detail	signature:(Iterator i, Iterator j)
has_branch_path	/usr/include/boost/filesystem/path.hpp	/^    bool   has_branch_path() const  { return !parent_path().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_digraphs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool has_digraphs()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
has_extension	/usr/include/boost/filesystem/path.hpp	/^    bool has_extension() const       { return !extension().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_filename	/usr/include/boost/filesystem/path.hpp	/^    bool has_filename() const        { return !m_pathname.empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_fold_case	/usr/include/boost/xpressive/regex_traits.hpp	/^struct has_fold_case$/;"	s	namespace:boost::xpressive	inherits:is_convertible
has_fold_case	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^struct has_fold_case<cpp_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
has_fold_case	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^struct has_fold_case<c_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
has_leaf	/usr/include/boost/filesystem/path.hpp	/^    bool   has_leaf() const         { return !m_pathname.empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_parent_path	/usr/include/boost/filesystem/path.hpp	/^    bool has_parent_path() const     { return !parent_path().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_relative_path	/usr/include/boost/filesystem/path.hpp	/^    bool has_relative_path() const   { return !relative_path().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_root_directory	/usr/include/boost/filesystem/path.hpp	/^    bool has_root_directory() const  { return !root_directory().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_root_name	/usr/include/boost/filesystem/path.hpp	/^    bool has_root_name() const       { return !root_name().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_root_path	/usr/include/boost/filesystem/path.hpp	/^    bool has_root_path() const       { return has_root_directory() || has_root_name(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
has_stem	/usr/include/boost/filesystem/path.hpp	/^    bool has_stem() const            { return !stem().empty(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
heterogeneous_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system : T {};$/;"	s	namespace:boost::units	inherits:T
heterogeneous_system_dim	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system_dim$/;"	s	namespace:boost::units
heterogeneous_system_dim_tag	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system_dim_tag {};$/;"	s	namespace:boost::units
heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct heterogeneous_system_impl$/;"	s	namespace:boost::units
hf	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_handle hf;$/;"	m	struct:boost::re_detail::file_iterator_ref	access:public
hfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   HANDLE hfile;$/;"	m	class:boost::re_detail::mapfile	access:private
hidden_mark_count_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
hidden_mark_count_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
highest_bit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const highest_bit = static_cast<umaskex_t>(1) << (sizeof(umaskex_t) * CHAR_BIT - 1);$/;"	m	namespace:boost::xpressive::detail
high_resolution_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  typedef steady_clock high_resolution_clock;  \/\/ as permitted by [time.clock.hires]$/;"	t	namespace:boost::chrono
high_resolution_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  typedef system_clock high_resolution_clock;  \/\/ as permitted by [time.clock.hires]$/;"	t	namespace:boost::chrono
high_surrogate_base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^static const ::boost::uint16_t high_surrogate_base = 0xD7C0u;$/;"	m	namespace:boost::detail
hmap	/usr/include/boost/regex/v4/fileiter.hpp	/^   HANDLE hmap;$/;"	m	class:boost::re_detail::mapfile	access:private
homogeneous_system	/usr/include/boost/units/homogeneous_system.hpp	/^struct homogeneous_system {$/;"	s	namespace:boost::units
host_down	/usr/include/boost/system/linux_error.hpp	/^        host_down = EHOSTDOWN,$/;"	e	enum:boost::system::linux_error::linux_errno
host_unreachable	/usr/include/boost/system/error_code.hpp	/^        host_unreachable = EHOSTUNREACH,$/;"	e	enum:boost::system::errc::errc_t
i	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   unsigned int i;$/;"	m	union:boost::re_detail::padding	access:public
i	/usr/include/boost/regex/v4/states.hpp	/^   std::ptrdiff_t    i;$/;"	m	union:boost::re_detail::offset_type	access:public
icase	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool icase;$/;"	m	class:boost::re_detail::perl_matcher	access:private
icase	/usr/include/boost/regex/v4/regbase.hpp	/^      icase = 1 << 20,                                  \/\/ characters are matched regardless of case$/;"	e	enum:boost::regbase::flag_type_
icase	/usr/include/boost/regex/v4/regbase.hpp	/^      icase = ::boost::regbase::icase,$/;"	e	enum:boost::regex_constants::flag_type_
icase	/usr/include/boost/regex/v4/states.hpp	/^   bool icase;$/;"	m	struct:boost::re_detail::re_brace	access:public
icase	/usr/include/boost/regex/v4/states.hpp	/^   bool icase;$/;"	m	struct:boost::re_detail::re_case	access:public
icase	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::icase;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
icase	/usr/include/boost/xpressive/regex_constants.hpp	/^    icase       = 1 << 1,   \/\/\/< Specifies that matching of regular expressions against a character$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
icase	/usr/include/boost/xpressive/regex_constants.hpp	21;"	d
icase	/usr/include/boost/xpressive/regex_constants.hpp	291;"	d
icase	/usr/include/boost/xpressive/regex_primitives.hpp	/^template<typename Expr> detail::unspecified icase(Expr const &expr) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Expr const &expr)
icu_regex_traits	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits()$/;"	f	class:boost::icu_regex_traits	access:public	signature:()
icu_regex_traits	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits(const icu_regex_traits&);$/;"	p	class:boost::icu_regex_traits	access:private	signature:(const icu_regex_traits&)
icu_regex_traits	/usr/include/boost/regex/icu.hpp	/^class BOOST_REGEX_DECL icu_regex_traits$/;"	c	namespace:boost
icu_regex_traits_implementation	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits_implementation(const U_NAMESPACE_QUALIFIER Locale& l)$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const U_NAMESPACE_QUALIFIER Locale& l)
icu_regex_traits_implementation	/usr/include/boost/regex/icu.hpp	/^class BOOST_REGEX_DECL icu_regex_traits_implementation$/;"	c	namespace:boost::re_detail
identifier_removed	/usr/include/boost/system/error_code.hpp	/^        identifier_removed = EIDRM,$/;"	e	enum:boost::system::errc::errc_t
idx	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   int idx;$/;"	m	struct:boost::re_detail::recursion_info	access:public
ifstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ifstream<char> ifstream;$/;"	t	namespace:boost::filesystem
ignore_unused_regex_actions	/usr/include/boost/xpressive/regex_actions.hpp	/^        inline void ignore_unused_regex_actions()$/;"	f	namespace:boost::xpressive::detail	signature:()
ignore_unused_regex_primitives	/usr/include/boost/xpressive/regex_primitives.hpp	/^    inline void ignore_unused_regex_primitives()$/;"	f	namespace:boost::xpressive::detail	signature:()
ignore_white_space	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ignore_white_space;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
ignore_white_space	/usr/include/boost/xpressive/regex_constants.hpp	/^    ignore_white_space  = 1 << 13   \/\/\/< Specifies that non-escaped white-space is not significant.$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
illegal_byte_sequence	/usr/include/boost/system/error_code.hpp	/^        illegal_byte_sequence = EILSEQ,$/;"	e	enum:boost::system::errc::errc_t
illuminance	/usr/include/boost/units/systems/si/illuminance.hpp	/^typedef unit<illuminance_dimension,si::system>      illuminance;$/;"	t	namespace:boost::units::si
imbue	/usr/include/boost/filesystem/path.hpp	/^    static std::locale  imbue(const std::locale& loc);$/;"	p	class:boost::filesystem::path	access:public	signature:(const std::locale& loc)
imbue	/usr/include/boost/regex/concepts.hpp	/^   locale_type imbue(locale_type l)$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(locale_type l)
imbue	/usr/include/boost/regex/icu.hpp	/^   locale_type imbue(locale_type l)$/;"	f	class:boost::icu_regex_traits	access:public	signature:(locale_type l)
imbue	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL imbue(locale_type l)$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(locale_type l)
imbue	/usr/include/boost/regex/v4/basic_regex.hpp	/^   locale_type BOOST_REGEX_CALL imbue(locale_type l);$/;"	p	class:boost::basic_regex	access:public	signature:(locale_type l)
imbue	/usr/include/boost/regex/v4/basic_regex.hpp	/^typename basic_regex<charT, traits>::locale_type BOOST_REGEX_CALL basic_regex<charT, traits>::imbue(locale_type l)$/;"	f	class:boost::basic_regex	signature:(locale_type l)
imbue	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   locale_type imbue(locale_type l)$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(locale_type l)
imbue	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::locale imbue(const std::locale& l);$/;"	p	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const std::locale& l)
imbue	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^std::locale cpp_regex_traits_base<charT>::imbue(const std::locale& l)$/;"	f	class:boost::re_detail::cpp_regex_traits_base	signature:(const std::locale& l)
imbue	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   locale_type imbue(locale_type l)$/;"	f	struct:boost::c_regex_traits	access:public	signature:(locale_type l)
imbue	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   lcid_type imbue(lcid_type l);$/;"	p	struct:boost::re_detail::w32_regex_traits_base	access:public	signature:(lcid_type l)
imbue	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   locale_type imbue(locale_type l)$/;"	f	class:boost::w32_regex_traits	access:public	signature:(locale_type l)
imbue	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^inline lcid_type w32_regex_traits_base<charT>::imbue(lcid_type l)$/;"	f	class:boost::re_detail::w32_regex_traits_base	signature:(lcid_type l)
imbue	/usr/include/boost/xpressive/regex_compiler.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(locale_type loc)
imbue	/usr/include/boost/xpressive/regex_primitives.hpp	/^imbue(Locale const &loc)$/;"	f	class:boost::xpressive::detail	signature:(Locale const &loc)
imbue	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &)
imbue	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &loc)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &loc)
imbue	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type loc)
imbue	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^        static void imbue(Traits const &)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &)
imbue	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^        void imbue(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &tr)
imbue	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type loc)
imbue	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type loc)
impedance	/usr/include/boost/units/systems/si/impedance.hpp	/^typedef unit<impedance_dimension,si::system>    impedance;$/;"	t	namespace:boost::units::si
impl	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef regex_iterator_implementation<BidirectionalIterator, charT, traits> impl;$/;"	t	class:boost::regex_iterator	access:private
impl	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef regex_token_iterator_implementation<BidirectionalIterator, charT, traits> impl;$/;"	t	class:boost::regex_token_iterator	access:private
impl	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef u32regex_iterator_implementation<BidirectionalIterator> impl;$/;"	t	class:boost::u32regex_iterator	access:private
impl	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef u32regex_token_iterator_implementation<BidirectionalIterator> impl;$/;"	t	class:boost::u32regex_token_iterator	access:private
impl	/usr/include/boost/xpressive/regex_primitives.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::skip_primitives	inherits:proto::transform_impl	access:public
impl_	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_impl<BidiIter> impl_;$/;"	m	struct:boost::xpressive::detail::regex_matcher	access:public
impl_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_iterator	access:private
impl_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_token_iterator	access:private
impl_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::impl_type  impl_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
impl_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::impl_type impl_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
impl_type_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef detail::regex_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
impl_type_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef detail::regex_token_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
in1	/usr/include/boost/regex/concepts.hpp	/^   input_iterator_type in1, in2;$/;"	m	struct:boost::BaseRegexConcept	access:public
in2	/usr/include/boost/regex/concepts.hpp	/^   input_iterator_type in1, in2;$/;"	m	struct:boost::BaseRegexConcept	access:public
inappropriate_io_control_operation	/usr/include/boost/system/error_code.hpp	/^        inappropriate_io_control_operation = ENOTTY,$/;"	e	enum:boost::system::errc::errc_t
increment	/usr/include/boost/filesystem/operations.hpp	/^      void increment(system::error_code* ec);  \/\/ ec == 0 means throw on error$/;"	p	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public	signature:(system::error_code* ec)
increment	/usr/include/boost/filesystem/operations.hpp	/^    directory_iterator& increment(system::error_code& ec)$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:(system::error_code& ec)
increment	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator& increment(system::error_code& ec)$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(system::error_code& ec)
increment	/usr/include/boost/filesystem/operations.hpp	/^    void increment() { detail::directory_iterator_increment(*this, 0); }$/;"	f	class:boost::filesystem::directory_iterator	access:private	signature:()
increment	/usr/include/boost/filesystem/operations.hpp	/^    void increment()$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:private	signature:()
increment	/usr/include/boost/filesystem/operations.hpp	/^    void recur_dir_itr_imp::increment(system::error_code* ec)$/;"	f	class:boost::filesystem::detail::recur_dir_itr_imp	signature:(system::error_code* ec)
increment	/usr/include/boost/filesystem/path.hpp	/^    void increment() { m_path_iterator_increment(*this); }$/;"	f	class:boost::filesystem::path::iterator	access:private	signature:()
increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:()
increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:()
increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:()
increment	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void increment()$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:()
index	/usr/include/boost/regex/pending/object_cache.hpp	/^      map_type    index;$/;"	m	struct:boost::object_cache::data	access:public
index	/usr/include/boost/regex/v4/basic_regex.hpp	/^      int index;$/;"	m	struct:boost::re_detail::named_subexpressions::name	access:public
index	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   int index;$/;"	m	struct:boost::re_detail::saved_matched_paren	access:public
index	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   int index;$/;"	m	class:boost::re_detail::backup_subex	access:private
index	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   size_type BOOST_REGEX_CALL index(void* ptr)$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:(void* ptr)
index	/usr/include/boost/regex/v4/states.hpp	/^   int index;$/;"	m	struct:boost::re_detail::re_brace	access:public
inductance	/usr/include/boost/units/systems/si/inductance.hpp	/^typedef unit<inductance_dimension,si::system>    inductance;$/;"	t	namespace:boost::units::si
inf	/usr/include/boost/xpressive/regex_primitives.hpp	/^unsigned int const inf = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
init	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void init(unsigned l_flags)$/;"	f	class:boost::re_detail::basic_regex_creator	access:public	signature:(unsigned l_flags)
init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::cpp_regex_traits_char_layer	access:private	signature:()
init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:()
init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:private	signature:()
init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^void cpp_regex_traits_char_layer<charT>::init()$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	signature:()
init	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^void cpp_regex_traits_implementation<charT>::init()$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:()
init	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:(BidirectionalIterator first)
init	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(BidirectionalIterator first)
init	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:(BidirectionalIterator first)
init	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool init(BidirectionalIterator first)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(BidirectionalIterator first)
init	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   void init();$/;"	p	class:boost::re_detail::w32_regex_traits_char_layer	access:private	signature:()
initial_max	/usr/include/boost/regex/v4/regex_split.hpp	/^   std::size_t initial_max;$/;"	m	class:boost::re_detail::split_pred	access:private
initial_path	/usr/include/boost/filesystem/operations.hpp	/^    path initial_path(system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(system::error_code* ec=0)
initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path()                  {return detail::initial_path();}$/;"	f	namespace:boost::filesystem	signature:()
initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path() {return initial_path();}$/;"	f	namespace:boost::filesystem	signature:()
initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path();$/;"	p	namespace:boost::filesystem	signature:()
initial_path	/usr/include/boost/filesystem/operations.hpp	/^  path initial_path(system::error_code& ec) {return detail::initial_path(&ec);}$/;"	f	namespace:boost::filesystem	signature:(system::error_code& ec)
initial_path	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path initial_path()$/;"	f	namespace:boost::wave::util	signature:()
init_error	/usr/include/boost/regex/icu.hpp	/^   void init_error()$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:private	signature:()
inplace_destroy	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void inplace_destroy(T* p)$/;"	f	namespace:boost::re_detail	signature:(T* p)
input_iterator_type	/usr/include/boost/regex/concepts.hpp	/^   typedef input_iterator_archetype<value_type> input_iterator_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
insert	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* BOOST_REGEX_CALL insert(size_type pos, size_type n);$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:(size_type pos, size_type n)
insert	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct insert$/;"	s	namespace:boost::xpressive::op
insert	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::insert>::type const insert = {{}};$/;"	m	class:boost::xpressive::function
insert_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base* insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base));$/;"	p	class:boost::re_detail::basic_regex_creator	access:public	signature:(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base))
insert_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^re_syntax_base* basic_regex_creator<charT, traits>::insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)
instances	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    static int instances;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
instances	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^int regex_impl<BidiIter>::instances = 0;$/;"	m	class:boost::xpressive::detail::regex_impl
interrupted	/usr/include/boost/system/error_code.hpp	/^        interrupted = EINTR,$/;"	e	enum:boost::system::errc::errc_t
int_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::int_type   int_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::int_type int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
int_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::int_type int_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
invalid_access	/usr/include/boost/system/windows_error.hpp	/^        invalid_access = ERROR_INVALID_ACCESS,$/;"	e	enum:boost::system::windows_error::windows_error_code
invalid_argument	/usr/include/boost/system/error_code.hpp	/^        invalid_argument = EINVAL,$/;"	e	enum:boost::system::errc::errc_t
invalid_block	/usr/include/boost/system/windows_error.hpp	/^        invalid_block = ERROR_INVALID_BLOCK,$/;"	e	enum:boost::system::windows_error::windows_error_code
invalid_code_point	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   static void invalid_code_point(::boost::uint16_t val)$/;"	f	class:boost::u16_to_u32_iterator	access:private	signature:(::boost::uint16_t val)
invalid_drive	/usr/include/boost/system/windows_error.hpp	/^        invalid_drive = ERROR_INVALID_DRIVE,$/;"	e	enum:boost::system::windows_error::windows_error_code
invalid_function	/usr/include/boost/system/windows_error.hpp	/^        invalid_function = ERROR_INVALID_FUNCTION,$/;"	e	enum:boost::system::windows_error::windows_error_code
invalid_handle	/usr/include/boost/system/windows_error.hpp	/^        invalid_handle = ERROR_INVALID_HANDLE,$/;"	e	enum:boost::system::windows_error::windows_error_code
invalid_seek	/usr/include/boost/system/error_code.hpp	/^        invalid_seek = ESPIPE,$/;"	e	enum:boost::system::errc::errc_t
invalid_sequence	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   static void invalid_sequence()$/;"	f	class:boost::u8_to_u32_iterator	access:private	signature:()
invalid_utf32_code_point	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline void invalid_utf32_code_point(::boost::uint32_t val)$/;"	f	namespace:boost::detail	signature:(::boost::uint32_t val)
inverse_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<dimensionless,amount>::type inverse_amount;$/;"	t	namespace:boost::units::si::constants::codata
in_range	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    bool in_range(char_type from, char_type to, char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type from, char_type to, char_type ch) const
in_range	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual bool in_range(Char from, Char to, Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char from, Char to, Char ch) const
in_range	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range_nocase	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool in_range_nocase(char_type first, char_type last, char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch) const
in_range_nocase	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range_nocase	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
iostreams	/usr/include/boost/iostreams/detail/system_failure.hpp	/^namespace boost { namespace iostreams { namespace detail {$/;"	n	namespace:boost
iostreams	/usr/include/boost/iostreams/filter/regex.hpp	/^namespace boost { namespace iostreams {$/;"	n	namespace:boost
io_error	/usr/include/boost/system/error_code.hpp	/^        io_error = EIO,$/;"	e	enum:boost::system::errc::errc_t
is	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        bool is(std::ctype<Char> const &, Char ch, umaskex_t mask) const$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &, Char ch, umaskex_t mask) const
is	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is(std::ctype<Char> const &ct, Char ch, umaskex_t mask)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &ct, Char ch, umaskex_t mask)
isctype	/usr/include/boost/regex/concepts.hpp	/^   bool isctype(charT, char_class_type) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT, char_class_type) const
isctype	/usr/include/boost/regex/icu.hpp	/^   bool isctype(char_type c, char_class_type f) const;$/;"	p	class:boost::icu_regex_traits	access:public	signature:(char_type c, char_class_type f) const
isctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool isctype(charT c, char_class_type f) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c, char_class_type f) const
isctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool isctype(charT c, char_class_type m)const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(charT c, char_class_type m) const
isctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^bool cpp_regex_traits_implementation<charT>::isctype(const charT c, char_class_type mask) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT c, char_class_type mask) const
isctype	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static bool BOOST_REGEX_CALL isctype(char, char_class_type);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(char, char_class_type)
isctype	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static bool BOOST_REGEX_CALL isctype(unsigned short, char_class_type);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(unsigned short, char_class_type)
isctype	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static bool BOOST_REGEX_CALL isctype(wchar_t, char_class_type);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(wchar_t, char_class_type)
isctype	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   bool isctype(boost::uint32_t mask, char c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(boost::uint32_t mask, char c) const
isctype	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   bool isctype(boost::uint32_t mask, charT c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(boost::uint32_t mask, charT c) const
isctype	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   bool isctype(charT c, char_class_type f) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c, char_class_type f) const
isctype	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool isctype(char_type ch, char_class_type mask) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, char_class_type mask) const
isctype	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
isctype	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
isnot	/usr/include/boost/regex/v4/states.hpp	/^   bool                    isnot;$/;"	m	struct:boost::re_detail::re_set_long	access:public
iswalnum	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswalnum)(wint_t i)$/;"	f	signature:(wint_t i)
iswalnum	/usr/include/boost/regex/config/cwchar.hpp	28;"	d
iswalnum	/usr/include/boost/regex/config/cwchar.hpp	58;"	d
iswalpha	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswalpha)(wint_t i)$/;"	f	signature:(wint_t i)
iswalpha	/usr/include/boost/regex/config/cwchar.hpp	29;"	d
iswalpha	/usr/include/boost/regex/config/cwchar.hpp	66;"	d
iswblank	/usr/include/boost/regex/config/cwchar.hpp	30;"	d
iswcntrl	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswcntrl)(wint_t i)$/;"	f	signature:(wint_t i)
iswcntrl	/usr/include/boost/regex/config/cwchar.hpp	31;"	d
iswcntrl	/usr/include/boost/regex/config/cwchar.hpp	74;"	d
iswctype	/usr/include/boost/regex/config/cwchar.hpp	41;"	d
iswdigit	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswdigit)(wint_t i)$/;"	f	signature:(wint_t i)
iswdigit	/usr/include/boost/regex/config/cwchar.hpp	32;"	d
iswdigit	/usr/include/boost/regex/config/cwchar.hpp	82;"	d
iswgraph	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswgraph)(wint_t i)$/;"	f	signature:(wint_t i)
iswgraph	/usr/include/boost/regex/config/cwchar.hpp	33;"	d
iswgraph	/usr/include/boost/regex/config/cwchar.hpp	90;"	d
iswlower	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswlower)(wint_t i)$/;"	f	signature:(wint_t i)
iswlower	/usr/include/boost/regex/config/cwchar.hpp	34;"	d
iswlower	/usr/include/boost/regex/config/cwchar.hpp	98;"	d
iswprint	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswprint)(wint_t i)$/;"	f	signature:(wint_t i)
iswprint	/usr/include/boost/regex/config/cwchar.hpp	106;"	d
iswprint	/usr/include/boost/regex/config/cwchar.hpp	35;"	d
iswprint	/usr/include/boost/regex/config/cwchar.hpp	36;"	d
iswpunct	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswpunct)(wint_t i)$/;"	f	signature:(wint_t i)
iswpunct	/usr/include/boost/regex/config/cwchar.hpp	114;"	d
iswpunct	/usr/include/boost/regex/config/cwchar.hpp	37;"	d
iswspace	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswspace)(wint_t i)$/;"	f	signature:(wint_t i)
iswspace	/usr/include/boost/regex/config/cwchar.hpp	122;"	d
iswspace	/usr/include/boost/regex/config/cwchar.hpp	38;"	d
iswupper	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswupper)(wint_t i)$/;"	f	signature:(wint_t i)
iswupper	/usr/include/boost/regex/config/cwchar.hpp	130;"	d
iswupper	/usr/include/boost/regex/config/cwchar.hpp	39;"	d
iswxdigit	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswxdigit)(wint_t i)$/;"	f	signature:(wint_t i)
iswxdigit	/usr/include/boost/regex/config/cwchar.hpp	138;"	d
iswxdigit	/usr/include/boost/regex/config/cwchar.hpp	40;"	d
is_absolute	/usr/include/boost/filesystem/path.hpp	/^    bool is_absolute() const$/;"	f	class:boost::filesystem::path	access:public	signature:() const
is_a_directory	/usr/include/boost/system/error_code.hpp	/^        is_a_directory = EISDIR,$/;"	e	enum:boost::system::errc::errc_t
is_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool is_bad_repeat(re_syntax_base* pt);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* pt)
is_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^bool basic_regex_creator<charT, traits>::is_bad_repeat(re_syntax_base* pt)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* pt)
is_blank	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_blank(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
is_byte	/usr/include/boost/regex/v4/states.hpp	/^template <class charT> struct is_byte               { typedef _wide_type width_type; };$/;"	s	namespace:boost::re_detail
is_byte	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<char>         { typedef _narrow_type width_type; };$/;"	s	namespace:boost::re_detail
is_byte	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<signed char>  { typedef _narrow_type width_type; };$/;"	s	namespace:boost::re_detail
is_byte	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<unsigned char>{ typedef _narrow_type width_type; };$/;"	s	namespace:boost::re_detail
is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<char>(char)$/;"	f	namespace:boost::re_detail	signature:(char)
is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<signed char>(signed char)$/;"	f	namespace:boost::re_detail	signature:(signed char)
is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<unsigned char>(unsigned char)$/;"	f	namespace:boost::re_detail	signature:(unsigned char)
is_combining	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_combining<wchar_t>(wchar_t c)$/;"	f	namespace:boost::re_detail	signature:(wchar_t c)
is_combining_implementation	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL is_combining_implementation(uint_least16_t s);$/;"	p	namespace:boost::re_detail	signature:(uint_least16_t s)
is_complete	/usr/include/boost/filesystem/path.hpp	/^    bool   is_complete() const      { return is_absolute(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
is_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool is_directory(const path& p)     {return is_directory(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
is_directory	/usr/include/boost/filesystem/operations.hpp	/^  bool is_directory(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
is_directory	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_directory(file_status f) { return f.type() == directory_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
is_empty	/usr/include/boost/filesystem/operations.hpp	/^    bool is_empty(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
is_empty	/usr/include/boost/filesystem/operations.hpp	/^  bool is_empty(const path& p)         {return detail::is_empty(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
is_empty	/usr/include/boost/filesystem/operations.hpp	/^  bool is_empty(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
is_empty_dim	/usr/include/boost/units/heterogeneous_system.hpp	/^struct is_empty_dim<heterogeneous_system_dim<Unit1,Exponent1> > : detail::is_zero<Exponent1> {};$/;"	s	namespace:boost::units::detail	inherits:detail::is_zero
is_equal	/usr/include/boost/date_time/time_system_counted.hpp	/^    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
is_equal	/usr/include/boost/date_time/time_system_split.hpp	/^    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
is_error_code_enum	/usr/include/boost/system/cygwin_error.hpp	/^    template<> struct is_error_code_enum<cygwin_error::cygwin_errno>$/;"	s	namespace:boost::system
is_error_code_enum	/usr/include/boost/system/error_code.hpp	/^    struct is_error_code_enum { static const bool value = false; };$/;"	s	namespace:boost::system
is_error_code_enum	/usr/include/boost/system/linux_error.hpp	/^    template<> struct is_error_code_enum<linux_error::linux_errno>$/;"	s	namespace:boost::system
is_error_code_enum	/usr/include/boost/system/windows_error.hpp	/^    template<> struct is_error_code_enum<windows_error::windows_error_code>$/;"	s	namespace:boost::system
is_error_condition_enum	/usr/include/boost/system/error_code.hpp	/^    struct is_error_condition_enum { static const bool value = false; };$/;"	s	namespace:boost::system
is_error_condition_enum	/usr/include/boost/system/error_code.hpp	/^    template<> struct is_error_condition_enum<errc::errc_t>$/;"	s	namespace:boost::system
is_extended	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_extended(char)$/;"	f	namespace:boost::re_detail	signature:(char)
is_extended	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_extended(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
is_high_surrogate	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline bool is_high_surrogate(::boost::uint16_t v)$/;"	f	namespace:boost::detail	signature:(::boost::uint16_t v)
is_less	/usr/include/boost/date_time/time_system_counted.hpp	/^    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
is_less	/usr/include/boost/date_time/time_system_split.hpp	/^    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
is_low_surrogate	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline bool is_low_surrogate(::boost::uint16_t v)$/;"	f	namespace:boost::detail	signature:(::boost::uint16_t v)
is_named_file_type	/usr/include/boost/system/linux_error.hpp	/^        is_named_file_type= EISNAM,$/;"	e	enum:boost::system::linux_error::linux_errno
is_negated	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool is_negated()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
is_neg_infinity	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_neg_infinity()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
is_newline	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_newline(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
is_not_a_date_time	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_not_a_date_time()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
is_other	/usr/include/boost/filesystem/operations.hpp	/^  bool is_other(const path& p)         {return is_other(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
is_other	/usr/include/boost/filesystem/operations.hpp	/^  bool is_other(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
is_other	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_other(file_status f)     { return exists(f) && !is_regular_file(f)$/;"	f	namespace:boost::filesystem	signature:(file_status f)
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  struct is_pathable { static const bool value = false; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<char*>                  { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const char*>            { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const wchar_t*>         { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<directory_entry>        { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<char> >       { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<wchar_t> >    { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::string>            { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<char> >     { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<wchar_t> >  { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::wstring>           { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pathable	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<wchar_t*>               { static const bool value = true; };$/;"	s	namespace:boost::filesystem::path_traits
is_pos_infinity	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_pos_infinity()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
is_quantity_of_system	/usr/include/boost/units/is_quantity_of_system.hpp	/^struct is_quantity_of_system :$/;"	s	namespace:boost::units	inherits:mpl::false_
is_quantity_of_system	/usr/include/boost/units/is_quantity_of_system.hpp	/^struct is_quantity_of_system< quantity< Unit,Y>,System > :$/;"	s	namespace:boost::units	inherits:is_unit_of_system
is_random_access_iterator	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_access_iterator$/;"	s	namespace:boost
is_random_imp	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_imp$/;"	s	namespace:boost::detail
is_random_imp_selector	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_imp_selector$/;"	s	namespace:boost::detail
is_random_imp_selector	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_imp_selector<true>$/;"	s	namespace:boost::detail
is_random_pointer_imp	/usr/include/boost/regex/v4/iterator_category.hpp	/^struct is_random_pointer_imp$/;"	s	namespace:boost::detail
is_regular	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular(const path& p)       {return is_regular(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
is_regular	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
is_regular	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_regular(file_status f)   { return f.type() == regular_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
is_regular_file	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular_file(const path& p)  {return is_regular_file(detail::status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
is_regular_file	/usr/include/boost/filesystem/operations.hpp	/^  bool is_regular_file(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
is_regular_file	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_regular_file(file_status f){ return f.type() == regular_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
is_relative	/usr/include/boost/filesystem/path.hpp	/^    bool is_relative() const         { return !is_absolute(); } $/;"	f	class:boost::filesystem::path	access:public	signature:() const
is_separator	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_separator(charT c)$/;"	f	namespace:boost::re_detail	signature:(charT c)
is_separator	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^inline bool is_separator<char>(char c)$/;"	f	namespace:boost::re_detail	signature:(char c)
is_special	/usr/include/boost/date_time/time_system_counted.hpp	/^    bool is_special()const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
is_steady	/usr/include/boost/chrono/system_clocks.hpp	/^      BOOST_STATIC_CONSTEXPR bool is_steady =             false;$/;"	m	class:boost::chrono::system_clock	access:public
is_steady	/usr/include/boost/chrono/system_clocks.hpp	/^      BOOST_STATIC_CONSTEXPR bool is_steady =             true;$/;"	m	class:boost::chrono::steady_clock	access:public
is_surrogate	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline bool is_surrogate(T v)$/;"	f	namespace:boost::detail	signature:(T v)
is_symlink	/usr/include/boost/filesystem/operations.hpp	/^  bool is_symlink(const path& p)       {return is_symlink(detail::symlink_status(p));}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
is_symlink	/usr/include/boost/filesystem/operations.hpp	/^  bool is_symlink(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
is_symlink	/usr/include/boost/filesystem/operations.hpp	/^  inline bool is_symlink(file_status f)   { return f.type() == symlink_file; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
is_underscore	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_underscore(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
is_unit_of_system	/usr/include/boost/units/is_unit_of_system.hpp	/^struct is_unit_of_system :$/;"	s	namespace:boost::units	inherits:mpl::false_
is_unit_of_system	/usr/include/boost/units/is_unit_of_system.hpp	/^struct is_unit_of_system< absolute<unit<Dim,System> >,System > :$/;"	s	namespace:boost::units	inherits:mpl::true_
is_unit_of_system	/usr/include/boost/units/is_unit_of_system.hpp	/^struct is_unit_of_system< unit<Dim,System>,System > :$/;"	s	namespace:boost::units	inherits:mpl::true_
is_upper_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    bool is_upper_(char_type ch) const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(char_type ch) const
is_zero	/usr/include/boost/units/heterogeneous_system.hpp	/^struct is_zero : mpl::false_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::false_
is_zero	/usr/include/boost/units/heterogeneous_system.hpp	/^struct is_zero<static_rational<0> > : mpl::true_ {};$/;"	s	namespace:boost::units::detail	inherits:mpl::true_
iterator	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::iterator iterator;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
iterator	/usr/include/boost/filesystem/path.hpp	/^  class path::iterator$/;"	c	class:boost::filesystem::path	inherits:boost::iterator_facade
iterator	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef const_iterator                        iterator;$/;"	t	class:boost::basic_regex	access:public
iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char* iterator;$/;"	t	class:boost::re_detail::mapfile	access:public
iterator	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          const_iterator                                          iterator;$/;"	t	class:boost::match_results	access:public
iterator	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename value_type::iterator iterator;$/;"	t	struct:boost::re_detail::recursion_info	access:public
iterator	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          BidiIterator                                                     iterator;$/;"	t	struct:boost::sub_match	access:public
iterator_category	/usr/include/boost/regex/icu.hpp	/^   typedef std::output_iterator_tag iterator_category;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
iterator_category	/usr/include/boost/regex/mfc.hpp	/^   typedef std::output_iterator_tag iterator_category;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
iterator_category	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef std::output_iterator_tag               iterator_category;$/;"	t	class:boost::utf16_output_iterator	access:public
iterator_category	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef std::output_iterator_tag               iterator_category;$/;"	t	class:boost::utf8_output_iterator	access:public
iterator_category	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::input_iterator_tag   iterator_category;$/;"	t	class:boost::re_detail::directory_iterator	access:public
iterator_category	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef std::input_iterator_tag   iterator_category;$/;"	t	class:boost::re_detail::file_iterator	access:public
iterator_category	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::random_access_iterator_tag iterator_category;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
iterator_category	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef std::random_access_iterator_tag iterator_category;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
iterator_category	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::iterator_category iterator_category;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
iterator_category	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef std::output_iterator_tag iterator_category;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
iterator_category	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::regex_iterator	access:public
iterator_category	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::regex_token_iterator	access:public
iterator_category	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::u32regex_iterator	access:public
iterator_category	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          std::forward_iterator_tag                               iterator_category;$/;"	t	class:boost::u32regex_token_iterator	access:public
iterator_category	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
iterator_category	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
iterator_type	/usr/include/boost/regex/v4/regex_split.hpp	/^   typedef typename string_type::const_iterator iterator_type;$/;"	t	class:boost::re_detail::split_pred	access:private
iterator_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef          BidiIterator                                                     iterator_type;$/;"	t	struct:boost::sub_match	access:public
iterator_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
iterator_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
iter_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_iterator_impl<BidiIter> iter_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
JavaScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JavaScript = normal,$/;"	e	enum:boost::regbase::flag_type_
JavaScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JavaScript = normal,$/;"	e	enum:boost::regex_constants::flag_type_
join_if	/usr/include/boost/algorithm/string/regex.hpp	/^        join_if($/;"	f	namespace:boost::algorithm	signature:( const SequenceSequenceT& Input, const Range1T& Separator, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
join_if_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        join_if_regex($/;"	f	namespace:boost::algorithm	signature:( const SequenceSequenceT& Input, const Range1T& Separator, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
JScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JScript = normal$/;"	e	enum:boost::regbase::flag_type_
JScript	/usr/include/boost/regex/v4/regbase.hpp	/^      JScript = normal$/;"	e	enum:boost::regex_constants::flag_type_
keep	/usr/include/boost/xpressive/regex_primitives.hpp	/^keep(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
key_expired	/usr/include/boost/system/linux_error.hpp	/^        key_expired = EKEYEXPIRED,$/;"	e	enum:boost::system::linux_error::linux_errno
key_rejected	/usr/include/boost/system/linux_error.hpp	/^        key_rejected = EKEYREJECTED,$/;"	e	enum:boost::system::linux_error::linux_errno
key_revoked	/usr/include/boost/system/linux_error.hpp	/^        key_revoked = EKEYREVOKED,$/;"	e	enum:boost::system::linux_error::linux_errno
kinematic_viscosity	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^typedef unit<kinematic_viscosity_dimension,cgs::system>     kinematic_viscosity;$/;"	t	namespace:boost::units::cgs
kinematic_viscosity	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	/^typedef unit<kinematic_viscosity_dimension,si::system>     kinematic_viscosity;$/;"	t	namespace:boost::units::si
last	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator last; $/;"	m	class:boost::re_detail::perl_matcher	access:private
last	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   pointer last, start, end;$/;"	m	class:boost::re_detail::raw_storage	access:private
last_position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   BidiIterator last_position;$/;"	m	struct:boost::re_detail::saved_single_repeat	access:public
last_write_time	/usr/include/boost/filesystem/operations.hpp	/^    std::time_t last_write_time(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
last_write_time	/usr/include/boost/filesystem/operations.hpp	/^    void last_write_time(const path& p, const std::time_t new_time,$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, const std::time_t new_time, system::error_code* ec=0)
last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  std::time_t last_write_time(const path& p) {return detail::last_write_time(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  std::time_t last_write_time(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  void last_write_time(const path& p, const std::time_t new_time)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const std::time_t new_time)
last_write_time	/usr/include/boost/filesystem/operations.hpp	/^  void last_write_time(const path& p, const std::time_t new_time, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, const std::time_t new_time, system::error_code& ec)
lcid_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^typedef ::boost::uint32_t lcid_type;   \/\/ placeholder for LCID.$/;"	t	namespace:boost::re_detail
leading	/usr/include/boost/regex/v4/states.hpp	/^   bool          leading;   \/\/ True if this repeat is at the start of the machine (lets us optimize some searches)$/;"	m	struct:boost::re_detail::re_repeat	access:public
leaf	/usr/include/boost/filesystem/path.hpp	/^    path   leaf() const             { return filename(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
leaf	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline std::string leaf(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
length	/usr/include/boost/regex/concepts.hpp	/^   static std::size_t length(const char_type* ) { return 0; }$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(const char_type* )
length	/usr/include/boost/regex/icu.hpp	/^   static size_type length(const char_type* p);$/;"	p	class:boost::icu_regex_traits	access:public	signature:(const char_type* p)
length	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   static size_type length(const char_type* p)$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const char_type* p)
Length	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Length(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
length	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static size_type length(const char_type* p) $/;"	f	struct:boost::c_regex_traits	access:public	signature:(const char_type* p)
length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(const charT* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* sub) const
length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(const char_type* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* sub) const
length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(const std::basic_string<charT, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& sub) const
length	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type length(int sub = 0) const$/;"	f	class:boost::match_results	access:public	signature:(int sub = 0) const
length	/usr/include/boost/regex/v4/regex_format.hpp	/^   static std::ptrdiff_t length(const charT* p)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(const charT* p)
length	/usr/include/boost/regex/v4/states.hpp	/^   unsigned int length;$/;"	m	struct:boost::re_detail::re_literal	access:public
length	/usr/include/boost/regex/v4/sub_match.hpp	/^   difference_type BOOST_REGEX_CALL length()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
length	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   static size_type length(const char_type* p)$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const char_type* p)
length	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<length_dimension,system>                length;                 \/\/\/< abstract unit of length$/;"	t	namespace:boost::units::abstract
length	/usr/include/boost/units/systems/cgs/length.hpp	/^typedef unit<length_dimension,cgs::system>   length;$/;"	t	namespace:boost::units::cgs
length	/usr/include/boost/units/systems/si/length.hpp	/^typedef unit<length_dimension,si::system>    length;$/;"	t	namespace:boost::units::si
length	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct length$/;"	s	namespace:boost::xpressive::op
length	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::length>::type const length = {{}};$/;"	m	class:boost::xpressive::function
length_temperature	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef multiply_typeof_helper<length,temperature>::type length_temperature;$/;"	t	namespace:boost::units::si::constants::codata
length_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct length_unit_tag : base_unit<length_unit_tag, length_dimension, -30> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
less_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct less_impl<boost::units::heterogeneous_system_dim_tag, boost::units::heterogeneous_system_dim_tag>$/;"	s	namespace:boost::mpl
let	/usr/include/boost/xpressive/regex_actions.hpp	/^    detail::let_<proto::terminal<detail::let_tag>::type> const let = {{{}}};$/;"	m	class:boost::xpressive::detail
let_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct let_$/;"	s	namespace:boost::xpressive::detail
let_domain	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct let_domain$/;"	s	namespace:boost::xpressive::detail	inherits:boost::proto::domain
let_tag	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct let_tag$/;"	s	namespace:boost::xpressive::detail
level	/usr/include/boost/filesystem/operations.hpp	/^    int level() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
level2_halt	/usr/include/boost/system/linux_error.hpp	/^        level2_halt= EL2HLT,$/;"	e	enum:boost::system::linux_error::linux_errno
level2_no_syncronized	/usr/include/boost/system/linux_error.hpp	/^        level2_no_syncronized= EL2NSYNC,$/;"	e	enum:boost::system::linux_error::linux_errno
level3_halt	/usr/include/boost/system/linux_error.hpp	/^        level3_halt = EL3HLT,$/;"	e	enum:boost::system::linux_error::linux_errno
level3_reset	/usr/include/boost/system/linux_error.hpp	/^        level3_reset = EL3RST,$/;"	e	enum:boost::system::linux_error::linux_errno
lexicographical_compare	/usr/include/boost/filesystem/path.hpp	/^  inline bool lexicographical_compare(path::iterator first1, path::iterator last1,$/;"	f	namespace:boost::filesystem	signature:(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2)
lex_compare	/usr/include/boost/filesystem/path.hpp	/^      int lex_compare(path::iterator first1, path::iterator last1,$/;"	p	namespace:boost::filesystem::detail	signature:(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2)
link_range	/usr/include/boost/system/linux_error.hpp	/^        link_range = ELNRNG,$/;"	e	enum:boost::system::linux_error::linux_errno
linux_errno	/usr/include/boost/system/linux_error.hpp	/^      enum linux_errno$/;"	g	namespace:boost::system::linux_error
linux_error	/usr/include/boost/system/linux_error.hpp	/^    namespace linux_error$/;"	n	namespace:boost::system
list_iterator	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef typename list_type::iterator list_iterator;$/;"	t	class:boost::object_cache	access:public
list_iterator	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef typename std::vector<digraph_type>::const_iterator  list_iterator;$/;"	t	class:boost::re_detail::basic_char_set	access:public
list_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef std::list<value_type> list_type;$/;"	t	class:boost::object_cache	access:public
literal	/usr/include/boost/regex/v4/regbase.hpp	/^      literal = 2,                                \/\/ all characters are literals$/;"	e	enum:boost::regbase::flag_type_
literal	/usr/include/boost/regex/v4/regbase.hpp	/^      literal = ::boost::regbase::literal,$/;"	e	enum:boost::regex_constants::flag_type_
local	/usr/include/boost/xpressive/regex_actions.hpp	/^        explicit local(T const &t)$/;"	f	struct:boost::xpressive::local	access:public	signature:(T const &t)
local	/usr/include/boost/xpressive/regex_actions.hpp	/^        local()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
local	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct local$/;"	s	namespace:boost::xpressive	inherits:detail::value_wrapper,proto::terminal::type
locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef copy_constructible_archetype<assignable_archetype<> > locale_type;$/;"	t	struct:boost::regex_traits_architype	access:public
locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::locale_type locale_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::locale_type locale_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::locale_type locale_type;$/;"	t	struct:boost::RegexConcept	access:public
locale_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::locale_type locale_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
locale_type	/usr/include/boost/regex/icu.hpp	/^   typedef U_NAMESPACE_QUALIFIER Locale locale_type;$/;"	t	class:boost::icu_regex_traits	access:public
locale_type	/usr/include/boost/regex/icu.hpp	/^   typedef U_NAMESPACE_QUALIFIER Locale locale_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
locale_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename traits::locale_type          locale_type;$/;"	t	class:boost::basic_regex	access:public
locale_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename traits::locale_type          locale_type;$/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
locale_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::locale                  locale_type;$/;"	t	class:boost::cpp_regex_traits	access:public
locale_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   struct locale_type{};$/;"	s	struct:boost::c_regex_traits	access:public
locale_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef ::boost::re_detail::lcid_type locale_type;$/;"	t	class:boost::w32_regex_traits	access:public
locale_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename traits_type::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
locale_type	/usr/include/boost/xpressive/regex_traits.hpp	/^    typedef typename Impl::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_traits	access:public
locale_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::locale locale_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
locale_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef detail::empty_locale locale_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
locale_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef detail::not_a_locale locale_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   void lock();$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:()
locked	/usr/include/boost/regex/pending/static_mutex.hpp	/^   inline bool locked()const$/;"	f	class:boost::scoped_static_mutex_lock	access:public	signature:() const
lock_failed	/usr/include/boost/system/windows_error.hpp	/^        lock_failed = ERROR_LOCK_FAILED,$/;"	e	enum:boost::system::windows_error::windows_error_code
lock_violation	/usr/include/boost/system/windows_error.hpp	/^        lock_violation = ERROR_LOCK_VIOLATION,$/;"	e	enum:boost::system::windows_error::windows_error_code
loc_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    locale_type loc_;$/;"	m	struct:boost::xpressive::cpp_regex_traits	access:private
lookup_classname	/usr/include/boost/regex/concepts.hpp	/^   char_class_type lookup_classname(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
lookup_classname	/usr/include/boost/regex/icu.hpp	/^   char_class_type lookup_classname(const char_type* p1, const char_type* p2) const;$/;"	p	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
lookup_classname	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
lookup_classname	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
lookup_classname	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static char_class_type BOOST_REGEX_CALL lookup_classname(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
lookup_classname	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static char_class_type BOOST_REGEX_CALL lookup_classname(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
lookup_classname	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static char_class_type BOOST_REGEX_CALL lookup_classname(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
lookup_classname	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
lookup_classname	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char_class_type lookup_classname(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
lookup_classname	/usr/include/boost/xpressive/regex_traits.hpp	/^lookup_classname(Traits const &traits, char const (&cname)[N], bool icase)$/;"	f	namespace:boost::xpressive	signature:(Traits const &traits, char const (&cname)[N], bool icase)
lookup_classname	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase) const
lookup_classname	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
lookup_classname	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
lookup_classname_imp	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:private	signature:(const charT* p1, const charT* p2) const
lookup_classname_imp	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
lookup_classname_imp	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:private	signature:(const charT* p1, const charT* p2) const
lookup_classname_imp	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
lookup_classname_impl_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_type lookup_classname_impl_(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(FwdIter begin, FwdIter end)
lookup_collatename	/usr/include/boost/regex/concepts.hpp	/^   string_type lookup_collatename(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
lookup_collatename	/usr/include/boost/regex/icu.hpp	/^   string_type lookup_collatename(const char_type* p1, const char_type* p2) const;$/;"	p	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
lookup_collatename	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
lookup_collatename	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
lookup_collatename	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
lookup_collatename	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL lookup_collatename(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
lookup_collatename	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL lookup_collatename(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
lookup_collatename	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL lookup_collatename(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
lookup_collatename	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
lookup_collatename	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type lookup_collatename(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
lookup_collatename	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
lookup_collatename	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type lookup_collatename(FwdIter begin, FwdIter end) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end) const
lookup_collatename	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
lookup_collatename	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
lookup_default_collate_name	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^BOOST_REGEX_DECL std::string BOOST_REGEX_CALL lookup_default_collate_name(const std::string& name);$/;"	p	namespace:boost::re_detail	signature:(const std::string& name)
lookup_icu_mask	/usr/include/boost/regex/icu.hpp	/^   static char_class_type lookup_icu_mask(const ::UChar32* p1, const ::UChar32* p2);$/;"	p	class:boost::icu_regex_traits	access:private	signature:(const ::UChar32* p1, const ::UChar32* p2)
lower	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const lower = {{"lower", false}};$/;"	m	class:boost::xpressive::proto::terminal
lower_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type lower_bound() const { return Base().lower_bound(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
lower_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type lower_bound() const { return Base().lower_bound(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
low_surrogate_base	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^static const ::boost::uint16_t low_surrogate_base = 0xDC00u;$/;"	m	namespace:boost::detail
luminous_flux	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^typedef unit<luminous_flux_dimension,si::system>      luminous_flux;$/;"	t	namespace:boost::units::si
luminous_intensity	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<luminous_intensity_dimension,system>    luminous_intensity;     \/\/\/< abstract unit of luminous intensity$/;"	t	namespace:boost::units::abstract
luminous_intensity	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^typedef unit<luminous_intensity_dimension,si::system>      luminous_intensity;$/;"	t	namespace:boost::units::si
luminous_intensity_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct luminous_intensity_unit_tag : base_unit<luminous_intensity_unit_tag, luminous_intensity_dimension, -24> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
m	/usr/include/boost/regex/v4/regex_format.hpp	/^   static M m;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
magnetic_field_intensity	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	/^typedef unit<magnetic_field_intensity_dimension,si::system>    magnetic_field_intensity;$/;"	t	namespace:boost::units::si
magnetic_flux	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^typedef unit<magnetic_flux_dimension,si::system>    magnetic_flux;$/;"	t	namespace:boost::units::si
magnetic_flux_density	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^typedef unit<magnetic_flux_density_dimension,si::system>    magnetic_flux_density;$/;"	t	namespace:boost::units::si
main_option_type	/usr/include/boost/regex/v4/regbase.hpp	/^      main_option_type = literal | basic_syntax_group | perl_syntax_group, \/\/ everything!$/;"	e	enum:boost::regbase::flag_type_
make_error_code	/usr/include/boost/system/cygwin_error.hpp	/^      inline error_code make_error_code( cygwin_errno e )$/;"	f	namespace:boost::system::cygwin_error	signature:( cygwin_errno e )
make_error_code	/usr/include/boost/system/error_code.hpp	/^      inline error_code make_error_code( errc_t e )$/;"	f	namespace:boost::system::errc	signature:( errc_t e )
make_error_code	/usr/include/boost/system/linux_error.hpp	/^      inline error_code make_error_code( linux_errno e )$/;"	f	namespace:boost::system::linux_error	signature:( linux_errno e )
make_error_code	/usr/include/boost/system/windows_error.hpp	/^      inline error_code make_error_code( windows_error_code e )$/;"	f	namespace:boost::system::windows_error	signature:( windows_error_code e )
make_error_condition	/usr/include/boost/system/error_code.hpp	/^      inline error_condition make_error_condition( errc_t e )$/;"	f	namespace:boost::system::errc	signature:( errc_t e )
make_function	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef boost::proto::functional::make_expr<proto::tag::function, proto::default_domain> make_function;$/;"	t	namespace:boost::xpressive::detail
make_heterogeneous_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system$/;"	s	namespace:boost::units::detail
make_heterogeneous_system	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system<Dimensions, heterogeneous_system<T> >$/;"	s	namespace:boost::units::detail
make_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system_impl$/;"	s	namespace:boost::units::detail
make_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct make_heterogeneous_system_impl<0>$/;"	s	namespace:boost::units::detail
make_pair	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct make_pair$/;"	s	namespace:boost::xpressive::op
make_pair	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::make_pair>::type const make_pair = {{}};$/;"	m	class:boost::xpressive::function
make_preferred	/usr/include/boost/filesystem/path.hpp	/^    path&  make_preferred()$/;"	f	class:boost::filesystem::path	access:public	signature:()
make_regex	/usr/include/boost/regex/mfc.hpp	/^make_regex(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, ::boost::regex_constants::syntax_option_type f = boost::regex_constants::normal)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, ::boost::regex_constants::syntax_option_type f = boost::regex_constants::normal)
make_regex_iterator	/usr/include/boost/regex/mfc.hpp	/^make_regex_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
make_regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^inline regex_iterator<const charT*, charT, traits> make_regex_iterator(const charT* p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)
make_regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^inline regex_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^   make_regex_token_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, int sub = 0, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, int sub = 0, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^make_regex_token_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const int (& subs)[N], ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const int (& subs)[N], ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^make_regex_token_iterator(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const std::vector<int>& subs, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B>& e, const std::vector<int>& subs, ::boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const charT* p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
make_regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
make_system	/usr/include/boost/units/make_system.hpp	/^struct make_system$/;"	s	namespace:boost::units
make_tag	/usr/include/boost/xpressive/regex_primitives.hpp	/^    static detail::basic_mark_tag make_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:private	signature:(int mark_nbr)
make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const std::basic_string<C, T, A>& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const std::basic_string<C, T, A>& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const UChar* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const UChar* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const unsigned char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const unsigned char* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const U_NAMESPACE_QUALIFIER UnicodeString& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(const wchar_t* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)$/;"	f	namespace:boost	signature:(const wchar_t* p, boost::regex_constants::syntax_option_type opt = boost::regex_constants::perl)
make_u32regex	/usr/include/boost/regex/icu.hpp	/^inline u32regex make_u32regex(InputIterator i, $/;"	f	namespace:boost	signature:(InputIterator i, InputIterator j, boost::regex_constants::syntax_option_type opt)
make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const char*> make_u32regex_iterator(const char* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const UChar*> make_u32regex_iterator(const UChar* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const UChar*> make_u32regex_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<const wchar_t*> make_u32regex_iterator(const wchar_t* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^inline u32regex_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
make_u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)$/;"	f	namespace:boost	signature:(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
make_utf32_out	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator make_utf32_out(OutputIterator o, mpl::int_<4> const*)$/;"	f	namespace:boost::re_detail	signature:(OutputIterator o, mpl::int_<4> const*)
make_utf32_out	/usr/include/boost/regex/icu.hpp	/^inline utf16_output_iterator<OutputIterator> make_utf32_out(OutputIterator o, mpl::int_<2> const*)$/;"	f	namespace:boost::re_detail	signature:(OutputIterator o, mpl::int_<2> const*)
make_utf32_out	/usr/include/boost/regex/icu.hpp	/^inline utf8_output_iterator<OutputIterator> make_utf32_out(OutputIterator o, mpl::int_<1> const*)$/;"	f	namespace:boost::re_detail	signature:(OutputIterator o, mpl::int_<1> const*)
make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(const charT* p, mpl::int_<1> const*)$/;"	f	namespace:boost::re_detail	signature:(const charT* p, mpl::int_<1> const*)
make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(const charT* p, mpl::int_<2> const*)$/;"	f	namespace:boost::re_detail	signature:(const charT* p, mpl::int_<2> const*)
make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(const charT* p, mpl::int_<4> const*)$/;"	f	namespace:boost::re_detail	signature:(const charT* p, mpl::int_<4> const*)
make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(I i, I j, mpl::int_<1> const*)$/;"	f	namespace:boost::re_detail	signature:(I i, I j, mpl::int_<1> const*)
make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(I i, I j, mpl::int_<2> const*)$/;"	f	namespace:boost::re_detail	signature:(I i, I j, mpl::int_<2> const*)
make_utf32_seq	/usr/include/boost/regex/icu.hpp	/^   make_utf32_seq(I i, I j, mpl::int_<4> const*)$/;"	f	namespace:boost::re_detail	signature:(I i, I j, mpl::int_<4> const*)
mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   mapfile(){ hfile = hmap = 0; _first = _last = 0; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   mapfile(const char* file){ hfile = hmap = 0; _first = _last = 0; open(file); }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:(const char* file)
mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^class BOOST_REGEX_DECL mapfile$/;"	c	namespace:boost::re_detail
map_iterator	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef typename map_type::iterator map_iterator;$/;"	t	class:boost::object_cache	access:public
map_iterator_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename map_type::const_iterator map_iterator_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
map_iterator_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef typename map_type::const_iterator map_iterator_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
map_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef std::map<Key, list_iterator> map_type;$/;"	t	class:boost::object_cache	access:public
map_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::map<charT, regex_constants::syntax_type> map_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
map_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::map<charT, regex_constants::syntax_type> map_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
Marks	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Marks()const;$/;"	p	class:boost::RegEx	access:public	signature:() const
mark_count	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL mark_count()const $/;"	f	class:boost::basic_regex	access:public	signature:() const
mark_count	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL mark_count()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
mark_count	/usr/include/boost/xpressive/basic_regex.hpp	/^    std::size_t mark_count() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
mark_count_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
mark_count_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
mark_nbr	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct mark_nbr$/;"	s	namespace:boost::xpressive::detail
mark_nbr_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_nbr_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
mark_number	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct mark_number : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
mark_number	/usr/include/boost/xpressive/regex_primitives.hpp	100;"	d
mark_number	/usr/include/boost/xpressive/regex_primitives.hpp	46;"	d
mark_tag	/usr/include/boost/xpressive/regex_primitives.hpp	/^    mark_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:(int mark_nbr)
mark_tag	/usr/include/boost/xpressive/regex_primitives.hpp	/^struct mark_tag$/;"	s	namespace:boost::xpressive	inherits:proto::extends
mask	/usr/include/boost/regex/v4/states.hpp	/^   unsigned char mask;$/;"	m	struct:boost::re_detail::re_dot	access:public
masks_	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^        umaskex_t masks_[UCHAR_MAX + 1];$/;"	m	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private
mask_all	/usr/include/boost/regex/v4/states.hpp	/^   mask_all = mask_any$/;"	e	enum:boost::re_detail::mask_type
mask_any	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_any;$/;"	m	class:boost::icu_regex_traits	access:private
mask_any	/usr/include/boost/regex/v4/states.hpp	/^   mask_any = mask_skip | mask_take,$/;"	e	enum:boost::re_detail::mask_type
mask_ascii	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_ascii;$/;"	m	class:boost::icu_regex_traits	access:private
mask_blank	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_blank;$/;"	m	class:boost::icu_regex_traits	access:private
mask_blank	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_blank;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
mask_cast	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast$/;"	s	namespace:boost::xpressive::detail
mask_cast	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast<std::ctype_base::print>$/;"	s	namespace:boost::xpressive::detail
mask_horizontal	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_horizontal;$/;"	m	class:boost::icu_regex_traits	access:private
mask_horizontal	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_horizontal;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
mask_init	/usr/include/boost/regex/v4/states.hpp	/^   mask_init = 4,$/;"	e	enum:boost::re_detail::mask_type
mask_skip	/usr/include/boost/regex/v4/states.hpp	/^   mask_skip = 2,$/;"	e	enum:boost::re_detail::mask_type
mask_space	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_space;$/;"	m	class:boost::icu_regex_traits	access:private
mask_take	/usr/include/boost/regex/v4/states.hpp	/^   mask_take = 1,$/;"	e	enum:boost::re_detail::mask_type
mask_type	/usr/include/boost/regex/v4/states.hpp	/^enum mask_type$/;"	g	namespace:boost::re_detail
mask_underscore	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_underscore;$/;"	m	class:boost::icu_regex_traits	access:private
mask_unicode	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_unicode;$/;"	m	class:boost::icu_regex_traits	access:private
mask_unicode	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_unicode;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
mask_vertical	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_vertical;$/;"	m	class:boost::icu_regex_traits	access:private
mask_vertical	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_vertical;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
mask_word	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_word;$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation::cpp_regex_traits_implementation
mask_xdigit	/usr/include/boost/regex/icu.hpp	/^   static const char_class_type mask_xdigit;$/;"	m	class:boost::icu_regex_traits	access:private
mass	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<mass_dimension,system>                  mass;                   \/\/\/< abstract unit of mass$/;"	t	namespace:boost::units::abstract
mass	/usr/include/boost/units/systems/cgs/mass.hpp	/^typedef unit<mass_dimension,cgs::system>     mass;$/;"	t	namespace:boost::units::cgs
mass	/usr/include/boost/units/systems/si/mass.hpp	/^typedef unit<mass_dimension,si::system>      mass;$/;"	t	namespace:boost::units::si
mass_density	/usr/include/boost/units/systems/cgs/mass_density.hpp	/^typedef unit<mass_density_dimension,cgs::system>     mass_density;$/;"	t	namespace:boost::units::cgs
mass_density	/usr/include/boost/units/systems/si/mass_density.hpp	/^typedef unit<mass_density_dimension,si::system>  mass_density;$/;"	t	namespace:boost::units::si
mass_over_amount	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<mass,amount>::type mass_over_amount;$/;"	t	namespace:boost::units::si::constants::codata
mass_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct mass_unit_tag : base_unit<mass_unit_tag, mass_dimension, -29> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
Match	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Match(const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p, match_flag_type flags = match_default)
Match	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Match(const std::string& s, match_flag_type flags = match_default) { return Match(s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s, match_flag_type flags = match_default)
match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match();$/;"	p	class:boost::re_detail::perl_matcher	access:public	signature:()
match	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::match()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
Matched	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Matched(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
matched	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool matched;$/;"	m	struct:boost::sub_match	access:public
matched	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct matched$/;"	s	namespace:boost::xpressive::op
matched	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::matched>::type const matched = {{}};$/;"	m	class:boost::xpressive::function
matcher_proc_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef bool (self_type::*matcher_proc_type)(void);$/;"	t	class:boost::re_detail::perl_matcher	access:public
match_	/usr/include/boost/xpressive/basic_regex.hpp	/^    bool match_(detail::match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(detail::match_state<BidiIter> &state) const
match_all	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_all = match_stop << 1,                      \/* must find the whole of input even if match_any is set *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_all_states	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_all_states();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_all_states	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_all_states()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_all_states	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_all_states()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_alt();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_alt	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_alt()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_alt	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_alt()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_any	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_any = match_init << 1,                      \/* don't care what we match *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_any	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_any               = 1 << 7,   \/\/\/< Specifies that if more than one match is possible then$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_any_mask	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   unsigned char match_any_mask;$/;"	m	class:boost::re_detail::perl_matcher	access:private
match_assert_backref	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_assert_backref();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_assert_backref	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::match_assert_backref()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_backref	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_backref();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_backref	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_backref()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_backstep	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_backstep();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_backstep	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_backstep()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_buffer_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_buffer_end();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_buffer_end	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_buffer_end()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_buffer_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_buffer_start();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_buffer_start	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_buffer_start()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_char_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_char_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_char_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_char_repeat	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_combining	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_combining();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_combining	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_combining()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_continuous	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_continuous = match_not_null << 1,           \/* each grep match must continue from *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_continuous	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_continuous        = 1 << 10,  \/\/\/< Specifies that the expression must match a sub-sequence$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_default	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_default = 0,$/;"	e	enum:boost::regex_constants::_match_flags
match_default	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_default           = 0,        \/\/\/< Specifies that matching of regular expressions proceeds$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_dot_repeat_dispatch	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_dot_repeat_dispatch()$/;"	f	class:boost::re_detail::perl_matcher	access:private	signature:()
match_dot_repeat_fast	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_dot_repeat_fast();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_dot_repeat_fast	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_dot_repeat_fast	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_dot_repeat_slow	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_dot_repeat_slow();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_dot_repeat_slow	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_dot_repeat_slow	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_endmark	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_endmark();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_endmark	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_endmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_endmark	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_endmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_end_line	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_end_line();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_end_line	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_end_line()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_extra	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_extra = match_nosubs << 1,                  \/* include full capture information for repeated captures *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_flags	/usr/include/boost/regex/v4/match_flags.hpp	/^} match_flags;$/;"	t	namespace:boost::regex_constants	typeref:enum:boost::regex_constants::_match_flags
match_flag_type	/usr/include/boost/regex/v4/match_flags.hpp	/^typedef match_flags match_flag_type;$/;"	t	namespace:boost::regex_constants
match_flag_type	/usr/include/boost/regex/v4/match_flags.hpp	/^typedef unsigned long match_flag_type;$/;"	t	namespace:boost::regex_constants
match_flag_type	/usr/include/boost/xpressive/regex_constants.hpp	/^enum match_flag_type$/;"	g	namespace:boost::xpressive::regex_constants
match_imp	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_imp();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_imp	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_imp()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_init	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_init = match_prev_avail << 1,               \/* internal use *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_jump	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_jump();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_jump	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_jump()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_literal	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_literal();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_literal	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_literal()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_long_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_long_set();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_long_set	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_long_set_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_match();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_match	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_match()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_match	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_match()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_max	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_max = match_unused3,$/;"	e	enum:boost::regex_constants::_match_flags
match_nosubs	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_nosubs = match_posix << 1,                  \/* don't trap marked subs *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_bob	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_bob = match_not_eol << 1,               \/* first is not start of buffer *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_bol	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_bol = 1,                                \/* first is not start of line *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_bol	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_bol           = 1 << 1,   \/\/\/< Specifies that the expression "^" should not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_bow	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_bow = match_not_eob << 1,               \/* first is not start of word *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_bow	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_bow           = 1 << 3,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_dot_newline	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_dot_newline = match_not_eow << 1,       \/* \\n is not matched by '.' *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_dot_null	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_dot_null = match_not_dot_newline << 1,  \/* '\\0' is not matched by '.' *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_eob	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_eob = match_not_bob << 1,               \/* last is not end of buffer *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_eol	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_eol = match_not_bol << 1,               \/* last is not end of line *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_eol	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_eol           = 1 << 2,   \/\/\/< Specifies that the expression "\\$" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_eow	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_eow = match_not_bow << 1,               \/* last is not end of word *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_eow	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_eow           = 1 << 4,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_initial_null	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_initial_null = match_stop,              \/* don't match initial null, V4 only *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_null	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_not_null = match_any << 1,                  \/* string can't be null *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_not_null	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_not_null          = 1 << 8,   \/\/\/< Specifies that the expression can not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_partial	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_partial = match_continuous << 1,            \/* find partial matches *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_partial	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_partial           = 1 << 11,  \/\/\/< Specifies that if no match can be found, then it is$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_perl	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_perl = match_all << 1,                      \/* Use perl matching rules *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_posix	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_posix = match_perl << 1,                    \/* Use POSIX matching rules *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_prefix	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_prefix();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_prefix	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_prefix()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_prev_avail	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_prev_avail = match_not_dot_null << 1,       \/* *--first is a valid expression *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_prev_avail	/usr/include/boost/xpressive/regex_constants.hpp	/^    match_prev_avail        = 1 << 12,  \/\/\/< Specifies that --first is a valid iterator position,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_recursion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_recursion();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_recursion()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_recursion	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_recursion()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_rep	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_rep();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_rep	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_rep()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_rep	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_rep()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_restart_continue	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_restart_continue();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_restart_continue	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_restart_continue()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_results	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                const match_results_type& match_results() const$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:() const
match_results	/usr/include/boost/regex/v4/instances.hpp	/^template class BOOST_REGEX_DECL match_results< const BOOST_REGEX_CHAR_T* >;$/;"	m	namespace:boost	typeref:class:boost::BOOST_REGEX_DECL
match_results	/usr/include/boost/regex/v4/match_results.hpp	/^   explicit match_results(const Allocator& a = Allocator())$/;"	f	class:boost::match_results	access:public	signature:(const Allocator& a = Allocator())
match_results	/usr/include/boost/regex/v4/match_results.hpp	/^   match_results(const match_results& m)$/;"	f	class:boost::match_results	access:public	signature:(const match_results& m)
match_results	/usr/include/boost/regex/v4/match_results.hpp	/^class match_results$/;"	c	namespace:boost
match_results_default_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
match_results_default_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
match_results_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef boost::match_results<iterator> match_results_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
match_results_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
match_results_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
match_results_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;$/;"	t	struct:boost::RegexConcept	access:public
match_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_set();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_set	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_set()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_set_repeat();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_set_repeat	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_single_line	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_single_line = match_extra << 1,             \/* treat text as single line and ignor any \\n's when matching ^ and $. *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_soft_buffer_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_soft_buffer_end();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_soft_buffer_end	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_soft_buffer_end()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_startmark	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_startmark();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_startmark	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_startmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_startmark	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_startmark()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_start_line	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_start_line();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_start_line	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_start_line()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_stop	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_stop = match_partial << 1,                  \/* stop after first match (grep) V3 only *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_toggle_case	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_toggle_case();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_toggle_case	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef match_results<const Ch*>                   match_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
match_unused1	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_unused1 = match_single_line << 1,           \/* unused *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_unused2	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_unused2 = match_unused1 << 1,               \/* unused *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_unused3	/usr/include/boost/regex/v4/match_flags.hpp	/^   match_unused3 = match_unused2 << 1,               \/* unused *\/$/;"	e	enum:boost::regex_constants::_match_flags
match_wild	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_wild();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_wild	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_wild()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_within_word	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_within_word();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_within_word	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_within_word()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_word_boundary	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_word_boundary();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_word_boundary	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_word_boundary()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_word_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_word_end();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_word_end	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_word_end()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
match_word_start	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool match_word_start();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
match_word_start	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::match_word_start()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
max	/usr/include/boost/regex/v4/states.hpp	/^   std::size_t   min, max;  \/\/ min and max allowable repeats$/;"	m	struct:boost::re_detail::re_repeat	access:public
max_size	/usr/include/boost/regex/concepts.hpp	/^   size_type max_size()const;$/;"	p	class:allocator_architype	access:public	signature:() const
max_size	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL max_size()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
max_size	/usr/include/boost/regex/v4/match_results.hpp	/^   size_type max_size() const$/;"	f	class:boost::match_results	access:public	signature:() const
max_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::ptrdiff_t max_state_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
maybe_assign	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL maybe_assign(const match_results<BidiIterator, Allocator>& m);$/;"	p	class:boost::match_results	access:public	signature:(const match_results<BidiIterator, Allocator>& m)
maybe_assign	/usr/include/boost/regex/v4/match_results.hpp	/^void BOOST_REGEX_CALL match_results<BidiIterator, Allocator>::maybe_assign(const match_results<BidiIterator, Allocator>& m)$/;"	f	class:boost::match_results	signature:(const match_results<BidiIterator, Allocator>& m)
maybe_char_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename boost::remove_cv< typename boost::remove_pointer<Func>::type>::type maybe_char_type;$/;"	t	struct:boost::re_detail::compute_functor_type	access:public
medium_type	/usr/include/boost/system/linux_error.hpp	/^        medium_type = EMEDIUMTYPE,$/;"	e	enum:boost::system::linux_error::linux_errno
mem_block_cache	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^struct mem_block_cache$/;"	s	namespace:boost::re_detail
mem_block_node	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^struct mem_block_node$/;"	s	namespace:boost::re_detail
Merge	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string Merge(const char* in, const char* fmt,$/;"	p	class:boost::RegEx	access:public	signature:(const char* in, const char* fmt, bool copy = true, match_flag_type flags = match_default)
Merge	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string Merge(const std::string& in, const std::string& fmt,$/;"	p	class:boost::RegEx	access:public	signature:(const std::string& in, const std::string& fmt, bool copy = true, match_flag_type flags = match_default)
message	/usr/include/boost/system/error_code.hpp	/^      std::string             message() const  { return m_cat->message(value()); }$/;"	f	class:boost::system::error_code	access:public	signature:() const
message	/usr/include/boost/system/error_code.hpp	/^      std::string             message() const  { return m_cat->message(value()); }$/;"	f	class:boost::system::error_condition	access:public	signature:() const
message	/usr/include/boost/system/error_code.hpp	/^      virtual std::string      message( int ev ) const = 0;$/;"	p	class:boost::system::error_category	access:public	signature:( int ev ) const
message_size	/usr/include/boost/system/error_code.hpp	/^        message_size = EMSGSIZE,$/;"	e	enum:boost::system::errc::errc_t
mfc_string_out_iterator	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator(ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s) : out(&s) {}$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:(ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s)
mfc_string_out_iterator	/usr/include/boost/regex/mfc.hpp	/^class mfc_string_out_iterator$/;"	c	namespace:boost::re_detail
min	/usr/include/boost/regex/v4/states.hpp	/^   std::size_t   min, max;  \/\/ min and max allowable repeats$/;"	m	struct:boost::re_detail::re_repeat	access:public
minus_one	/usr/include/boost/xpressive/regex_primitives.hpp	/^    typedef mpl::int_<-1> minus_one;$/;"	t	namespace:boost::xpressive::detail
minus_one	/usr/include/boost/xpressive/regex_primitives.hpp	101;"	d
minus_one	/usr/include/boost/xpressive/regex_primitives.hpp	47;"	d
mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_s = 1 << 12,                            \/\/ force s modifier on (overrides match_not_dot_newline)$/;"	e	enum:boost::regbase::flag_type_
mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_s = ::boost::regbase::mod_s,$/;"	e	enum:boost::regex_constants::flag_type_
mod_x	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_x = 1 << 11,                            \/\/ Perl x modifier$/;"	e	enum:boost::regbase::flag_type_
mod_x	/usr/include/boost/regex/v4/regbase.hpp	/^      mod_x = ::boost::regbase::mod_x,$/;"	e	enum:boost::regex_constants::flag_type_
momentum	/usr/include/boost/units/systems/cgs/momentum.hpp	/^typedef unit<momentum_dimension,cgs::system>     momentum;$/;"	t	namespace:boost::units::cgs
momentum	/usr/include/boost/units/systems/si/momentum.hpp	/^typedef unit<momentum_dimension,si::system>  momentum;$/;"	t	namespace:boost::units::si
moment_of_inertia	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	/^typedef unit<moment_of_inertia_dimension,si::system>      moment_of_inertia;$/;"	t	namespace:boost::units::si
mpl	/usr/include/boost/units/heterogeneous_system.hpp	/^namespace mpl {$/;"	n	namespace:boost
multiply_systems	/usr/include/boost/units/heterogeneous_system.hpp	/^struct multiply_systems$/;"	s	namespace:boost::units::detail
mut	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   boost::static_mutex mut;$/;"	m	struct:boost::re_detail::mem_block_cache	access:public
mylog2	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    inline int mylog2(umaskex_t i)$/;"	f	namespace:boost::xpressive::detail	signature:(umaskex_t i)
m_alpha_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_alpha_mask;      \/\/ mask used to determine if a character is an alphabetic character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_alt_insert_point	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::ptrdiff_t             m_alt_insert_point; \/\/ where to insert the next alternative$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_alt_jumps	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::vector<long>           m_alt_jumps;      \/\/ list of alternative in the current scope.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_alt_jumps	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::vector<std::ptrdiff_t> m_alt_jumps;      \/\/ list of alternative in the current scope.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_append_separator_if_needed	/usr/include/boost/filesystem/path.hpp	/^    string_type::size_type m_append_separator_if_needed();$/;"	p	class:boost::filesystem::path	access:private	signature:()
m_backrefs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   unsigned                      m_backrefs;           \/\/ bitmask of permitted backrefs$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_backup_state	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state* m_backup_state;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_bad_repeats	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   boost::uintmax_t              m_bad_repeats;        \/\/ bitmask of repeats we can't deduce a startmap for;$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_base	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   const charT*               m_base;           \/\/ the start of the string being parsed$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_base	/usr/include/boost/regex/v4/match_results.hpp	/^   BidiIterator   m_base;                              \/\/ where the search started from$/;"	m	class:boost::match_results	access:private
m_can_be_null	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int                m_can_be_null;             \/\/ whether we can match a null string$/;"	m	struct:boost::re_detail::regex_data	access:public
m_captures	/usr/include/boost/regex/v4/sub_match.hpp	/^   mutable boost::scoped_ptr<capture_sequence_type> m_captures;$/;"	m	struct:boost::sub_match	access:private
m_cat	/usr/include/boost/system/error_code.hpp	/^      const error_category *  m_cat;$/;"	m	class:boost::system::error_code	access:private
m_cat	/usr/include/boost/system/error_code.hpp	/^      const error_category *  m_cat;$/;"	m	class:boost::system::error_condition	access:private
m_char	/usr/include/boost/regex/concepts.hpp	/^   char_type m_char;$/;"	m	struct:boost::RegexTraitsConcept	access:public
m_char	/usr/include/boost/regex/concepts.hpp	/^   const value_type m_char;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_char	/usr/include/boost/regex/concepts.hpp	/^   const value_type m_char;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_char	/usr/include/boost/regex/concepts.hpp	/^   value_type m_char;$/;"	m	struct:boost::RegexConcept	access:public
m_char_map	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   map_type m_char_map;$/;"	m	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
m_char_map	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type m_char_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
m_char_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   map_type m_char_map;$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
m_char_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type m_char_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
m_classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type                    m_classes;         \/\/ character classes to match$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_collate_delim	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT                          m_collate_delim;   \/\/ the collation group delimiter$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
m_collate_delim	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT                          m_collate_delim;   \/\/ the collation group delimiter$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
m_collate_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   unsigned                       m_collate_type;    \/\/ the form of the collation string$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
m_collate_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   unsigned                       m_collate_type;    \/\/ the form of the collation string$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
m_collator	/usr/include/boost/regex/icu.hpp	/^   boost::scoped_ptr< U_NAMESPACE_QUALIFIER Collator> m_collator;          \/\/ The full collation object$/;"	m	class:boost::re_detail::icu_regex_traits_implementation	access:private
m_cresults	/usr/include/boost/regex/concepts.hpp	/^   const match_results_type m_cresults;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_cresults	/usr/include/boost/regex/concepts.hpp	/^   const match_results_type m_cresults;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_cresults	/usr/include/boost/regex/concepts.hpp	/^   const match_results_type m_cresults;$/;"	m	struct:boost::RegexConcept	access:public
m_ctraits	/usr/include/boost/regex/concepts.hpp	/^   const traits m_ctraits;$/;"	m	struct:boost::RegexTraitsConcept	access:public
m_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable unsigned m_current;$/;"	m	class:boost::u32_to_u16_iterator	access:private
m_current	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable unsigned m_current;$/;"	m	class:boost::u32_to_u8_iterator	access:private
m_custom_class_names	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::map<string_type, char_class_type>  m_custom_class_names; \/\/ character class names$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
m_custom_class_names	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::map<string_type, char_class_type>  m_custom_class_names; \/\/ character class names$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
m_custom_collate_names	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::map<string_type, string_type>      m_custom_collate_names; \/\/ collating element names$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
m_custom_collate_names	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::map<string_type, string_type>      m_custom_collate_names; \/\/ collating element names$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
m_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   re_detail::raw_storage      m_data;                    \/\/ the buffer in which our states are constructed$/;"	m	struct:boost::re_detail::regex_data	access:public
m_element	/usr/include/boost/filesystem/path.hpp	/^    path                    m_element;   \/\/ current element$/;"	m	class:boost::filesystem::path::iterator	access:private
m_empty	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                      m_empty;           \/\/ whether we've added anything yet$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_end	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   const charT*               m_end;            \/\/ the end of the string being parsed$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_end	/usr/include/boost/regex/v4/regex_format.hpp	/^   ForwardIter      m_end;       \/\/ format string end$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_equivalents	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<digraph_type> m_equivalents;     \/\/ a list of equivalence classes$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_erase_redundant_separator	/usr/include/boost/filesystem/path.hpp	/^    void m_erase_redundant_separator(string_type::size_type sep_pos);$/;"	p	class:boost::filesystem::path	access:private	signature:(string_type::size_type sep_pos)
m_error_code	/usr/include/boost/regex/pattern_except.hpp	/^   regex_constants::error_type m_error_code;$/;"	m	class:boost::regex_error	access:private
m_error_code	/usr/include/boost/system/system_error.hpp	/^      error_code           m_error_code;$/;"	m	class:boost::system::system_error	access:private
m_error_strings	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::map<int, std::string>     m_error_strings;   \/\/ error messages indexed by numberic ID$/;"	m	class:boost::re_detail::cpp_regex_traits_implementation	access:private
m_error_strings	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   std::map<int, std::string>     m_error_strings;   \/\/ error messages indexed by numberic ID$/;"	m	class:boost::re_detail::w32_regex_traits_implementation	access:private
m_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   const charT*                m_expression;              \/\/ the original expression$/;"	m	struct:boost::re_detail::regex_data	access:public
m_expression_len	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::ptrdiff_t              m_expression_len;          \/\/ the length of the original expression$/;"	m	struct:boost::re_detail::regex_data	access:public
m_first_state	/usr/include/boost/regex/v4/basic_regex.hpp	/^   re_detail::re_syntax_base*  m_first_state;             \/\/ the first state of the machine$/;"	m	struct:boost::re_detail::regex_data	access:public
m_Flags	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                match_flag_type m_Flags;$/;"	m	struct:boost::algorithm::detail::regex_formatF	access:private
m_flags	/usr/include/boost/regex/concepts.hpp	/^   flag_type m_flags;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_flags	/usr/include/boost/regex/concepts.hpp	/^   flag_type m_flags;$/;"	m	struct:boost::RegexConcept	access:public
m_flags	/usr/include/boost/regex/v4/basic_regex.hpp	/^   flag_type                   m_flags;                   \/\/ flags with which we were compiled$/;"	m	struct:boost::re_detail::regex_data	access:public
m_flags	/usr/include/boost/regex/v4/regex_format.hpp	/^   match_flag_type  m_flags;      \/\/ format flags to use$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_Fmt	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                const StringT& m_Fmt;$/;"	m	struct:boost::algorithm::detail::regex_formatF	access:private
m_get_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status m_get_status(system::error_code* ec=0) const;$/;"	p	class:boost::filesystem::directory_entry	access:private	signature:(system::error_code* ec=0) const
m_get_symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status m_get_symlink_status(system::error_code* ec=0) const;$/;"	p	class:boost::filesystem::directory_entry	access:private	signature:(system::error_code* ec=0) const
m_has_backrefs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                          m_has_backrefs;       \/\/ true if there are actually any backrefs$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_has_case_change	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool                       m_has_case_change; \/\/ true if somewhere in the current block the case has changed$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_has_digraphs	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                      m_has_digraphs;    \/\/ true if we have digraphs present$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_has_found_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_has_found_match;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_has_partial_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_has_partial_match;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_has_recursions	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool                        m_has_recursions;          \/\/ whether we have recursive expressions;$/;"	m	struct:boost::re_detail::regex_data	access:public
m_has_recursions	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                          m_has_recursions;     \/\/ set when we have recursive expresisons to fixup$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_have_conditional	/usr/include/boost/regex/v4/regex_format.hpp	/^   bool             m_have_conditional; \/\/ we are parsing a conditional$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_have_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   bool m_have_lock;$/;"	m	class:boost::scoped_static_mutex_lock	access:private
m_icase	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                          m_icase;              \/\/ true for case insensitive matches$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_imp	/usr/include/boost/filesystem/operations.hpp	/^    boost::shared_ptr< detail::dir_itr_imp >  m_imp;$/;"	m	class:boost::filesystem::directory_iterator	access:private
m_imp	/usr/include/boost/filesystem/operations.hpp	/^    boost::shared_ptr< detail::recur_dir_itr_imp >  m_imp;$/;"	m	class:boost::filesystem::recursive_directory_iterator	access:private
m_imp	/usr/include/boost/filesystem/operations.hpp	/^    struct m_imp$/;"	s	class:boost::filesystem::filesystem_error	access:private
m_imp_ptr	/usr/include/boost/filesystem/operations.hpp	/^    boost::shared_ptr<m_imp> m_imp_ptr;$/;"	m	class:boost::filesystem::filesystem_error	access:private
m_in	/usr/include/boost/regex/concepts.hpp	/^   BidiIterator m_in;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_in	/usr/include/boost/regex/concepts.hpp	/^   BidiIterator m_in;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_in	/usr/include/boost/regex/concepts.hpp	/^   BidiIterator m_in;$/;"	m	struct:boost::RegexConcept	access:public
m_independent	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_independent;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_is_singular	/usr/include/boost/regex/v4/match_results.hpp	/^   bool m_is_singular;                                 \/\/ True if our stored iterators are singular$/;"	m	class:boost::match_results	access:private
m_last_closed_paren	/usr/include/boost/regex/v4/match_results.hpp	/^   int m_last_closed_paren;                            \/\/ Last ) to be seen - used for formatting$/;"	m	class:boost::match_results	access:private
m_last_state	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   re_syntax_base*               m_last_state;         \/\/ the last state we added$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_level	/usr/include/boost/filesystem/operations.hpp	/^      int  m_level;$/;"	m	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
m_locale	/usr/include/boost/regex/icu.hpp	/^   U_NAMESPACE_QUALIFIER Locale m_locale;                                  \/\/ The ICU locale that we're using$/;"	m	class:boost::re_detail::icu_regex_traits_implementation	access:private
m_locale	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::locale m_locale;$/;"	m	struct:boost::re_detail::cpp_regex_traits_base	access:public
m_locale	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   lcid_type m_locale;$/;"	m	struct:boost::re_detail::w32_regex_traits_base	access:public
m_lower_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char m_lower_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
m_lower_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_lower_mask;       \/\/ mask used to determine if a character is a lowercase character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_mark_count	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type                   m_mark_count;              \/\/ the number of marked sub-expressions$/;"	m	struct:boost::re_detail::regex_data	access:public
m_mark_count	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   unsigned                   m_mark_count;     \/\/ how many sub-expressions we have$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_mark_reset	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   int                        m_mark_reset;     \/\/ used to indicate that we're inside a (?|...) block.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_mask1	/usr/include/boost/regex/concepts.hpp	/^   Bitmask m_mask1, m_mask2, m_mask3;$/;"	m	struct:boost::BitmaskConcept	access:public
m_mask2	/usr/include/boost/regex/concepts.hpp	/^   Bitmask m_mask1, m_mask2, m_mask3;$/;"	m	struct:boost::BitmaskConcept	access:public
m_mask3	/usr/include/boost/regex/concepts.hpp	/^   Bitmask m_mask1, m_mask2, m_mask3;$/;"	m	struct:boost::BitmaskConcept	access:public
m_mask_space	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_mask_space;      \/\/ mask used to determine if a character is a word character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_MatchFlags	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                match_flag_type m_MatchFlags;     \/\/ match flags$/;"	m	struct:boost::algorithm::detail::find_regexF	access:private
m_MatchResults	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                match_results_type m_MatchResults;$/;"	m	struct:boost::algorithm::detail::regex_search_result	access:private
m_match_flags	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   match_flag_type m_match_flags;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_max_mark	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   unsigned                   m_max_mark;       \/\/ largest mark count seen inside a (?|...) block.$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_mft	/usr/include/boost/regex/concepts.hpp	/^   global_regex_namespace::regex_constants::match_flag_type m_mft;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_mft	/usr/include/boost/regex/concepts.hpp	/^   global_regex_namespace::regex_constants::match_flag_type m_mft;$/;"	m	struct:boost::RegexConcept	access:public
m_mutex	/usr/include/boost/regex/pending/static_mutex.hpp	/^   pthread_mutex_t m_mutex;$/;"	m	class:boost::static_mutex	access:public
m_mutex	/usr/include/boost/regex/pending/static_mutex.hpp	/^   static_mutex& m_mutex;$/;"	m	class:boost::scoped_static_mutex_lock	access:private
m_named_subs	/usr/include/boost/regex/v4/match_results.hpp	/^   boost::shared_ptr<named_sub_type> m_named_subs;     \/\/ Shared copy of named subs in the regex object$/;"	m	class:boost::match_results	access:private
m_negate	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   bool                      m_negate;          \/\/ true if the set is to be negated$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_negated_classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type                    m_negated_classes; \/\/ negated character classes to match$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_normalize	/usr/include/boost/filesystem/path.hpp	/^    path& m_normalize();$/;"	p	class:boost::filesystem::path	access:private	signature:()
m_null	/usr/include/boost/regex/v4/match_results.hpp	/^   sub_match<BidiIterator> m_null;                     \/\/ a null match$/;"	m	class:boost::match_results	access:private
m_options	/usr/include/boost/filesystem/operations.hpp	/^      BOOST_SCOPED_ENUM(symlink_option) m_options;$/;"	m	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
m_out	/usr/include/boost/regex/concepts.hpp	/^   OutIterator m_out;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_out	/usr/include/boost/regex/concepts.hpp	/^   OutIterator m_out;$/;"	m	struct:boost::RegexConcept	access:public
m_out	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIterator   m_out;         \/\/ where to send output.$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_parent_path_end	/usr/include/boost/filesystem/path.hpp	/^    string_type::size_type m_parent_path_end() const;$/;"	p	class:boost::filesystem::path	access:private	signature:() const
m_paren_start	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   std::ptrdiff_t             m_paren_start;    \/\/ where the last seen ')' began (where repeats are inserted).$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_parser_proc	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   parser_proc_type           m_parser_proc;    \/\/ the main parser to use$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_path	/usr/include/boost/filesystem/operations.hpp	/^  boost::filesystem::path   m_path;$/;"	m	class:boost::filesystem::directory_entry	access:private
m_path1	/usr/include/boost/filesystem/operations.hpp	/^      path         m_path1; \/\/ may be empty()$/;"	m	struct:boost::filesystem::filesystem_error::m_imp	access:public
m_path2	/usr/include/boost/filesystem/operations.hpp	/^      path         m_path2; \/\/ may be empty()$/;"	m	struct:boost::filesystem::filesystem_error::m_imp	access:public
m_pathname	/usr/include/boost/filesystem/path.hpp	/^    string_type  m_pathname;  \/\/ Windows: as input; backslashes NOT converted to slashes,$/;"	m	class:boost::filesystem::path	access:private
m_path_iterator_decrement	/usr/include/boost/filesystem/path.hpp	/^    friend void m_path_iterator_decrement(path::iterator & it);$/;"	p	class:boost::filesystem::path::iterator	access:friend	signature:(path::iterator & it)
m_path_iterator_decrement	/usr/include/boost/filesystem/path.hpp	/^    static void m_path_iterator_decrement(path::iterator & it);$/;"	p	class:boost::filesystem::path	access:private	signature:(path::iterator & it)
m_path_iterator_increment	/usr/include/boost/filesystem/path.hpp	/^    friend void m_path_iterator_increment(path::iterator & it);$/;"	p	class:boost::filesystem::path::iterator	access:friend	signature:(path::iterator & it)
m_path_iterator_increment	/usr/include/boost/filesystem/path.hpp	/^    static void m_path_iterator_increment(path::iterator & it);$/;"	p	class:boost::filesystem::path	access:private	signature:(path::iterator & it)
m_path_ptr	/usr/include/boost/filesystem/path.hpp	/^    const path*             m_path_ptr;  \/\/ path being iterated over$/;"	m	class:boost::filesystem::path::iterator	access:private
m_pcollate	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::collate<charT> const* m_pcollate;$/;"	m	class:boost::re_detail::cpp_regex_traits_base::std	access:public
m_pctype	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::ctype<charT> const* m_pctype;$/;"	m	class:boost::re_detail::cpp_regex_traits_base::std	access:public
m_pdata	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   regex_data<charT, traits>*    m_pdata;              \/\/ pointer to the basic_regex_data struct we are filling in$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_perms	/usr/include/boost/filesystem/operations.hpp	/^    enum perms  m_perms;$/;"	m	class:boost::filesystem::file_status	typeref:enum:boost::filesystem::file_status::perms	access:private
m_pimpl	/usr/include/boost/regex/icu.hpp	/^   boost::shared_ptr< ::boost::re_detail::icu_regex_traits_implementation> m_pimpl;$/;"	m	class:boost::icu_regex_traits	access:private
m_pimpl	/usr/include/boost/regex/v4/basic_regex.hpp	/^   shared_ptr<re_detail::basic_regex_implementation<charT, traits> > m_pimpl;$/;"	m	class:boost::basic_regex	access:private
m_pimpl	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   boost::shared_ptr<const re_detail::cpp_regex_traits_implementation<charT> > m_pimpl;$/;"	m	class:boost::cpp_regex_traits	access:private
m_pimpl	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   boost::shared_ptr<const re_detail::w32_regex_traits_implementation<charT> > m_pimpl;$/;"	m	class:boost::w32_regex_traits	access:private
m_pmatch	/usr/include/boost/regex/concepts.hpp	/^      m_pmatch;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_pmessages	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::messages<charT> const* m_pmessages;$/;"	m	class:boost::re_detail::cpp_regex_traits_base::std	access:public
m_pointer	/usr/include/boost/regex/concepts.hpp	/^   const char_type* m_pointer;$/;"	m	struct:boost::RegexTraitsConcept	access:public
m_pointer	/usr/include/boost/regex/concepts.hpp	/^   pointer_type m_pointer;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_pointer	/usr/include/boost/regex/concepts.hpp	/^   pointer_type m_pointer;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_pointer	/usr/include/boost/regex/concepts.hpp	/^   pointer_type m_pointer;$/;"	m	struct:boost::RegexConcept	access:public
m_pos	/usr/include/boost/filesystem/path.hpp	/^    string_type::size_type  m_pos;       \/\/ position of m_element in$/;"	m	class:boost::filesystem::path::iterator	access:private
m_position	/usr/include/boost/regex/pattern_except.hpp	/^   std::ptrdiff_t m_position;$/;"	m	class:boost::regex_error	access:private
m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u16_to_u32_iterator	access:private
m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u32_to_u16_iterator	access:private
m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u32_to_u8_iterator	access:private
m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   BaseIterator m_position;$/;"	m	class:boost::u8_to_u32_iterator	access:private
m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable BaseIterator m_position;$/;"	m	class:boost::utf16_output_iterator	access:private
m_position	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable BaseIterator m_position;$/;"	m	class:boost::utf8_output_iterator	access:private
m_position	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   const charT*               m_position;       \/\/ our current parser position$/;"	m	class:boost::re_detail::basic_regex_parser	access:private
m_position	/usr/include/boost/regex/v4/regex_format.hpp	/^   ForwardIter      m_position;  \/\/ format string, current position$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_presult	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   match_results<BidiIterator, Allocator>* m_presult;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_primary_collator	/usr/include/boost/regex/icu.hpp	/^   boost::scoped_ptr< U_NAMESPACE_QUALIFIER Collator> m_primary_collator;  \/\/ The primary collation object$/;"	m	class:boost::re_detail::icu_regex_traits_implementation	access:private
m_ptraits	/usr/include/boost/regex/v4/basic_regex.hpp	/^      >                        m_ptraits;                 \/\/ traits class instance$/;"	m	struct:boost::re_detail::regex_data	access:public
m_ranges	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<digraph_type> m_ranges;          \/\/ a list of end points of our ranges$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_recursion_checks	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<bool>             m_recursion_checks;   \/\/ notes which recursions we've followed while analysing this expression$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_recursive_result	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool m_recursive_result;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_repeater_id	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   unsigned                      m_repeater_id;        \/\/ the state_id of the next repeater$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_restart_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned                    m_restart_type;            \/\/ search optimisation type$/;"	m	struct:boost::re_detail::regex_data	access:public
m_restore_state	/usr/include/boost/regex/v4/regex_format.hpp	/^   output_state     m_restore_state;  \/\/ what state to restore to.$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_result	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   match_results<BidiIterator, Allocator>& m_result;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_results	/usr/include/boost/regex/concepts.hpp	/^   match_results_type m_results;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_results	/usr/include/boost/regex/concepts.hpp	/^   match_results_type m_results;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_results	/usr/include/boost/regex/concepts.hpp	/^   match_results_type m_results;$/;"	m	struct:boost::RegexConcept	access:public
m_results	/usr/include/boost/regex/v4/regex_format.hpp	/^   const Results&   m_results;     \/\/ the match_results being used.$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_Rx	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_reference_type m_Rx; \/\/ Regexp$/;"	m	struct:boost::algorithm::detail::find_regexF	access:private
m_singles	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   std::vector<digraph_type> m_singles;         \/\/ a list of single characters to match$/;"	m	class:boost::re_detail::basic_char_set	access:private
m_size	/usr/include/boost/regex/concepts.hpp	/^   std::size_t m_size;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_smatch	/usr/include/boost/regex/concepts.hpp	/^   global_regex_namespace::match_results<typename string_type::const_iterator, allocator_architype<global_regex_namespace::sub_match<typename string_type::const_iterator> > > m_smatch;$/;"	m	struct:boost::RegexConcept	access:public
m_stack	/usr/include/boost/filesystem/operations.hpp	/^      std::stack< element_type, std::vector< element_type > > m_stack;$/;"	m	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public
m_stack_base	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state* m_stack_base;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_startmap	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned char               m_startmap[1 << CHAR_BIT]; \/\/ which characters can start a match$/;"	m	struct:boost::re_detail::regex_data	access:public
m_state	/usr/include/boost/regex/v4/regex_format.hpp	/^   output_state     m_state;      \/\/ what to do with the next character$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_status	/usr/include/boost/filesystem/operations.hpp	/^  mutable file_status       m_status;           \/\/ stat()-like$/;"	m	class:boost::filesystem::directory_entry	access:private
m_status	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int                         m_status;                  \/\/ error code (0 implies OK).$/;"	m	struct:boost::re_detail::regex_data	access:public
m_stream	/usr/include/boost/regex/concepts.hpp	/^   std::basic_ostream<value_type> m_stream;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_string	/usr/include/boost/regex/concepts.hpp	/^   string_type m_string;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_string	/usr/include/boost/regex/concepts.hpp	/^   string_type m_string;$/;"	m	struct:boost::RegexConcept	access:public
m_sub	/usr/include/boost/regex/concepts.hpp	/^   const sub_match_type m_sub;$/;"	m	struct:boost::BaseRegexConcept	access:public
m_sub	/usr/include/boost/regex/concepts.hpp	/^   const sub_match_type m_sub;$/;"	m	struct:boost::RegexConcept	access:public
m_sub	/usr/include/boost/regex/concepts.hpp	/^   sub_match_type m_sub;$/;"	m	struct:boost::BoostRegexConcept	access:public
m_subs	/usr/include/boost/regex/v4/basic_regex.hpp	/^      std::size_t, std::size_t> > m_subs;                 \/\/ Position of sub-expressions within the *string*.$/;"	m	struct:boost::re_detail::regex_data	access:public
m_subs	/usr/include/boost/regex/v4/match_results.hpp	/^   vector_type            m_subs;                      \/\/ subexpressions$/;"	m	class:boost::match_results	access:private
m_sub_names	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::vector<name> m_sub_names;$/;"	m	class:boost::re_detail::named_subexpressions	access:private
m_symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  mutable file_status       m_symlink_status;   \/\/ lstat()-like$/;"	m	class:boost::filesystem::directory_entry	access:private
m_temp_match	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   scoped_ptr<match_results<BidiIterator, Allocator> > m_temp_match;$/;"	m	class:boost::re_detail::perl_matcher	access:private
m_traits	/usr/include/boost/regex/concepts.hpp	/^   traits m_traits;$/;"	m	struct:boost::RegexTraitsConcept	access:public
m_traits	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^                                 m_traits;             \/\/ convenience reference to traits class$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_traits	/usr/include/boost/regex/v4/regex_format.hpp	/^   const traits&    m_traits;       \/\/ the traits class for localised formatting operations$/;"	m	class:boost::re_detail::basic_regex_formatter	access:private
m_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef typename traits::char_class_type m_type;$/;"	t	class:boost::re_detail::basic_char_set	access:public
m_type_map	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   boost::uint16_t m_type_map[1u << CHAR_BIT];$/;"	m	class:boost::re_detail::w32_regex_traits_char_layer	access:private
m_upper_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_upper_mask;      \/\/ mask used to determine if a character is an uppercase character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_val	/usr/include/boost/system/error_code.hpp	/^      int                     m_val;$/;"	m	class:boost::system::error_code	access:private
m_val	/usr/include/boost/system/error_code.hpp	/^      int                     m_val;$/;"	m	class:boost::system::error_condition	access:private
m_value	/usr/include/boost/filesystem/operations.hpp	/^    file_type   m_value;$/;"	m	class:boost::filesystem::file_status	access:private
m_value	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U32Type m_value;$/;"	m	class:boost::u16_to_u32_iterator	access:private
m_value	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U32Type m_value;$/;"	m	class:boost::u8_to_u32_iterator	access:private
m_values	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U16Type m_values[3];$/;"	m	class:boost::u32_to_u16_iterator	access:private
m_values	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   mutable U8Type m_values[5];$/;"	m	class:boost::u32_to_u8_iterator	access:private
m_what	/usr/include/boost/filesystem/operations.hpp	/^      std::string  m_what;  \/\/ not built until needed$/;"	m	struct:boost::filesystem::filesystem_error::m_imp	access:public
m_what	/usr/include/boost/system/system_error.hpp	/^      mutable std::string  m_what;$/;"	m	class:boost::system::system_error	access:private
m_word_mask	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typename traits::char_class_type    m_word_mask;       \/\/ mask used to determine if a character is a word character$/;"	m	struct:boost::re_detail::regex_data	access:public
m_word_mask	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typename traits::char_class_type m_word_mask;       \/\/ mask used to determine if a character is a word character$/;"	m	class:boost::re_detail::basic_regex_creator	access:protected
m_word_mask	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typename traits::char_class_type m_word_mask;$/;"	m	class:boost::re_detail::perl_matcher	access:private
N	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   int                                  N;      \/\/ the current sub-expression being enumerated$/;"	m	class:boost::regex_token_iterator_implementation	access:private
N	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   int                                  N;      \/\/ the current sub-expression being enumerated$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
name	/usr/include/boost/chrono/system_clocks.hpp	/^    static std::basic_string<CharT> name()$/;"	f	struct:boost::chrono::clock_string	access:public	signature:()
name	/usr/include/boost/regex/v4/basic_regex.hpp	/^      name(const charT* i, const charT* j, int idx)$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(const charT* i, const charT* j, int idx)
name	/usr/include/boost/regex/v4/basic_regex.hpp	/^      name(int h, int idx)$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(int h, int idx)
name	/usr/include/boost/regex/v4/basic_regex.hpp	/^   struct name$/;"	s	class:boost::re_detail::named_subexpressions	access:public
name	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* name()const { return ptr; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:() const
name	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* name()const { return ptr; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:() const
name	/usr/include/boost/system/error_code.hpp	/^      virtual const char *     name() const = 0;$/;"	p	class:boost::system::error_category	access:public	signature:() const
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Amount]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Electric Current]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Length]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Luminous Intensity]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Mass]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Plane Angle]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Solid Angle]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Temperature]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
name	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string name()       { return "[Time]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
named_mark	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    named_mark(string_type name, std::size_t mark_nbr)$/;"	f	struct:boost::xpressive::detail::named_mark	access:public	signature:(string_type name, std::size_t mark_nbr)
named_mark	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct named_mark$/;"	s	namespace:boost::xpressive::detail
named_marks_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    std::vector<named_mark<char_type> > named_marks_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
named_subexpression	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference named_subexpression(const charT* i, const charT* j) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* i, const charT* j) const
named_subexpression	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference named_subexpression(const char_type* i, const char_type* j) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* i, const char_type* j) const
named_subexpressions	/usr/include/boost/regex/v4/basic_regex.hpp	/^   named_subexpressions(){}$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:()
named_subexpressions	/usr/include/boost/regex/v4/basic_regex.hpp	/^class named_subexpressions$/;"	c	namespace:boost::re_detail
named_subexpression_index	/usr/include/boost/regex/v4/match_results.hpp	/^   int named_subexpression_index(const charT* i, const charT* j) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* i, const charT* j) const
named_subexpression_index	/usr/include/boost/regex/v4/match_results.hpp	/^   int named_subexpression_index(const char_type* i, const char_type* j) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* i, const char_type* j) const
named_sub_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          re_detail::named_subexpressions                         named_sub_type;$/;"	t	class:boost::match_results	access:public
name_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    string_type name_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::acceleration>::type&) { return "galileo"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::acceleration>::type&)
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::current>::type&)   { return "biot"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::current>::type&)
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::dynamic_viscosity>::type&) { return "poise"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::dynamic_viscosity>::type&)
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::energy>::type&) { return "erg"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::energy>::type&)
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::force>::type&) { return "dyne"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::force>::type&)
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::kinematic_viscosity>::type&) { return "stoke"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::kinematic_viscosity>::type&)
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::pressure>::type&) { return "barye"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::pressure>::type&)
name_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string name_string(const reduce_unit<cgs::wavenumber>::type&) { return "kayser"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::wavenumber>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::absorbed_dose>::type&) { return "gray"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::absorbed_dose>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::capacitance>::type&)   { return "farad"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::capacitance>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::catalytic_activity>::type&) { return "katal"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::catalytic_activity>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::conductance>::type&) { return "siemen"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::conductance>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::electric_charge>::type&) { return "coulomb"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_charge>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::electric_potential>::type&) { return "volt"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_potential>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::energy>::type&) { return "joule"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::energy>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::force>::type&) { return "newton"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::force>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::frequency>::type&) { return "hertz"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::frequency>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::illuminance>::type&) { return "lux"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::illuminance>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::inductance>::type&) { return "henry"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::inductance>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::luminous_flux>::type&) { return "lumen"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::luminous_flux>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::magnetic_flux>::type&) { return "weber"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::magnetic_flux_density>::type&) { return "tesla"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux_density>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::power>::type&) { return "watt"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::power>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::pressure>::type&) { return "pascal"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::pressure>::type&)
name_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string name_string(const reduce_unit<si::resistance>::type&) { return "ohm"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::resistance>::type&)
native	/usr/include/boost/filesystem/path.hpp	/^    const string_type&  native() const { return m_pathname; }          \/\/ Throws: nothing$/;"	f	class:boost::filesystem::path	access:public	signature:() const
native	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool native(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
native_directory_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string native_directory_string() const   { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
native_ecat	/usr/include/boost/system/error_code.hpp	/^    static const error_category &  native_ecat    = system_category();$/;"	m	namespace:boost::system
native_file_string	/usr/include/boost/filesystem/path.hpp	/^    const std::string native_file_string() const        { return string(); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
native_file_string	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline std::string native_file_string(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
native_mask_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename std::ctype<charT>::mask                  native_mask_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
ncg	/usr/include/boost/geometry/core/coordinate_system.hpp	/^    typedef typename boost::remove_const<Geometry>::type ncg;$/;"	t	struct:boost::geometry::coordinate_system	access:public
negate	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void negate()$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:()
negated_classes	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   m_type negated_classes()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
negate_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct negate_impl<boost::units::heterogeneous_system_dim_tag>$/;"	s	namespace:boost::mpl
network_busy	/usr/include/boost/system/windows_error.hpp	/^        network_busy = ERROR_NETWORK_BUSY,$/;"	e	enum:boost::system::windows_error::windows_error_code
network_down	/usr/include/boost/system/error_code.hpp	/^        network_down = ENETDOWN,$/;"	e	enum:boost::system::errc::errc_t
network_reset	/usr/include/boost/system/error_code.hpp	/^        network_reset = ENETRESET,$/;"	e	enum:boost::system::errc::errc_t
network_unreachable	/usr/include/boost/system/error_code.hpp	/^        network_unreachable = ENETUNREACH,$/;"	e	enum:boost::system::errc::errc_t
newline_alt	/usr/include/boost/regex/v4/regbase.hpp	/^      newline_alt = 1 << 17,                            \/\/ \\n is the same as |$/;"	e	enum:boost::regbase::flag_type_
next	/usr/include/boost/regex/v4/fileiter.hpp	/^   void next();$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:()
next	/usr/include/boost/regex/v4/fileiter.hpp	/^   void next();$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:()
next	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   mem_block_node* next;$/;"	m	struct:boost::re_detail::mem_block_cache	access:public
next	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   mem_block_node* next;$/;"	m	struct:boost::re_detail::mem_block_node	access:public
next	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count* next;$/;"	m	class:boost::re_detail::repeater_count	access:private
next	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool next()$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:()
next	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool next()$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:()
next	/usr/include/boost/regex/v4/states.hpp	/^   offset_type           next;         \/\/ next state in the machine$/;"	m	struct:boost::re_detail::re_syntax_base	access:public
next	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool next()$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:()
next	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool next()$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:()
next	/usr/include/boost/xpressive/regex_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:()
next	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:()
next_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
next_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
next_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count<BidiIterator>* next_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
nil	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const nil = {{}};$/;"	m	class:boost::xpressive::proto::terminal
nocollate	/usr/include/boost/regex/v4/regbase.hpp	/^      nocollate = 0,                                    \/\/ don't use locale specific collation (deprecated)$/;"	e	enum:boost::regbase::flag_type_
nocollate	/usr/include/boost/regex/v4/regbase.hpp	/^      nocollate = ::boost::regbase::nocollate,$/;"	e	enum:boost::regex_constants::flag_type_
non_std_ctype_blank	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = 1 << 12;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_blank	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = unused_mask<all_ctype_masks | non_std_ctype_underscore>::value;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_masks	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_masks = non_std_ctype_underscore | non_std_ctype_blank | non_std_ctype_newline;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_newline	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = 1 << 13;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_newline	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = unused_mask<all_ctype_masks | non_std_ctype_underscore | non_std_ctype_blank>::value;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_underscore	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = 1 << 11;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_underscore	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = unused_mask<all_ctype_masks>::value;$/;"	m	namespace:boost::xpressive::detail
normal	/usr/include/boost/regex/v4/regbase.hpp	/^      normal = 0,$/;"	e	enum:boost::regbase::flag_type_
normal	/usr/include/boost/regex/v4/regbase.hpp	/^      normal = ::boost::regbase::normal,$/;"	e	enum:boost::regex_constants::flag_type_
normalize	/usr/include/boost/filesystem/path.hpp	/^    path&  normalize()              { return m_normalize(); }$/;"	f	class:boost::filesystem::path	access:public	signature:()
normalize	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path normalize(boost::filesystem::path& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path& p)
nosubs	/usr/include/boost/regex/v4/regbase.hpp	/^      nosubs = 1 << 22,                                 \/\/ don't mark sub-expressions$/;"	e	enum:boost::regbase::flag_type_
nosubs	/usr/include/boost/regex/v4/regbase.hpp	/^      nosubs = ::boost::regbase::nosubs,$/;"	e	enum:boost::regex_constants::flag_type_
nosubs	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::nosubs;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
nosubs	/usr/include/boost/xpressive/regex_constants.hpp	/^    nosubs      = 1 << 2,   \/\/\/< Specifies that when a regular expression is matched against a$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
not_avail	/usr/include/boost/system/linux_error.hpp	/^        not_avail = ENAVAIL,$/;"	e	enum:boost::system::linux_error::linux_errno
not_a_directory	/usr/include/boost/system/error_code.hpp	/^        not_a_directory = ENOTDIR,$/;"	e	enum:boost::system::errc::errc_t
not_a_locale	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    struct not_a_locale {};$/;"	s	namespace:boost::xpressive::detail
not_a_socket	/usr/include/boost/system/error_code.hpp	/^        not_a_socket = ENOTSOCK,$/;"	e	enum:boost::system::errc::errc_t
not_a_stream	/usr/include/boost/system/error_code.hpp	/^        not_a_stream = ENOSTR,$/;"	e	enum:boost::system::errc::errc_t
not_connected	/usr/include/boost/system/error_code.hpp	/^        not_connected = ENOTCONN,$/;"	e	enum:boost::system::errc::errc_t
not_dos_disk	/usr/include/boost/system/windows_error.hpp	/^        not_dos_disk = ERROR_NOT_DOS_DISK,$/;"	e	enum:boost::system::windows_error::windows_error_code
not_dot_newline	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_newline;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
not_dot_newline	/usr/include/boost/xpressive/regex_constants.hpp	/^    not_dot_newline     = 1 << 12,  \/\/\/< Specifies that the . metacharacter does not match the$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
not_dot_null	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_null;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
not_dot_null	/usr/include/boost/xpressive/regex_constants.hpp	/^    not_dot_null        = 1 << 11,  \/\/\/< Specifies that the . metacharacter does not match the null$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
not_enough_memory	/usr/include/boost/system/error_code.hpp	/^        not_enough_memory = ENOMEM,$/;"	e	enum:boost::system::errc::errc_t
not_enough_memory	/usr/include/boost/system/windows_error.hpp	/^        not_enough_memory = ERROR_NOT_ENOUGH_MEMORY,$/;"	e	enum:boost::system::windows_error::windows_error_code
not_named_file_type	/usr/include/boost/system/linux_error.hpp	/^        not_named_file_type= ENOTNAM,$/;"	e	enum:boost::system::linux_error::linux_errno
not_null_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    bool not_null_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
not_ready	/usr/include/boost/system/windows_error.hpp	/^        not_ready = ERROR_NOT_READY,$/;"	e	enum:boost::system::windows_error::windows_error_code
not_recoverable	/usr/include/boost/system/linux_error.hpp	/^        not_recoverable = ENOTRECOVERABLE,$/;"	e	enum:boost::system::linux_error::linux_errno
not_same_device	/usr/include/boost/system/windows_error.hpp	/^        not_same_device = ERROR_NOT_SAME_DEVICE,$/;"	e	enum:boost::system::windows_error::windows_error_code
not_supported	/usr/include/boost/system/error_code.hpp	/^        not_supported = ENOTSUP,$/;"	e	enum:boost::system::errc::errc_t
not_unique	/usr/include/boost/system/linux_error.hpp	/^        not_unique = ENOTUNIQ,$/;"	e	enum:boost::system::linux_error::linux_errno
now	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now(system::error_code & ec);$/;"	p	class:boost::chrono::steady_clock	access:public	signature:(system::error_code & ec)
now	/usr/include/boost/chrono/system_clocks.hpp	/^      static BOOST_CHRONO_INLINE time_point  now(system::error_code & ec);$/;"	p	class:boost::chrono::system_clock	access:public	signature:(system::error_code & ec)
no_anode	/usr/include/boost/system/linux_error.hpp	/^        no_anode= ENOANO,$/;"	e	enum:boost::system::linux_error::linux_errno
no_bk_refs	/usr/include/boost/regex/v4/regbase.hpp	/^      no_bk_refs = 1 << 8,                        \/\/ \\d not allowed$/;"	e	enum:boost::regbase::flag_type_
no_block_device	/usr/include/boost/system/linux_error.hpp	/^        no_block_device = ENOTBLK,$/;"	e	enum:boost::system::linux_error::linux_errno
no_buffer_space	/usr/include/boost/system/error_code.hpp	/^        no_buffer_space = ENOBUFS,$/;"	e	enum:boost::system::errc::errc_t
no_char_classes	/usr/include/boost/regex/v4/regbase.hpp	/^      no_char_classes = 1 << 8,                   \/\/ [[:CLASS:]] not allowed$/;"	e	enum:boost::regbase::flag_type_
no_char_classes	/usr/include/boost/regex/v4/regbase.hpp	/^      no_char_classes = ::boost::regbase::no_char_classes,$/;"	e	enum:boost::regex_constants::flag_type_
no_child_process	/usr/include/boost/system/error_code.hpp	/^        no_child_process = ECHILD,$/;"	e	enum:boost::system::errc::errc_t
no_csi	/usr/include/boost/system/linux_error.hpp	/^        no_csi = ENOCSI,$/;"	e	enum:boost::system::linux_error::linux_errno
no_empty_expressions	/usr/include/boost/regex/v4/regbase.hpp	/^      no_empty_expressions = 1 << 24,                   \/\/ no empty expressions allowed$/;"	e	enum:boost::regbase::flag_type_
no_empty_expressions	/usr/include/boost/regex/v4/regbase.hpp	/^      no_empty_expressions = ::boost::regbase::no_empty_expressions,$/;"	e	enum:boost::regex_constants::flag_type_
no_escape_in_lists	/usr/include/boost/regex/v4/regbase.hpp	/^      no_escape_in_lists = 1 << 16,                     \/\/ '\\' not special inside [...]$/;"	e	enum:boost::regbase::flag_type_
no_escape_in_lists	/usr/include/boost/regex/v4/regbase.hpp	/^      no_escape_in_lists = ::boost::regbase::no_escape_in_lists,$/;"	e	enum:boost::regex_constants::flag_type_
no_except	/usr/include/boost/regex/v4/regbase.hpp	/^      no_except = 1 << 18,                              \/\/ no exception on error$/;"	e	enum:boost::regbase::flag_type_
no_except	/usr/include/boost/regex/v4/regbase.hpp	/^      no_except = ::boost::regbase::no_except,$/;"	e	enum:boost::regex_constants::flag_type_
no_intervals	/usr/include/boost/regex/v4/regbase.hpp	/^      no_intervals = 1 << 9,                      \/\/ {x,y} not allowed$/;"	e	enum:boost::regbase::flag_type_
no_intervals	/usr/include/boost/regex/v4/regbase.hpp	/^      no_intervals = ::boost::regbase::no_intervals,$/;"	e	enum:boost::regex_constants::flag_type_
no_key	/usr/include/boost/system/linux_error.hpp	/^        no_key = ENOKEY,$/;"	e	enum:boost::system::linux_error::linux_errno
no_link	/usr/include/boost/system/error_code.hpp	/^        no_link = ENOLINK,$/;"	e	enum:boost::system::errc::errc_t
no_lock_available	/usr/include/boost/system/error_code.hpp	/^        no_lock_available = ENOLCK,$/;"	e	enum:boost::system::errc::errc_t
no_medium	/usr/include/boost/system/linux_error.hpp	/^        no_medium = ENOMEDIUM,$/;"	e	enum:boost::system::linux_error::linux_errno
no_message	/usr/include/boost/system/error_code.hpp	/^        no_message = ENOMSG,$/;"	e	enum:boost::system::errc::errc_t
no_message_available	/usr/include/boost/system/error_code.hpp	/^        no_message_available = ENODATA,$/;"	e	enum:boost::system::errc::errc_t
no_mod_m	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_m = 1 << 10,                         \/\/ disable Perl m modifier$/;"	e	enum:boost::regbase::flag_type_
no_mod_m	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_m = ::boost::regbase::no_mod_m,$/;"	e	enum:boost::regex_constants::flag_type_
no_mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_s = 1 << 13,                         \/\/ force s modifier off (overrides match_not_dot_newline)$/;"	e	enum:boost::regbase::flag_type_
no_mod_s	/usr/include/boost/regex/v4/regbase.hpp	/^      no_mod_s = ::boost::regbase::no_mod_s,$/;"	e	enum:boost::regex_constants::flag_type_
no_more_files	/usr/include/boost/system/windows_error.hpp	/^        no_more_files = ERROR_NO_MORE_FILES,$/;"	e	enum:boost::system::windows_error::windows_error_code
no_net	/usr/include/boost/system/cygwin_error.hpp	/^        no_net = ENONET,$/;"	e	enum:boost::system::cygwin_error::cygwin_errno
no_network	/usr/include/boost/system/linux_error.hpp	/^        no_network = ENONET,$/;"	e	enum:boost::system::linux_error::linux_errno
no_package	/usr/include/boost/system/cygwin_error.hpp	/^        no_package = ENOPKG,$/;"	e	enum:boost::system::cygwin_error::cygwin_errno
no_package	/usr/include/boost/system/linux_error.hpp	/^        no_package = ENOPKG,$/;"	e	enum:boost::system::linux_error::linux_errno
no_perl_ex	/usr/include/boost/regex/v4/regbase.hpp	/^      no_perl_ex = 1 << 9,                        \/\/ disable perl extensions$/;"	e	enum:boost::regbase::flag_type_
no_perms	/usr/include/boost/filesystem/operations.hpp	/^    no_perms = 0,       \/\/ file_not_found is no_perms rather than perms_not_known$/;"	e	enum:boost::filesystem::perms
no_protocol_option	/usr/include/boost/system/error_code.hpp	/^        no_protocol_option = ENOPROTOOPT,$/;"	e	enum:boost::system::errc::errc_t
no_push	/usr/include/boost/filesystem/operations.hpp	/^    void no_push(bool value=true)$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(bool value=true)
no_push_pending	/usr/include/boost/filesystem/operations.hpp	/^    bool no_push_pending() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
no_push_request	/usr/include/boost/filesystem/operations.hpp	/^    bool no_push_request() const { return no_push_pending(); }$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
no_scale	/usr/include/boost/units/heterogeneous_system.hpp	/^typedef dimensionless_type no_scale;$/;"	t	namespace:boost::units
no_share	/usr/include/boost/system/cygwin_error.hpp	/^        no_share = ENOSHARE$/;"	e	enum:boost::system::cygwin_error::cygwin_errno
no_space_on_device	/usr/include/boost/system/error_code.hpp	/^        no_space_on_device = ENOSPC,$/;"	e	enum:boost::system::errc::errc_t
no_stream_resources	/usr/include/boost/system/error_code.hpp	/^        no_stream_resources = ENOSR,$/;"	e	enum:boost::system::errc::errc_t
no_such_device	/usr/include/boost/system/error_code.hpp	/^        no_such_device = ENODEV,$/;"	e	enum:boost::system::errc::errc_t
no_such_device_or_address	/usr/include/boost/system/error_code.hpp	/^        no_such_device_or_address = ENXIO,$/;"	e	enum:boost::system::errc::errc_t
no_such_file_or_directory	/usr/include/boost/system/error_code.hpp	/^        no_such_file_or_directory = ENOENT,$/;"	e	enum:boost::system::errc::errc_t
no_such_process	/usr/include/boost/system/error_code.hpp	/^        no_such_process = ESRCH,$/;"	e	enum:boost::system::errc::errc_t
no_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char no_type;$/;"	t	namespace:boost::re_detail
no_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef char (&no_type)[2];$/;"	t	struct:boost::xpressive::op::insert::result	access:public
npos	/usr/include/boost/regex/v4/cregex.hpp	/^   static const std::size_t npos;$/;"	m	class:boost::RegEx	access:public
null_regex_traits	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    null_regex_traits(locale_type = locale_type())$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type = locale_type())
null_regex_traits	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^struct null_regex_traits$/;"	s	namespace:boost::xpressive
n_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    int n_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
obj	/usr/include/boost/regex/v4/protected_call.hpp	/^   T* obj;$/;"	m	class:boost::re_detail::concrete_protected_call	access:private
object_cache	/usr/include/boost/regex/pending/object_cache.hpp	/^class object_cache$/;"	c	namespace:boost
offset_any	/usr/include/boost/regex/icu.hpp	/^      offset_any = U_CHAR_CATEGORY_COUNT+5,$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_ascii	/usr/include/boost/regex/icu.hpp	/^      offset_ascii = U_CHAR_CATEGORY_COUNT+6,$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_blank	/usr/include/boost/regex/icu.hpp	/^      offset_blank = U_CHAR_CATEGORY_COUNT,$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_horizontal	/usr/include/boost/regex/icu.hpp	/^      offset_horizontal = U_CHAR_CATEGORY_COUNT+7,$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_space	/usr/include/boost/regex/icu.hpp	/^      offset_space = U_CHAR_CATEGORY_COUNT+1,$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_type	/usr/include/boost/regex/v4/states.hpp	/^union offset_type$/;"	u	namespace:boost::re_detail
offset_underscore	/usr/include/boost/regex/icu.hpp	/^      offset_underscore = U_CHAR_CATEGORY_COUNT+3,$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_unicode	/usr/include/boost/regex/icu.hpp	/^      offset_unicode = U_CHAR_CATEGORY_COUNT+4,$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_vertical	/usr/include/boost/regex/icu.hpp	/^      offset_vertical = U_CHAR_CATEGORY_COUNT+8$/;"	e	enum:boost::icu_regex_traits::__anon1
offset_xdigit	/usr/include/boost/regex/icu.hpp	/^      offset_xdigit = U_CHAR_CATEGORY_COUNT+2,$/;"	e	enum:boost::icu_regex_traits::__anon1
off_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::off_type off_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
ofstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ofstream<char> ofstream;$/;"	t	namespace:boost::filesystem
ok_for_partial_matches	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual bool ok_for_partial_matches() const { return true; }$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:() const
op	/usr/include/boost/xpressive/regex_actions.hpp	/^    namespace op$/;"	n	namespace:boost::xpressive
open	/usr/include/boost/filesystem/fstream.hpp	/^      open(const path& p, std::ios_base::openmode mode) $/;"	f	class:boost::filesystem::basic_filebuf	access:public	signature:(const path& p, std::ios_base::openmode mode)
open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p)
open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p)
open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p)
open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
open	/usr/include/boost/filesystem/fstream.hpp	/^    void open(const path& p, std::ios_base::openmode mode)$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:(const path& p, std::ios_base::openmode mode)
open	/usr/include/boost/regex/v4/fileiter.hpp	/^   void open(const char* file);$/;"	p	class:boost::re_detail::mapfile	access:public	signature:(const char* file)
open_failed	/usr/include/boost/system/windows_error.hpp	/^        open_failed = ERROR_OPEN_FAILED,$/;"	e	enum:boost::system::windows_error::windows_error_code
operation_canceled	/usr/include/boost/system/error_code.hpp	/^        operation_canceled = ECANCELED,$/;"	e	enum:boost::system::errc::errc_t
operation_in_progress	/usr/include/boost/system/error_code.hpp	/^        operation_in_progress = EINPROGRESS,$/;"	e	enum:boost::system::errc::errc_t
operation_not_permitted	/usr/include/boost/system/error_code.hpp	/^        operation_not_permitted = EPERM,$/;"	e	enum:boost::system::errc::errc_t
operation_not_supported	/usr/include/boost/system/error_code.hpp	/^        operation_not_supported = EOPNOTSUPP,$/;"	e	enum:boost::system::errc::errc_t
operation_would_block	/usr/include/boost/system/error_code.hpp	/^        operation_would_block = EWOULDBLOCK,$/;"	e	enum:boost::system::errc::errc_t
operator !	/usr/include/boost/system/error_code.hpp	/^      bool operator!() const  \/\/ true if no error$/;"	f	class:boost::system::error_code	access:public	signature:() const
operator !	/usr/include/boost/system/error_code.hpp	/^      bool operator!() const  \/\/ true if no error$/;"	f	class:boost::system::error_condition	access:public	signature:() const
operator !=	/usr/include/boost/filesystem/operations.hpp	/^    bool operator!=(const file_status& rhs) const { return !(*this == rhs); }$/;"	f	class:boost::filesystem::file_status	access:public	signature:(const file_status& rhs) const
operator !=	/usr/include/boost/filesystem/operations.hpp	/^  bool operator!=(const directory_entry& rhs) {return m_path != rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path& lhs, const path& rhs)              {return lhs.compare(rhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path& lhs, const path::string_type& rhs) {return lhs.compare(rhs) != 0;} $/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::string_type& rhs)
operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path& lhs, const path::value_type* rhs)  {return lhs.compare(rhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::value_type* rhs)
operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path::string_type& lhs, const path& rhs) {return rhs.compare(lhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::string_type& lhs, const path& rhs)
operator !=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator!=(const path::value_type* lhs, const path& rhs)  {return rhs.compare(lhs) != 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::value_type* lhs, const path& rhs)
operator !=	/usr/include/boost/regex/concepts.hpp	/^   bool operator!=(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
operator !=	/usr/include/boost/regex/concepts.hpp	/^bool operator != (const allocator_architype<T>&, const allocator_architype<T>&);$/;"	p	signature:(const allocator_architype<T>&, const allocator_architype<T>&)
operator !=	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator != (const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
operator !=	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator != (const directory_iterator& f1, const directory_iterator& f2)$/;"	f	class:boost::re_detail::directory_iterator	access:friend	signature:(const directory_iterator& f1, const directory_iterator& f2)
operator !=	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator != (const file_iterator& f1, const file_iterator& f2)$/;"	f	class:boost::re_detail::file_iterator	access:friend	signature:(const file_iterator& f1, const file_iterator& f2)
operator !=	/usr/include/boost/regex/v4/match_results.hpp	/^   bool operator!=(const match_results& that)const$/;"	f	class:boost::match_results	access:public	signature:(const match_results& that) const
operator !=	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool operator!=(const regex_iterator& that)const$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that) const
operator !=	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool operator!=(const regex_token_iterator& that)const$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that) const
operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool BOOST_REGEX_CALL operator !=(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
operator !=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator != (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
operator !=	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool operator!=(const u32regex_iterator& that)const$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that) const
operator !=	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool operator!=(const u32regex_token_iterator& that)const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that) const
operator !=	/usr/include/boost/system/error_code.hpp	/^      bool operator!=(const error_category & rhs) const { return this != &rhs; }$/;"	f	class:boost::system::error_category	access:public	signature:(const error_category & rhs) const
operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_code & lhs,$/;"	f	namespace:boost::system	signature:( const error_code & lhs, const error_code & rhs )
operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_code & lhs,$/;"	f	namespace:boost::system	signature:( const error_code & lhs, const error_condition & rhs )
operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_condition & lhs,$/;"	f	namespace:boost::system	signature:( const error_condition & lhs, const error_code & rhs )
operator !=	/usr/include/boost/system/error_code.hpp	/^    inline bool operator!=( const error_condition & lhs,$/;"	f	namespace:boost::system	signature:( const error_condition & lhs, const error_condition & rhs )
operator !=	/usr/include/boost/xpressive/regex_iterator.hpp	/^    friend bool operator !=(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
operator !=	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    friend bool operator !=(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
operator !=	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool operator !=(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
operator !=	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    bool operator !=(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
operator !=	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    bool operator !=(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
operator &	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator&(match_flags m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1, match_flags m2)
operator &	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator &(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
operator &	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator &(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
operator &=	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags& operator&=(match_flags& m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags& m1, match_flags m2)
operator ()	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                operator()( $/;"	f	struct:boost::algorithm::detail::find_regexF	access:public	signature:( ForwardIteratorT Begin, ForwardIteratorT End ) const
operator ()	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                result_type operator()( $/;"	f	struct:boost::algorithm::detail::regex_formatF	access:public	signature:( const regex_search_result<InputIteratorT>& Replace ) const
operator ()	/usr/include/boost/iostreams/filter/regex.hpp	/^        string_type operator() (const match_type& match) const$/;"	f	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public	signature:(const match_type& match) const
operator ()	/usr/include/boost/regex/concepts.hpp	/^   const char_type* operator()(const M&)const$/;"	f	struct:boost::functor1	access:public	signature:(const M&) const
operator ()	/usr/include/boost/regex/concepts.hpp	/^   O operator()(const M& \/*m*\/, O i)const$/;"	f	struct:boost::functor2	access:public	signature:(const M& , O i) const
operator ()	/usr/include/boost/regex/concepts.hpp	/^   O operator()(const M& \/*m*\/, O i, regex_constants::match_flag_type)const$/;"	f	struct:boost::functor3	access:public	signature:(const M& , O i, regex_constants::match_flag_type) const
operator ()	/usr/include/boost/regex/concepts.hpp	/^   std::vector<char_type> operator()(const M&)const$/;"	f	struct:boost::functor1b	access:public	signature:(const M&) const
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f)$/;"	f	struct:boost::re_detail::format_functor3	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f)
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())$/;"	f	struct:boost::re_detail::format_functor_container	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())$/;"	f	struct:boost::re_detail::format_functor_c_string	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits& t = Traits())
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)$/;"	f	struct:boost::re_detail::format_functor2	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)$/;"	f	struct:boost::re_detail::format_functor3	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type f, const Traits&)
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type \/*f*\/)$/;"	f	struct:boost::re_detail::format_functor1	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type )
operator ()	/usr/include/boost/regex/v4/regex_format.hpp	/^   OutputIter operator()(const Match& m, OutputIter i, boost::regex_constants::match_flag_type \/*f*\/)$/;"	f	struct:boost::re_detail::format_functor2	access:public	signature:(const Match& m, OutputIter i, boost::regex_constants::match_flag_type )
operator ()	/usr/include/boost/regex/v4/regex_split.hpp	/^   bool operator()(const match_results<iterator_type>& what);$/;"	p	class:boost::re_detail::split_pred	access:public	signature:(const match_results<iterator_type>& what)
operator ()	/usr/include/boost/regex/v4/regex_split.hpp	/^bool split_pred<OutputIterator, charT, Traits1, Alloc1>::operator()$/;"	f	class:boost::re_detail::split_pred	signature:(const match_results<iterator_type>& what)
operator ()	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual bool operator ()(match_state<BidiIter> &state) const = 0;$/;"	p	struct:boost::xpressive::detail::finder	access:public	signature:(match_state<BidiIter> &state) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            bool operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::matched	access:public	signature:(Sub const &sub) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            Expr const & operator ()(MatchResults &what, Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::BindArg	access:public	signature:(MatchResults &what, Expr const &expr) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            int operator()(mark_placeholder m) const$/;"	f	struct:boost::xpressive::detail::mark_nbr	access:public	signature:(mark_placeholder m) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            std::pair<First, Second> operator()(First const &first, Second const &second) const$/;"	f	struct:boost::xpressive::op::make_pair	access:public	signature:(First const &first, Second const &second) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T &operator()(boost::reference_wrapper<T> r) const$/;"	f	struct:boost::xpressive::op::unwrap_reference	access:public	signature:(boost::reference_wrapper<T> r) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()() const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:() const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(csub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(csub_match const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(ssub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(ssub_match const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(sub_match<BidiIter> const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(sub_match<BidiIter> const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(Value const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::const_cast_	access:public	signature:(Value const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::dynamic_cast_	access:public	signature:(Value const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::static_cast_	access:public	signature:(Value const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(wcsub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(wcsub_match const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            T operator()(wssub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(wssub_match const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Cont::const_reference operator()(Cont const &c, Idx idx) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont const &c, Idx idx) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Cont::reference operator()(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Pair::first_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::first	access:public	signature:(Pair const &p) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Pair::second_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::second	access:public	signature:(Pair const &p) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename result<back(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::back	access:public	signature:(Sequence &seq) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename result<front(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::front	access:public	signature:(Sequence &seq) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename result<top(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::top	access:public	signature:(Sequence &seq) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Sub::difference_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::length	access:public	signature:(Sub const &sub) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            typename Sub::string_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::str	access:public	signature:(Sub const &sub) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()() const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:() const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop	access:public	signature:(Sequence &seq) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_back	access:public	signature:(Sequence &seq) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_front	access:public	signature:(Sequence &seq) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push	access:public	signature:(Sequence &seq, Value const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_back	access:public	signature:(Sequence &seq, Value const &val) const
operator ()	/usr/include/boost/xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_front	access:public	signature:(Sequence &seq, Value const &val) const
operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::skip_primitives::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param ) const
operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^        int operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::mark_number	access:public	signature:(Expr const &expr) const
operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^        int operator ()(Subs &subs, int i) const$/;"	f	struct:boost::xpressive::detail::push_back	access:public	signature:(Subs &subs, int i) const
operator ()	/usr/include/boost/xpressive/regex_primitives.hpp	/^        operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Expr const &expr) const
operator *	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator*() { return *this; }$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:()
operator *	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator*() { return *this; }$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:()
operator *	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   const utf16_output_iterator& operator*()const$/;"	f	class:boost::utf16_output_iterator	access:public	signature:() const
operator *	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   const utf8_output_iterator& operator*()const$/;"	f	class:boost::utf8_output_iterator	access:public	signature:() const
operator *	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* operator*() { return path(); }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
operator *	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* operator*() { return path(); }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:()
operator *	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator*() { return *this; }$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:()
operator *	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::regex_iterator	access:public	signature:() const
operator *	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::regex_token_iterator	access:public	signature:() const
operator *	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::u32regex_iterator	access:public	signature:() const
operator *	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const value_type& operator*()const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:() const
operator *	/usr/include/boost/xpressive/regex_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
operator *	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const * s)
operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (const sub_match<RandomAccessIterator>& m1,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m1, const sub_match<RandomAccessIterator>& m2)
operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
operator +	/usr/include/boost/regex/v4/sub_match.hpp	/^operator + (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
operator ++	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator++() { return *this; }$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator++(int) { return *this; }$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator++() { return *this; }$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator++(int) { return *this; }$/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator& operator++()$/;"	f	class:boost::utf16_output_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator& operator++(int)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator& operator++()$/;"	f	class:boost::utf8_output_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator& operator++(int)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator operator++(int);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator& operator++() { next(); return *this; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator operator++(int);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator& operator++() { next(); return *this; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::size_t operator++() { return ++count; }$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
operator ++	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator++() { return *this; }$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator++(int) { return *this; }$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator operator++(int)$/;"	f	class:boost::regex_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator& operator++()$/;"	f	class:boost::regex_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator operator++(int)$/;"	f	class:boost::regex_token_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator& operator++()$/;"	f	class:boost::regex_token_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator operator++(int)$/;"	f	class:boost::u32regex_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator& operator++()$/;"	f	class:boost::u32regex_iterator	access:public	signature:()
operator ++	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator operator++(int)$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator& operator++()$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:()
operator ++	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
operator ++	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(int)
operator ++	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
operator ++	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(int)
operator +=	/usr/include/boost/filesystem/path.hpp	/^    operator+=(CharT c)$/;"	f	class:boost::filesystem::path	access:public	signature:(CharT c)
operator +=	/usr/include/boost/filesystem/path.hpp	/^    operator+=(Source const& source)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source)
operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(const path& p)         {m_pathname += p.m_pathname; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(const path& p)
operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(const string_type& s)  {m_pathname += s; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(const string_type& s)
operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(const value_type* ptr) {m_pathname += ptr; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr)
operator +=	/usr/include/boost/filesystem/path.hpp	/^    path& operator+=(value_type c)          {m_pathname += c; return *this;}$/;"	f	class:boost::filesystem::path	access:public	signature:(value_type c)
operator ->	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::regex_iterator	access:public	signature:() const
operator ->	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::regex_token_iterator	access:public	signature:() const
operator ->	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::u32regex_iterator	access:public	signature:() const
operator ->	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const value_type* operator->()const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:() const
operator ->	/usr/include/boost/xpressive/regex_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
operator ->	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
operator /	/usr/include/boost/filesystem/path.hpp	/^  inline path operator\/(const path& lhs, const path& rhs)  { return path(lhs) \/= rhs; }$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
operator /=	/usr/include/boost/filesystem/path.hpp	/^    operator\/=(Source const& source)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source)
operator /=	/usr/include/boost/filesystem/path.hpp	/^    path& operator\/=(const path& p);$/;"	p	class:boost::filesystem::path	access:public	signature:(const path& p)
operator /=	/usr/include/boost/filesystem/path.hpp	/^    path& operator\/=(const value_type* ptr);$/;"	p	class:boost::filesystem::path	access:public	signature:(const value_type* ptr)
operator <	/usr/include/boost/filesystem/operations.hpp	/^  bool operator< (const directory_entry& rhs) {return m_path < rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
operator <	/usr/include/boost/filesystem/path.hpp	/^    friend bool operator<(const path& lhs, const path& rhs);$/;"	p	class:boost::filesystem::path	access:friend	signature:(const path& lhs, const path& rhs)
operator <	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator<(const path& lhs, const path& rhs)  {return lhs.compare(rhs) < 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
operator <	/usr/include/boost/regex/concepts.hpp	/^   bool operator<(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
operator <	/usr/include/boost/regex/v4/basic_regex.hpp	/^      bool operator < (const name& other)const$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(const name& other) const
operator <	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator<(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
operator <	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool operator<(const cpp_regex_traits_base& b)const$/;"	f	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const cpp_regex_traits_base& b) const
operator <	/usr/include/boost/regex/v4/fileiter.hpp	/^inline bool operator < (const directory_iterator&, const directory_iterator&)$/;"	f	namespace:boost::re_detail	signature:(const directory_iterator&, const directory_iterator&)
operator <	/usr/include/boost/regex/v4/fileiter.hpp	/^inline bool operator < (const file_iterator&, const file_iterator&)$/;"	f	namespace:boost::re_detail	signature:(const file_iterator&, const file_iterator&)
operator <	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   bool operator < (const character_pointer_range& r)const$/;"	f	struct:boost::re_detail::character_pointer_range	access:public	signature:(const character_pointer_range& r) const
operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator<(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
operator <	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator < (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
operator <	/usr/include/boost/system/error_code.hpp	/^      bool operator<( const error_category & rhs ) const$/;"	f	class:boost::system::error_category	access:public	signature:( const error_category & rhs ) const
operator <	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator<( const error_code & lhs,$/;"	f	class:boost::system::error_code	access:friend	signature:( const error_code & lhs, const error_code & rhs )
operator <	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator<( const error_condition & lhs,$/;"	f	class:boost::system::error_condition	access:friend	signature:( const error_condition & lhs, const error_condition & rhs )
operator <<	/usr/include/boost/filesystem/path.hpp	/^  operator<<(std::basic_ostream<Char, Traits>& os, const path& p)$/;"	f	namespace:boost::filesystem	signature:(std::basic_ostream<Char, Traits>& os, const path& p)
operator <<	/usr/include/boost/regex/v4/basic_regex.hpp	/^   operator << (std::basic_ostream<charT, traits>& os, $/;"	f	namespace:boost	signature:(std::basic_ostream<charT, traits>& os, const basic_regex<charT, traits2>& e)
operator <<	/usr/include/boost/regex/v4/basic_regex.hpp	/^std::ostream& operator << (std::ostream& os, const basic_regex<char, traits>& e)$/;"	f	namespace:boost	signature:(std::ostream& os, const basic_regex<char, traits>& e)
operator <<	/usr/include/boost/regex/v4/match_results.hpp	/^   operator << (std::basic_ostream<charT, traits>& os,$/;"	f	namespace:boost	signature:(std::basic_ostream<charT, traits>& os, const match_results<BidiIterator, Allocator>& s)
operator <<	/usr/include/boost/regex/v4/match_results.hpp	/^std::ostream& operator << (std::ostream& os,$/;"	f	namespace:boost	signature:(std::ostream& os, const match_results<BidiIterator, Allocator>& s)
operator <<	/usr/include/boost/regex/v4/states.hpp	/^std::ostream& operator<<(std::ostream&, syntax_element_type);$/;"	p	namespace:boost::re_detail	signature:(std::ostream&, syntax_element_type)
operator <<	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator << (std::basic_ostream<charT, traits>& os,$/;"	f	namespace:boost	signature:(std::basic_ostream<charT, traits>& os, const sub_match<RandomAccessIterator>& s)
operator <<	/usr/include/boost/regex/v4/sub_match.hpp	/^std::ostream& operator << (std::ostream& os,$/;"	f	namespace:boost	signature:(std::ostream& os, const sub_match<RandomAccessIterator>& s)
operator <<	/usr/include/boost/system/error_code.hpp	/^      operator<< (std::basic_ostream<charT,traits>& os, error_code ec)$/;"	f	namespace:boost::system	signature:(std::basic_ostream<charT,traits>& os, error_code ec)
operator <<	/usr/include/boost/units/systems/detail/constants.hpp	/^std::basic_ostream<Char,Traits>& operator<<(std::basic_ostream<Char,Traits>& os,const constant<Y>&)$/;"	f	namespace:boost::units	signature:(std::basic_ostream<Char,Traits>& os,const constant<Y>&)
operator <<	/usr/include/boost/units/systems/detail/constants.hpp	/^std::basic_ostream<Char,Traits>& operator<<(std::basic_ostream<Char,Traits>& os,const physical_constant<Y>& val)$/;"	f	namespace:boost::units	signature:(std::basic_ostream<Char,Traits>& os,const physical_constant<Y>& val)
operator <=	/usr/include/boost/filesystem/operations.hpp	/^  bool operator<=(const directory_entry& rhs) {return m_path <= rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
operator <=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator<=(const path& lhs, const path& rhs) {return !(rhs < lhs);}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
operator <=	/usr/include/boost/regex/concepts.hpp	/^   bool operator<=(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
operator <=	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator<=(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator<=(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
operator <=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator <= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
operator =	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result& operator=( const regex_search_result& Other )$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( const regex_search_result& Other )
operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_filebuf& operator=(const basic_filebuf&);$/;"	p	class:boost::filesystem::basic_filebuf	access:private	signature:(const basic_filebuf&)
operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_fstream & operator=(const basic_fstream&);$/;"	p	class:boost::filesystem::basic_fstream	access:private	signature:(const basic_fstream&)
operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_ifstream& operator=(const basic_ifstream&);$/;"	p	class:boost::filesystem::basic_ifstream	access:private	signature:(const basic_ifstream&)
operator =	/usr/include/boost/filesystem/fstream.hpp	/^    const basic_ofstream& operator=(const basic_ofstream&);$/;"	p	class:boost::filesystem::basic_ofstream	access:private	signature:(const basic_ofstream&)
operator =	/usr/include/boost/filesystem/path.hpp	/^    operator=(Source const& source)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source)
operator =	/usr/include/boost/filesystem/path.hpp	/^    path& operator=(const path& p)$/;"	f	class:boost::filesystem::path	access:public	signature:(const path& p)
operator =	/usr/include/boost/filesystem/path.hpp	/^    path& operator=(const value_type* ptr)  \/\/ required in case ptr overlaps *this$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* ptr)
operator =	/usr/include/boost/regex/concepts.hpp	/^   BaseRegexConcept& operator=(const BaseRegexConcept&);$/;"	p	struct:boost::BaseRegexConcept	access:public	signature:(const BaseRegexConcept&)
operator =	/usr/include/boost/regex/concepts.hpp	/^   BoostRegexConcept& operator=(const BoostRegexConcept&);$/;"	p	struct:boost::BoostRegexConcept	access:public	signature:(const BoostRegexConcept&)
operator =	/usr/include/boost/regex/concepts.hpp	/^   char_architype& operator=(const char_architype&);$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&)
operator =	/usr/include/boost/regex/concepts.hpp	/^   RegexConcept& operator=(const RegexConcept&);$/;"	p	struct:boost::RegexConcept	access:public	signature:(const RegexConcept&)
operator =	/usr/include/boost/regex/concepts.hpp	/^   RegexTraitsConcept& operator=(RegexTraitsConcept&);$/;"	p	struct:boost::RegexTraitsConcept	access:private	signature:(RegexTraitsConcept&)
operator =	/usr/include/boost/regex/concepts.hpp	/^   regex_traits_architype& operator=(const regex_traits_architype&);$/;"	p	struct:boost::regex_traits_architype	access:private	signature:(const regex_traits_architype&)
operator =	/usr/include/boost/regex/icu.hpp	/^   icu_regex_traits& operator=(const icu_regex_traits&);$/;"	p	class:boost::icu_regex_traits	access:private	signature:(const icu_regex_traits&)
operator =	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator& operator=(UChar v) $/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:(UChar v)
operator =	/usr/include/boost/regex/mfc.hpp	/^   mfc_string_out_iterator& operator=(B v) $/;"	f	class:boost::re_detail::mfc_string_out_iterator	access:public	signature:(B v)
operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator& operator=(const utf16_output_iterator& that)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(const utf16_output_iterator& that)
operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator& operator=(const utf8_output_iterator& that)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(const utf8_output_iterator& that)
operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void operator=(boost::uint32_t val)const$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(boost::uint32_t val) const
operator =	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void operator=(boost::uint32_t val)const$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(boost::uint32_t val) const
operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const basic_regex& that)$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& that)
operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const charT* ptr)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* ptr)
operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const std::basic_string<charT, ST, SA>& p)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT, ST, SA>& p)
operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   basic_regex& BOOST_REGEX_CALL operator=(const std::basic_string<charT>& p)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT>& p)
operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression& BOOST_REGEX_CALL operator=(const reg_expression& that)$/;"	f	class:boost::reg_expression	access:public	signature:(const reg_expression& that)
operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression& BOOST_REGEX_CALL operator=(const std::basic_string<charT, ST, SA>& p)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT, ST, SA>& p)
operator =	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression& BOOST_REGEX_CALL operator=(const std::basic_string<charT>& p)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT>& p)
operator =	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   basic_regex_creator& operator=(const basic_regex_creator&);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(const basic_regex_creator&)
operator =	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   basic_regex_parser& operator=(const basic_regex_parser&);$/;"	p	class:boost::re_detail::basic_regex_parser	access:private	signature:(const basic_regex_parser&)
operator =	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   parser_buf& operator=(const parser_buf&);$/;"	p	class:boost::re_detail::parser_buf	access:private	signature:(const parser_buf&)
operator =	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx& operator=(const char* p);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p)
operator =	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx& operator=(const RegEx& o);$/;"	p	class:boost::RegEx	access:public	signature:(const RegEx& o)
operator =	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx& operator=(const std::string& s){ return this->operator=(s.c_str()); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s)
operator =	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   c_regex_traits& operator=(const c_regex_traits&);$/;"	p	struct:boost::c_regex_traits	access:private	signature:(const c_regex_traits&)
operator =	/usr/include/boost/regex/v4/fileiter.hpp	/^   directory_iterator& operator=(const directory_iterator& other);$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:(const directory_iterator& other)
operator =	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator& operator=(const file_iterator&);$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:(const file_iterator&)
operator =	/usr/include/boost/regex/v4/match_results.hpp	/^   match_results& operator=(const match_results& m)$/;"	f	class:boost::match_results	access:public	signature:(const match_results& m)
operator =	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   perl_matcher& operator=(const perl_matcher&)$/;"	f	class:boost::re_detail::perl_matcher	access:private	signature:(const perl_matcher&)
operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   basic_regex_formatter& operator=(const basic_regex_formatter&);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(const basic_regex_formatter&)
operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor1& operator=(const format_functor1&);$/;"	p	struct:boost::re_detail::format_functor1	access:private	signature:(const format_functor1&)
operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor2& operator=(const format_functor2&);$/;"	p	struct:boost::re_detail::format_functor2	access:private	signature:(const format_functor2&)
operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor3& operator=(const format_functor3&);$/;"	p	struct:boost::re_detail::format_functor3	access:private	signature:(const format_functor3&)
operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_container& operator=(const format_functor_container&);$/;"	p	struct:boost::re_detail::format_functor_container	access:private	signature:(const format_functor_container&)
operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   format_functor_c_string& operator=(const format_functor_c_string&);$/;"	p	struct:boost::re_detail::format_functor_c_string	access:private	signature:(const format_functor_c_string&)
operator =	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator& operator=(typename S::value_type v) $/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:(typename S::value_type v)
operator =	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator& operator=(const regex_iterator& that)$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that)
operator =	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator_implementation& operator=(const regex_iterator_implementation&);$/;"	p	class:boost::regex_iterator_implementation	access:private	signature:(const regex_iterator_implementation&)
operator =	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator& operator=(const regex_token_iterator& that)$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that)
operator =	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation& operator=(const regex_token_iterator_implementation&);$/;"	p	class:boost::regex_token_iterator_implementation	access:private	signature:(const regex_token_iterator_implementation&)
operator =	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits_wrapper& operator=(const regex_traits_wrapper&);$/;"	p	struct:boost::regex_traits_wrapper	access:private	signature:(const regex_traits_wrapper&)
operator =	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match& operator=(const sub_match& that)$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that)
operator =	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator& operator=(const u32regex_iterator& that)$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that)
operator =	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator_implementation& operator=(const u32regex_iterator_implementation&);$/;"	p	class:boost::u32regex_iterator_implementation	access:private	signature:(const u32regex_iterator_implementation&)
operator =	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator& operator=(const u32regex_token_iterator& that)$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that)
operator =	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation& operator=(const u32regex_token_iterator_implementation&);$/;"	p	class:boost::u32regex_token_iterator_implementation	access:private	signature:(const u32regex_token_iterator_implementation&)
operator =	/usr/include/boost/system/error_code.hpp	/^          operator=( ErrorCodeEnum val )$/;"	f	class:boost::system::error_code	access:public	signature:( ErrorCodeEnum val )
operator =	/usr/include/boost/system/error_code.hpp	/^          operator=( ErrorConditionEnum val )$/;"	f	class:boost::system::error_condition	access:public	signature:( ErrorConditionEnum val )
operator =	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
operator =	/usr/include/boost/xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
operator =	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    regex_impl &operator =(regex_impl const &);$/;"	p	struct:boost::xpressive::detail::regex_impl	access:private	signature:(regex_impl const &)
operator =	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator =(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
operator =	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator =(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
operator ==	/usr/include/boost/filesystem/operations.hpp	/^    bool operator==(const file_status& rhs) const { return type() == rhs.type() && $/;"	f	class:boost::filesystem::file_status	access:public	signature:(const file_status& rhs) const
operator ==	/usr/include/boost/filesystem/operations.hpp	/^  bool operator==(const directory_entry& rhs) {return m_path == rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path& lhs, const path& rhs)              {return lhs.compare(rhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path& lhs, const path::string_type& rhs) {return lhs.compare(rhs) == 0;} $/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::string_type& rhs)
operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path& lhs, const path::value_type* rhs)  {return lhs.compare(rhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path::value_type* rhs)
operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path::string_type& lhs, const path& rhs) {return rhs.compare(lhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::string_type& lhs, const path& rhs)
operator ==	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator==(const path::value_type* lhs, const path& rhs)  {return rhs.compare(lhs) == 0;}$/;"	f	namespace:boost::filesystem	signature:(const path::value_type* lhs, const path& rhs)
operator ==	/usr/include/boost/regex/concepts.hpp	/^   bool operator==(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
operator ==	/usr/include/boost/regex/concepts.hpp	/^bool operator == (const allocator_architype<T>&, const allocator_architype<T>&);$/;"	p	signature:(const allocator_architype<T>&, const allocator_architype<T>&)
operator ==	/usr/include/boost/regex/v4/basic_regex.hpp	/^      bool operator == (const name& other)const$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(const name& other) const
operator ==	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator==(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
operator ==	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   bool operator==(const cpp_regex_traits_base& b)const$/;"	f	struct:boost::re_detail::cpp_regex_traits_base	access:public	signature:(const cpp_regex_traits_base& b) const
operator ==	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator == (const directory_iterator& f1, const directory_iterator& f2)$/;"	f	class:boost::re_detail::directory_iterator	access:friend	signature:(const directory_iterator& f1, const directory_iterator& f2)
operator ==	/usr/include/boost/regex/v4/fileiter.hpp	/^   friend inline bool operator == (const file_iterator& f1, const file_iterator& f2)$/;"	f	class:boost::re_detail::file_iterator	access:friend	signature:(const file_iterator& f1, const file_iterator& f2)
operator ==	/usr/include/boost/regex/v4/match_results.hpp	/^   bool operator==(const match_results& that)const$/;"	f	class:boost::match_results	access:public	signature:(const match_results& that) const
operator ==	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   bool operator==(const regex_iterator& that)const$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that) const
operator ==	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   bool operator==(const regex_token_iterator& that)const$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that) const
operator ==	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   bool operator == (const character_pointer_range& r)const$/;"	f	struct:boost::re_detail::character_pointer_range	access:public	signature:(const character_pointer_range& r) const
operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator==(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
operator ==	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator == (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
operator ==	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   bool operator==(const u32regex_iterator& that)const$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that) const
operator ==	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   bool operator==(const u32regex_token_iterator& that)const$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that) const
operator ==	/usr/include/boost/system/error_code.hpp	/^      bool operator==(const error_category & rhs) const { return this == &rhs; }$/;"	f	class:boost::system::error_category	access:public	signature:(const error_category & rhs) const
operator ==	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator==( const error_code & lhs,$/;"	f	class:boost::system::error_code	access:friend	signature:( const error_code & lhs, const error_code & rhs )
operator ==	/usr/include/boost/system/error_code.hpp	/^      inline friend bool operator==( const error_condition & lhs,$/;"	f	class:boost::system::error_condition	access:friend	signature:( const error_condition & lhs, const error_condition & rhs )
operator ==	/usr/include/boost/system/error_code.hpp	/^    inline bool operator==( const error_code & code,$/;"	f	namespace:boost::system	signature:( const error_code & code, const error_condition & condition )
operator ==	/usr/include/boost/system/error_code.hpp	/^    inline bool operator==( const error_condition & condition,$/;"	f	namespace:boost::system	signature:( const error_condition & condition, const error_code & code )
operator ==	/usr/include/boost/xpressive/regex_iterator.hpp	/^    friend bool operator ==(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
operator ==	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    friend bool operator ==(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
operator ==	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    bool operator ==(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
operator ==	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    bool operator ==(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
operator ==	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    bool operator ==(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
operator >	/usr/include/boost/filesystem/operations.hpp	/^  bool operator> (const directory_entry& rhs) {return m_path > rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
operator >	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator> (const path& lhs, const path& rhs) {return rhs < lhs;}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
operator >	/usr/include/boost/regex/concepts.hpp	/^   bool operator>(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
operator >	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator>(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator>(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
operator >	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator > (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
operator >=	/usr/include/boost/filesystem/operations.hpp	/^  bool operator>=(const directory_entry& rhs) {return m_path >= rhs.m_path;} $/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const directory_entry& rhs)
operator >=	/usr/include/boost/filesystem/path.hpp	/^  inline bool operator>=(const path& lhs, const path& rhs) {return !(lhs < rhs);}$/;"	f	namespace:boost::filesystem	signature:(const path& lhs, const path& rhs)
operator >=	/usr/include/boost/regex/concepts.hpp	/^   bool operator>=(const char_architype&)const;$/;"	p	struct:boost::char_architype	access:public	signature:(const char_architype&) const
operator >=	/usr/include/boost/regex/v4/basic_regex.hpp	/^   bool BOOST_REGEX_CALL operator>=(const basic_regex& e)const$/;"	f	class:boost::basic_regex	access:public	signature:(const basic_regex& e) const
operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^   bool operator>=(const sub_match& that)const$/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that) const
operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s, const sub_match<RandomAccessIterator>& m)
operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (const sub_match<RandomAccessIterator>& m,$/;"	f	namespace:boost	signature:(const sub_match<RandomAccessIterator>& m, typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s, const sub_match<RandomAccessIterator>& m)
operator >=	/usr/include/boost/regex/v4/sub_match.hpp	/^inline bool operator >= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,$/;"	f	namespace:boost	signature:(typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s, const sub_match<RandomAccessIterator>& m)
operator >>	/usr/include/boost/filesystem/path.hpp	/^  operator>>(std::basic_istream<Char, Traits>& is, path& p)$/;"	f	namespace:boost::filesystem	signature:(std::basic_istream<Char, Traits>& is, path& p)
operator binary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator binary_fun();$/;"	p	struct:boost::re_detail::unary_binary_ternary	access:public	signature:()
operator detail::basic_mark_tag const &	/usr/include/boost/xpressive/regex_primitives.hpp	/^    operator detail::basic_mark_tag const &() const$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:() const
operator Formatter *	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator Formatter *();$/;"	p	struct:boost::re_detail::formatter_wrapper	access:public	signature:()
operator int	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator int()const;$/;"	p	struct:boost::sub_match	access:public	signature:() const
operator int	/usr/include/boost/regex/v4/sub_match.hpp	/^sub_match<BidiIterator>::operator int()const$/;"	f	class:boost::sub_match	signature:() const
operator long	/usr/include/boost/regex/concepts.hpp	/^   operator long()const;$/;"	p	struct:boost::char_architype	access:public	signature:() const
operator short	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator short()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
operator std::basic_string<value_type, T, A>	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator std::basic_string<value_type, T, A> ()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
operator std::basic_string<value_type>	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator std::basic_string<value_type> ()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
operator ternary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator ternary_fun();$/;"	p	struct:boost::re_detail::unary_binary_ternary	access:public	signature:()
operator unary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    operator unary_fun();$/;"	p	struct:boost::re_detail::unary_binary_ternary	access:public	signature:()
operator unsigned int	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator unsigned int()const;$/;"	p	struct:boost::sub_match	access:public	signature:() const
operator unsigned int	/usr/include/boost/regex/v4/sub_match.hpp	/^sub_match<BidiIterator>::operator unsigned int()const$/;"	f	class:boost::sub_match	signature:() const
operator unsigned short	/usr/include/boost/regex/v4/sub_match.hpp	/^   operator unsigned short()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
operator unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      operator unspecified_bool_type() const  \/\/ true if error$/;"	f	class:boost::system::error_code	access:public	signature:() const
operator unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      operator unspecified_bool_type() const  \/\/ true if error$/;"	f	class:boost::system::error_condition	access:public	signature:() const
operator value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    operator value_type() const    { return Base().value(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
operator value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    operator value_type() const    { return Base().value(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
operator void const*	/usr/include/boost/regex/pending/static_mutex.hpp	/^   inline operator void const*()const$/;"	f	class:boost::scoped_static_mutex_lock	access:public	signature:() const
operator []	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string operator[](int i)const { return What(i); }$/;"	f	class:boost::RegEx	access:public	signature:(int i) const
operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const charT* p) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* p) const
operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const char_type* p) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* p) const
operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const std::basic_string<charT, Traits, A>& ns) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& ns) const
operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](const std::basic_string<char_type, Traits, A>& s) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<char_type, Traits, A>& s) const
operator []	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference operator[](int sub) const$/;"	f	class:boost::match_results	access:public	signature:(int sub) const
operator []	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> &operator [](string_type const &name)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name)
operator []	/usr/include/boost/xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> const &operator [](string_type const &name) const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name) const
operator ^	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator^(match_flags m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1, match_flags m2)
operator ^	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator ^(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
operator ^	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator ^(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
operator ^=	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags& operator^=(match_flags& m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags& m1, match_flags m2)
operator |	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator|(match_flags m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1, match_flags m2)
operator |	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator |(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
operator |	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator |(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
operator |=	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags& operator|=(match_flags& m1, match_flags m2)$/;"	f	namespace:boost::regex_constants	signature:(match_flags& m1, match_flags m2)
operator ~	/usr/include/boost/regex/v4/match_flags.hpp	/^inline match_flags operator~(match_flags m1)$/;"	f	namespace:boost::regex_constants	signature:(match_flags m1)
operator ~	/usr/include/boost/xpressive/regex_constants.hpp	/^inline match_flag_type operator ~(match_flag_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b)
operator ~	/usr/include/boost/xpressive/regex_constants.hpp	/^inline syntax_option_type operator ~(syntax_option_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b)
optimize	/usr/include/boost/regex/v4/regbase.hpp	/^      optimize = 0,                                     \/\/ not really supported$/;"	e	enum:boost::regbase::flag_type_
optimize	/usr/include/boost/regex/v4/regbase.hpp	/^      optimize = ::boost::regbase::optimize,$/;"	e	enum:boost::regex_constants::flag_type_
optimize	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::optimize;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
optimize	/usr/include/boost/xpressive/regex_constants.hpp	/^    optimize    = 1 << 3,   \/\/\/< Specifies that the regular expression engine should pay more$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
optional	/usr/include/boost/xpressive/regex_primitives.hpp	/^optional(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
other	/usr/include/boost/regex/concepts.hpp	/^      typedef allocator_architype<U> other;$/;"	t	struct:allocator_architype::rebind	access:public
others_all	/usr/include/boost/filesystem/operations.hpp	/^    others_all = 07,    \/\/ S_IRWXO, Read, write, execute\/search by others$/;"	e	enum:boost::filesystem::perms
others_exe	/usr/include/boost/filesystem/operations.hpp	/^    others_exe = 01,    \/\/ S_IXOTH, Execute\/search permission, others$/;"	e	enum:boost::filesystem::perms
others_read	/usr/include/boost/filesystem/operations.hpp	/^    others_read = 04,   \/\/ S_IROTH, Read permission, others$/;"	e	enum:boost::filesystem::perms
others_write	/usr/include/boost/filesystem/operations.hpp	/^    others_write = 02,  \/\/ S_IWOTH, Write permission, others$/;"	e	enum:boost::filesystem::perms
out	/usr/include/boost/regex/icu.hpp	/^   U_NAMESPACE_QUALIFIER UnicodeString* out;$/;"	m	class:boost::re_detail::unicode_string_out_iterator	access:private
out	/usr/include/boost/regex/mfc.hpp	/^   ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>* out;$/;"	m	class:boost::re_detail::mfc_string_out_iterator	access:private
out	/usr/include/boost/regex/v4/regex_format.hpp	/^   S* out;$/;"	m	class:boost::re_detail::string_out_iterator	access:private
out	/usr/include/boost/regex/v4/regex_format.hpp	/^   static O out;$/;"	m	struct:boost::re_detail::format_traits_imp	access:private
OutIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef output_iterator_archetype<value_type> OutIterator;$/;"	t	struct:boost::BaseRegexConcept	access:public
OutIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef output_iterator_archetype<value_type> OutIterator;$/;"	t	struct:boost::RegexConcept	access:public
outofmemory	/usr/include/boost/system/windows_error.hpp	/^        outofmemory = ERROR_OUTOFMEMORY,$/;"	e	enum:boost::system::windows_error::windows_error_code
OutputIterator	/usr/include/boost/regex/concepts.hpp	/^   typedef output_iterator_archetype<value_type> OutputIterator;$/;"	t	struct:boost::BoostRegexConcept	access:public
output_copy	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_copy,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
output_lower	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_lower,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
output_next_lower	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_next_lower,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
output_next_upper	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_next_upper,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
output_none	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_none$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
output_state	/usr/include/boost/regex/v4/regex_format.hpp	/^   enum output_state$/;"	g	class:boost::re_detail::basic_regex_formatter	access:private
output_upper	/usr/include/boost/regex/v4/regex_format.hpp	/^      output_upper,$/;"	e	enum:boost::re_detail::basic_regex_formatter::output_state
out_of_paper	/usr/include/boost/system/windows_error.hpp	/^        out_of_paper = ERROR_OUT_OF_PAPER,$/;"	e	enum:boost::system::windows_error::windows_error_code
overflow_error_if_not_zero	/usr/include/boost/regex/v4/regex_workaround.hpp	/^   inline void overflow_error_if_not_zero(std::size_t i)$/;"	f	namespace:boost::re_detail	signature:(std::size_t i)
owner_all	/usr/include/boost/filesystem/operations.hpp	/^    owner_all = 0700,   \/\/ S_IRWXU, Read, write, execute\/search by owner$/;"	e	enum:boost::filesystem::perms
owner_dead	/usr/include/boost/system/error_code.hpp	/^        owner_dead = EOWNERDEAD,$/;"	e	enum:boost::system::errc::errc_t
owner_dead	/usr/include/boost/system/linux_error.hpp	/^        owner_dead = EOWNERDEAD,$/;"	e	enum:boost::system::linux_error::linux_errno
owner_exe	/usr/include/boost/filesystem/operations.hpp	/^    owner_exe = 0100,   \/\/ S_IXUSR, Execute\/search permission, owner$/;"	e	enum:boost::filesystem::perms
owner_read	/usr/include/boost/filesystem/operations.hpp	/^    owner_read = 0400,  \/\/ S_IRUSR, Read permission, owner$/;"	e	enum:boost::filesystem::perms
owner_write	/usr/include/boost/filesystem/operations.hpp	/^    owner_write = 0200, \/\/ S_IWUSR, Write permission, owner$/;"	e	enum:boost::filesystem::perms
P	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        typedef typename point_type<GeometryTag, G>::type P;$/;"	t	struct:boost::geometry::core_dispatch::coordinate_system	access:public
p	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void* p;$/;"	m	union:boost::re_detail::padding	access:public
p	/usr/include/boost/regex/v4/states.hpp	/^   re_syntax_base*   p;$/;"	m	union:boost::re_detail::offset_type	access:public
p1	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   const charT* p1;$/;"	m	struct:boost::re_detail::character_pointer_range	access:public
p2	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^   const charT* p2;$/;"	m	struct:boost::re_detail::character_pointer_range	access:public
padding	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^union padding$/;"	u	namespace:boost::re_detail
padding1	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      std::size_t padding1;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
padding2	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      std::ptrdiff_t padding2;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
padding3	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      void* padding3;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3$/;"	s	namespace:boost::re_detail
padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<16>$/;"	s	namespace:boost::re_detail
padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<2>$/;"	s	namespace:boost::re_detail
padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<4>$/;"	s	namespace:boost::re_detail
padding3	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^struct padding3<8>$/;"	s	namespace:boost::re_detail
padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 1$/;"	e	enum:boost::re_detail::padding3::__anon11
padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 15$/;"	e	enum:boost::re_detail::padding3::__anon14
padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 3$/;"	e	enum:boost::re_detail::padding3::__anon12
padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 7$/;"	e	enum:boost::re_detail::padding3::__anon10
padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_mask = 7$/;"	e	enum:boost::re_detail::padding3::__anon13
padding_mask	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   padding_mask = padding3<sizeof(padding)>::padding_mask$/;"	e	enum:boost::re_detail::__anon15
padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 16,$/;"	e	enum:boost::re_detail::padding3::__anon14
padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 2,$/;"	e	enum:boost::re_detail::padding3::__anon11
padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 4,$/;"	e	enum:boost::re_detail::padding3::__anon12
padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 8,$/;"	e	enum:boost::re_detail::padding3::__anon10
padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^      padding_size = 8,$/;"	e	enum:boost::re_detail::padding3::__anon13
padding_size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   padding_size = padding3<sizeof(padding)>::padding_size,$/;"	e	enum:boost::re_detail::__anon15
parent_path	/usr/include/boost/filesystem/path.hpp	/^    path  parent_path() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
parse	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void parse(const charT* p1, const charT* p2, unsigned flags);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(const charT* p1, const charT* p2, unsigned flags)
parse	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::parse(const charT* p1, const charT* p2, unsigned l_flags)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(const charT* p1, const charT* p2, unsigned l_flags)
parse	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    parse(ScannerT const& scan) const$/;"	f	struct:boost::spirit::rxstrlit	access:public	signature:(ScannerT const& scan) const
parser_buf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   parser_buf() : base_type() { setbuf(0, 0); }$/;"	f	class:boost::re_detail::parser_buf	access:public	signature:()
parser_buf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   parser_buf(const parser_buf&);$/;"	p	class:boost::re_detail::parser_buf	access:private	signature:(const parser_buf&)
parser_buf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^class parser_buf : public ::std::basic_streambuf<charT, traits>$/;"	c	namespace:boost::re_detail	inherits:::std::basic_streambuf
parser_proc_type	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   typedef bool (basic_regex_parser::*parser_proc_type)();$/;"	t	class:boost::re_detail::basic_regex_parser	access:private
parse_all	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_all();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_all	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_all()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_alt	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_alt();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_alt	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_alt()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_alternates	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_alternates(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_atom	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_atom(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_backref	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_backref();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_backref	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_backref()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_basic	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_basic();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_basic	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_basic()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_basic_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_basic_escape();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_basic_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_basic_escape()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_charset	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_charset(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_escape	/usr/include/boost/xpressive/regex_compiler.hpp	/^    escape_value parse_escape(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_extended	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_extended();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_extended	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_extended()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_extended_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_extended_escape();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_extended_escape	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_extended_escape()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_group	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_group(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_inner_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_inner_set(basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(basic_char_set<charT, traits>& char_set)
parse_inner_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_inner_set(basic_char_set<charT, traits>& char_set)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(basic_char_set<charT, traits>& char_set)
parse_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_literal();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_literal()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_literal	/usr/include/boost/xpressive/regex_compiler.hpp	/^    string_type parse_literal(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_match_any	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_match_any();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_match_any	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_match_any()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_open_paren	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_open_paren();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_open_paren	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_open_paren()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_options	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   regex_constants::syntax_option_type parse_options();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_options	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^regex_constants::syntax_option_type basic_regex_parser<charT, traits>::parse_options()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_perl_extension	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_perl_extension();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_perl_extension	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_perl_extension()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_QE	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_QE();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_QE	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_QE()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_quant	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_quant(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_quote_meta	/usr/include/boost/xpressive/regex_compiler.hpp	/^    string_type parse_quote_meta(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_repeat	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_repeat(std::size_t low = 0, std::size_t high = (std::numeric_limits<std::size_t>::max)());$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(std::size_t low = 0, std::size_t high = (std::numeric_limits<std::size_t>::max)())
parse_repeat	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_repeat(std::size_t low, std::size_t high)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(std::size_t low, std::size_t high)
parse_repeat_range	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_repeat_range(bool isbasic);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(bool isbasic)
parse_repeat_range	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_repeat_range(bool isbasic)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(bool isbasic)
parse_sequence	/usr/include/boost/xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_sequence(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool parse_set();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
parse_set	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::parse_set()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
parse_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   void parse_set_literal(basic_char_set<charT, traits>& char_set);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(basic_char_set<charT, traits>& char_set)
parse_set_literal	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^void basic_regex_parser<charT, traits>::parse_set_literal(basic_char_set<charT, traits>& char_set)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(basic_char_set<charT, traits>& char_set)
path	/usr/include/boost/filesystem/operations.hpp	/^  const boost::filesystem::path&  path() const               {return m_path;}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:() const
path	/usr/include/boost/filesystem/path.hpp	/^    path(){}                                          $/;"	f	class:boost::filesystem::path	access:public	signature:()
path	/usr/include/boost/filesystem/path.hpp	/^    path(const path& p) : m_pathname(p.m_pathname) {}$/;"	f	class:boost::filesystem::path	access:public	signature:(const path& p)
path	/usr/include/boost/filesystem/path.hpp	/^    path(const std::basic_string<value_type>& s) : m_pathname(s) {}$/;"	f	class:boost::filesystem::path	access:public	signature:(const std::basic_string<value_type>& s)
path	/usr/include/boost/filesystem/path.hpp	/^    path(const value_type* s) : m_pathname(s) {}$/;"	f	class:boost::filesystem::path	access:public	signature:(const value_type* s)
path	/usr/include/boost/filesystem/path.hpp	/^    path(InputIterator begin, InputIterator end)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end)
path	/usr/include/boost/filesystem/path.hpp	/^    path(InputIterator begin, InputIterator end, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(InputIterator begin, InputIterator end, const codecvt_type& cvt)
path	/usr/include/boost/filesystem/path.hpp	/^    path(Source const& source, const codecvt_type& cvt)$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, const codecvt_type& cvt)
path	/usr/include/boost/filesystem/path.hpp	/^    path(Source const& source,$/;"	f	class:boost::filesystem::path	access:public	signature:(Source const& source, typename boost::enable_if<path_traits::is_pathable< typename boost::decay<Source>::type> >::type* =0)
path	/usr/include/boost/filesystem/path.hpp	/^  class BOOST_FILESYSTEM_DECL path$/;"	c	namespace:boost::filesystem
path	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* path()const { return _path; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:() const
path	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* path()const { return _path; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:() const
path1	/usr/include/boost/filesystem/operations.hpp	/^    const path& path1() const$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:() const
path2	/usr/include/boost/filesystem/operations.hpp	/^    const path& path2() const$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:() const
path_not_found	/usr/include/boost/system/windows_error.hpp	/^        path_not_found = ERROR_PATH_NOT_FOUND,$/;"	e	enum:boost::system::windows_error::windows_error_code
path_traits	/usr/include/boost/filesystem/path_traits.hpp	/^namespace path_traits {$/;"	n	namespace:boost::filesystem
pdata	/usr/include/boost/regex/v4/cregex.hpp	/^   re_detail::RegExData* pdata;$/;"	m	class:boost::RegEx	access:private
pdata	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::regex_iterator	access:private
pdata	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::regex_token_iterator	access:private
pdata	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::u32regex_iterator	access:private
pdata	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   pimpl pdata;$/;"	m	class:boost::u32regex_token_iterator	access:private
period	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::period                     period;$/;"	t	class:boost::chrono::steady_clock	access:public
period	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::period                     period;$/;"	t	class:boost::chrono::system_clock	access:public
perl	/usr/include/boost/regex/v4/regbase.hpp	/^      perl = normal,$/;"	e	enum:boost::regbase::flag_type_
perl	/usr/include/boost/regex/v4/regbase.hpp	/^      perl = normal,$/;"	e	enum:boost::regex_constants::flag_type_
perl_matcher	/usr/include/boost/regex/v4/instances.hpp	/^template class BOOST_REGEX_DECL ::boost::re_detail::perl_matcher<BOOST_REGEX_CHAR_T const *, match_results< const BOOST_REGEX_CHAR_T* >::allocator_type BOOST_REGEX_TRAITS_T >;$/;"	m	class:boost::BOOST_REGEX_DECL::boost::re_detail	typeref:class:boost::BOOST_REGEX_DECL::boost::re_detail::
perl_matcher	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   perl_matcher(BidiIterator first, BidiIterator end, $/;"	f	class:boost::re_detail::perl_matcher	access:public	signature:(BidiIterator first, BidiIterator end, match_results<BidiIterator, Allocator>& what, const basic_regex<char_type, traits>& e, match_flag_type f, BidiIterator l_base)
perl_matcher	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   perl_matcher(const perl_matcher& that)$/;"	f	class:boost::re_detail::perl_matcher	access:private	signature:(const perl_matcher& that)
perl_matcher	/usr/include/boost/regex/v4/perl_matcher.hpp	/^class perl_matcher$/;"	c	namespace:boost::re_detail
perl_syntax_group	/usr/include/boost/regex/v4/regbase.hpp	/^      perl_syntax_group = 0,                      \/\/ default$/;"	e	enum:boost::regbase::flag_type_
permeability	/usr/include/boost/units/systems/si/permeability.hpp	/^typedef unit<permeability_dimension,si::system>    permeability;$/;"	t	namespace:boost::units::si
permissions	/usr/include/boost/filesystem/operations.hpp	/^    perms      permissions() const                { return m_perms; } $/;"	f	class:boost::filesystem::file_status	access:public	signature:() const
permissions	/usr/include/boost/filesystem/operations.hpp	/^    void       permissions(perms prms)            { m_perms = prms; }$/;"	f	class:boost::filesystem::file_status	access:public	signature:(perms prms)
permissions	/usr/include/boost/filesystem/operations.hpp	/^    void permissions(const path& p, perms prms, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, perms prms, system::error_code* ec=0)
permissions	/usr/include/boost/filesystem/operations.hpp	/^  void permissions(const path& p, perms prms)$/;"	f	namespace:boost::filesystem	signature:(const path& p, perms prms)
permissions	/usr/include/boost/filesystem/operations.hpp	/^  void permissions(const path& p, perms prms, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, perms prms, system::error_code& ec)
permissions_present	/usr/include/boost/filesystem/operations.hpp	/^  inline bool permissions_present(file_status f)$/;"	f	namespace:boost::filesystem	signature:(file_status f)
permission_denied	/usr/include/boost/system/error_code.hpp	/^        permission_denied = EACCES,$/;"	e	enum:boost::system::errc::errc_t
permittivity	/usr/include/boost/units/systems/si/permittivity.hpp	/^typedef unit<permittivity_dimension,si::system>    permittivity;$/;"	t	namespace:boost::units::si
perms	/usr/include/boost/filesystem/operations.hpp	/^  enum perms$/;"	g	namespace:boost::filesystem
perms_mask	/usr/include/boost/filesystem/operations.hpp	/^    perms_mask = all_all|set_uid_on_exe|set_gid_on_exe|sticky_bit,  \/\/ 07777$/;"	e	enum:boost::filesystem::perms
perms_not_known	/usr/include/boost/filesystem/operations.hpp	/^    perms_not_known = 0xFFFF, \/\/ present when directory_entry cache not loaded$/;"	e	enum:boost::filesystem::perms
physical_constant	/usr/include/boost/units/systems/detail/constants.hpp	/^struct physical_constant $/;"	s	namespace:boost::units
pimpl	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::regex_iterator	access:private
pimpl	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::regex_token_iterator	access:private
pimpl	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::u32regex_iterator	access:private
pimpl	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef shared_ptr<impl> pimpl;$/;"	t	class:boost::u32regex_token_iterator	access:private
pimpl_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_impl<BidiIter> const *pimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
pimpl_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<detail::tracking_ptr<detail::regex_impl<BidiIter> > >, 0> pimpl_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
placeholder	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct placeholder$/;"	s	namespace:boost::xpressive
plane_angle	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<plane_angle_dimension,system>           plane_angle;            \/\/\/< abstract unit of plane angle$/;"	t	namespace:boost::units::abstract
plane_angle	/usr/include/boost/units/systems/angle/degrees.hpp	/^typedef unit<plane_angle_dimension,system>      plane_angle;           \/\/\/< angle degree unit constant$/;"	t	namespace:boost::units::degree
plane_angle	/usr/include/boost/units/systems/angle/gradians.hpp	/^typedef unit<plane_angle_dimension,system>      plane_angle;          \/\/\/< angle gradian unit constant$/;"	t	namespace:boost::units::gradian
plane_angle	/usr/include/boost/units/systems/angle/revolutions.hpp	/^typedef unit<plane_angle_dimension,system>      plane_angle;          \/\/\/< angle revolution unit constant$/;"	t	namespace:boost::units::revolution
plane_angle	/usr/include/boost/units/systems/si/plane_angle.hpp	/^typedef unit<plane_angle_dimension,si::system>      plane_angle;$/;"	t	namespace:boost::units::si
plane_angle_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct plane_angle_unit_tag : base_unit<plane_angle_unit_tag, plane_angle_dimension, -23> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
plus_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct plus_impl<boost::units::heterogeneous_system_dim_tag, boost::units::heterogeneous_system_dim_tag>$/;"	s	namespace:boost::mpl
pointer	/usr/include/boost/regex/concepts.hpp	/^   typedef T* pointer;$/;"	t	class:allocator_architype	access:public
pointer	/usr/include/boost/regex/icu.hpp	/^   typedef value_type* pointer;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
pointer	/usr/include/boost/regex/mfc.hpp	/^   typedef value_type* pointer;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
pointer	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t*                       pointer;$/;"	t	class:boost::utf16_output_iterator	access:public
pointer	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t*                       pointer;$/;"	t	class:boost::utf8_output_iterator	access:public
pointer	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char**              pointer;$/;"	t	class:boost::re_detail::directory_iterator	access:public
pointer	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char**              pointer;$/;"	t	class:boost::re_detail::file_iterator	access:public
pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef const T* pointer;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T* pointer;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::pointer           pointer;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
pointer	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef value_type*                   pointer;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
pointer	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef value_type* pointer;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
pointer	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::regex_iterator	access:public
pointer	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   typedef unsigned char*        pointer;$/;"	t	class:boost::re_detail::raw_storage	access:public
pointer	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::regex_token_iterator	access:public
pointer	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::u32regex_iterator	access:public
pointer	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          const value_type*                                       pointer;$/;"	t	class:boost::u32regex_token_iterator	access:public
pointer	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
pointer	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
pointer_construct	/usr/include/boost/regex/v4/regex_workaround.hpp	/^inline void pointer_construct(T* p, const T& t)$/;"	f	namespace:boost::re_detail	signature:(T* p, const T& t)
pointer_destroy	/usr/include/boost/regex/v4/regex_workaround.hpp	/^inline void pointer_destroy(T* p)$/;"	f	namespace:boost::re_detail	signature:(T* p)
pointer_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct pointer_iterator_traits$/;"	s	namespace:boost::re_detail
pointer_type	/usr/include/boost/regex/concepts.hpp	/^   typedef const value_type* pointer_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
pointer_type	/usr/include/boost/regex/concepts.hpp	/^   typedef const value_type* pointer_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
pointer_type	/usr/include/boost/regex/concepts.hpp	/^   typedef const value_type* pointer_type;$/;"	t	struct:boost::RegexConcept	access:public
pop	/usr/include/boost/filesystem/operations.hpp	/^      void pop();$/;"	p	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public	signature:()
pop	/usr/include/boost/filesystem/operations.hpp	/^    void pop()$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:()
pop	/usr/include/boost/filesystem/operations.hpp	/^    void recur_dir_itr_imp::pop()$/;"	f	class:boost::filesystem::detail::recur_dir_itr_imp	signature:()
pop	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct pop$/;"	s	namespace:boost::xpressive::op
pop	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::pop>::type const pop = {{}};$/;"	m	class:boost::xpressive::function
pop_back	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct pop_back$/;"	s	namespace:boost::xpressive::op
pop_back	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::pop_back>::type const pop_back = {{}};$/;"	m	class:boost::xpressive::function
pop_front	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct pop_front$/;"	s	namespace:boost::xpressive::op
pop_front	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::pop_front>::type const pop_front = {{}};$/;"	m	class:boost::xpressive::function
portable_directory_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_directory_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
portable_file_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_file_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
portable_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
portable_posix_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool portable_posix_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
position	/usr/include/boost/regex/pattern_except.hpp	/^   std::ptrdiff_t position()const$/;"	f	class:boost::regex_error	access:public	signature:() const
Position	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Position(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(const charT* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* sub) const
position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(const char_type* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* sub) const
position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(const std::basic_string<charT, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& sub) const
position	/usr/include/boost/regex/v4/match_results.hpp	/^   difference_type position(size_type sub = 0) const$/;"	f	class:boost::match_results	access:public	signature:(size_type sub = 0) const
position	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator position;$/;"	m	class:boost::re_detail::perl_matcher	access:private
position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   BidiIterator position;$/;"	m	struct:boost::re_detail::saved_position	access:public
positive	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   bool positive;$/;"	m	struct:boost::re_detail::saved_assertion	access:public
posix_category	/usr/include/boost/system/error_code.hpp	/^    static const error_category &  posix_category = generic_category();$/;"	m	namespace:boost::system
posix_time	/usr/include/boost/date_time/posix_time/posix_time_system.hpp	/^namespace posix_time { $/;"	n	namespace:boost
posix_time_system	/usr/include/boost/date_time/posix_time/posix_time_system.hpp	/^  typedef date_time::split_timedate_system<posix_time_system_config, 1000000000> posix_time_system;$/;"	t	namespace:boost::posix_time
POSIX_TIME_SYSTEM_HPP___	/usr/include/boost/date_time/posix_time/posix_time_system.hpp	2;"	d
possible_large_file_size_support	/usr/include/boost/filesystem/operations.hpp	/^    BOOST_FILESYSTEM_DECL bool possible_large_file_size_support();$/;"	p	namespace:boost::filesystem::detail	signature:()
pos_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef typename base_type::pos_type pos_type;$/;"	t	class:boost::re_detail::parser_buf	access:private
power	/usr/include/boost/units/systems/cgs/power.hpp	/^typedef unit<power_dimension,cgs::system>    power;$/;"	t	namespace:boost::units::cgs
power	/usr/include/boost/units/systems/si/power.hpp	/^typedef unit<power_dimension,si::system>     power;$/;"	t	namespace:boost::units::si
power_area	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef multiply_typeof_helper<power,area>::type power_area;$/;"	t	namespace:boost::units::si::constants::codata
power_area_over_solid_angle	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^typedef divide_typeof_helper<power_area,solid_angle>::type power_area_over_solid_angle;$/;"	t	namespace:boost::units::si::constants::codata
power_over_area_temperature_4	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^        >::type power_over_area_temperature_4;$/;"	t	namespace:boost::units::si::constants::codata
power_typeof_helper	/usr/include/boost/units/systems/detail/constants.hpp	/^struct power_typeof_helper<constant<T1>, static_rational<N,D> >$/;"	s	namespace:boost::units
preferred_separator	/usr/include/boost/filesystem/path.hpp	/^    BOOST_STATIC_CONSTEXPR value_type      preferred_separator = L'\\\\';$/;"	m	class:boost::filesystem::path	access:public
prefix	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference prefix() const$/;"	f	class:boost::match_results	access:public	signature:() const
pressure	/usr/include/boost/units/systems/cgs/pressure.hpp	/^typedef unit<pressure_dimension,cgs::system>     pressure;$/;"	t	namespace:boost::units::cgs
pressure	/usr/include/boost/units/systems/si/pressure.hpp	/^typedef unit<pressure_dimension,si::system>      pressure;$/;"	t	namespace:boost::units::si
preturn_address	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const re_syntax_base* preturn_address;$/;"	m	struct:boost::re_detail::recursion_info	access:public
preturn_address	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   const re_syntax_base* preturn_address;$/;"	m	struct:boost::re_detail::saved_recursion	access:public
Primitives	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct Primitives$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
print	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const print = {{"print", false}};$/;"	m	class:boost::xpressive::proto::terminal
print_regex_library_info	/usr/include/boost/regex/config.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL print_regex_library_info();$/;"	p	signature:()
probe_leading_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void probe_leading_repeat(re_syntax_base* state);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* state)
probe_leading_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::probe_leading_repeat(re_syntax_base* state)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* state)
proc	/usr/include/boost/regex/v4/protected_call.hpp	/^   proc_type proc;$/;"	m	class:boost::re_detail::concrete_protected_call	access:private
proc_type	/usr/include/boost/regex/v4/protected_call.hpp	/^   typedef bool (T::*proc_type)();$/;"	t	class:boost::re_detail::concrete_protected_call	access:public
protected_call	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool protected_call(protected_proc_type);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(protected_proc_type)
protected_call	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^inline bool perl_matcher<BidiIterator, Allocator, traits>::protected_call($/;"	f	class:boost::re_detail::perl_matcher	signature:( protected_proc_type proc)
protected_proc_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef bool (perl_matcher::*protected_proc_type)();$/;"	t	class:boost::re_detail::perl_matcher	access:private
protocol_error	/usr/include/boost/system/error_code.hpp	/^        protocol_error = EPROTO,$/;"	e	enum:boost::system::errc::errc_t
protocol_not_supported	/usr/include/boost/system/error_code.hpp	/^        protocol_not_supported = EPROTONOSUPPORT,$/;"	e	enum:boost::system::errc::errc_t
protocol_no_supported	/usr/include/boost/system/linux_error.hpp	/^        protocol_no_supported = EPFNOSUPPORT,$/;"	e	enum:boost::system::linux_error::linux_errno
pstate	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const re_syntax_base* pstate;$/;"	m	class:boost::re_detail::perl_matcher	access:private
pstate	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   const re_syntax_base* pstate;$/;"	m	struct:boost::re_detail::saved_position	access:public
ptr	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* ptr;$/;"	m	class:boost::re_detail::directory_iterator	access:private
ptr	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* ptr;$/;"	m	class:boost::re_detail::file_iterator	access:private
punct	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const punct = {{"punct", false}};$/;"	m	class:boost::xpressive::proto::terminal
push	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void push(boost::uint32_t c)const$/;"	f	class:boost::utf8_output_iterator	access:private	signature:(boost::uint32_t c) const
push	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   void push(boost::uint32_t v)const$/;"	f	class:boost::utf16_output_iterator	access:private	signature:(boost::uint32_t v) const
push	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct push$/;"	s	namespace:boost::xpressive::op
push	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::push>::type const push = {{}};$/;"	m	class:boost::xpressive::function
push_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_alt(const re_syntax_base* ps);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const re_syntax_base* ps)
push_alt	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_alt(const re_syntax_base* ps)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const re_syntax_base* ps)
push_assertion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_assertion(const re_syntax_base* ps, bool positive);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const re_syntax_base* ps, bool positive)
push_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_assertion(const re_syntax_base* ps, bool positive)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const re_syntax_base* ps, bool positive)
push_back	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct push_back$/;"	s	namespace:boost::xpressive::op
push_back	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::push_back>::type const push_back = {{}};$/;"	m	class:boost::xpressive::function
push_back	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct push_back : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
push_front	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct push_front$/;"	s	namespace:boost::xpressive::op
push_front	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::push_front>::type const push_front = {{}};$/;"	m	class:boost::xpressive::function
push_matched_paren	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_matched_paren(int index, const sub_match<BidiIterator>& sub);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(int index, const sub_match<BidiIterator>& sub)
push_matched_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_matched_paren(int index, const sub_match<BidiIterator>& sub)$/;"	f	class:boost::re_detail::perl_matcher	signature:(int index, const sub_match<BidiIterator>& sub)
push_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_non_greedy_repeat(const re_syntax_base* ps);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(const re_syntax_base* ps)
push_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_non_greedy_repeat(const re_syntax_base* ps)$/;"	f	class:boost::re_detail::perl_matcher	signature:(const re_syntax_base* ps)
push_recursion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_recursion(int idx, const re_syntax_base* p, results_type* presults);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(int idx, const re_syntax_base* p, results_type* presults)
push_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion(int idx, const re_syntax_base* p, results_type* presults)$/;"	f	class:boost::re_detail::perl_matcher	signature:(int idx, const re_syntax_base* p, results_type* presults)
push_recursion_pop	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_recursion_pop();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
push_recursion_pop	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_pop()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
push_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_recursion_stopper();$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:()
push_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_stopper()$/;"	f	class:boost::re_detail::perl_matcher	signature:()
push_repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_repeater_count(int i, repeater_count<BidiIterator>** s);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(int i, repeater_count<BidiIterator>** s)
push_repeater_count	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_repeater_count(int i, repeater_count<BidiIterator>** s)$/;"	f	class:boost::re_detail::perl_matcher	signature:(int i, repeater_count<BidiIterator>** s)
push_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
push_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^inline void perl_matcher<BidiIterator, Allocator, traits>::push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)$/;"	f	class:boost::re_detail::perl_matcher	signature:(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
put	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   void put(void* p)$/;"	f	struct:boost::re_detail::mem_block_cache	access:public	signature:(void* p)
put	/usr/include/boost/regex/v4/regex_format.hpp	/^   void put(char_type c);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(char_type c)
put	/usr/include/boost/regex/v4/regex_format.hpp	/^   void put(const sub_match_type& sub);$/;"	p	class:boost::re_detail::basic_regex_formatter	access:private	signature:(const sub_match_type& sub)
put	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::put(char_type c)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(char_type c)
put	/usr/include/boost/regex/v4/regex_format.hpp	/^void basic_regex_formatter<OutputIterator, Results, traits, ForwardIter>::put(const sub_match_type& sub)$/;"	f	class:boost::re_detail::basic_regex_formatter	signature:(const sub_match_type& sub)
put_mem_block	/usr/include/boost/regex/config.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL put_mem_block(void*);$/;"	p	namespace:boost::re_detail	signature:(void*)
p_last	/usr/include/boost/regex/v4/regex_split.hpp	/^   iterator_type* p_last;$/;"	m	class:boost::re_detail::split_pred	access:private
p_max	/usr/include/boost/regex/v4/regex_split.hpp	/^   std::size_t* p_max;$/;"	m	class:boost::re_detail::split_pred	access:private
p_out	/usr/include/boost/regex/v4/regex_split.hpp	/^   OutputIterator* p_out;$/;"	m	class:boost::re_detail::split_pred	access:private
raise	/usr/include/boost/regex/pattern_except.hpp	/^   void raise()const;$/;"	p	class:boost::regex_error	access:public	signature:() const
raise_error	/usr/include/boost/regex/pattern_except.hpp	/^void raise_error(const traits& t, regex_constants::error_type code)$/;"	f	namespace:boost::re_detail	signature:(const traits& t, regex_constants::error_type code)
raise_logic_error	/usr/include/boost/regex/v4/match_results.hpp	/^   static void raise_logic_error()$/;"	f	class:boost::match_results	access:private	signature:()
raise_runtime_error	/usr/include/boost/regex/pattern_except.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL raise_runtime_error(const std::runtime_error& ex);$/;"	p	namespace:boost::re_detail	signature:(const std::runtime_error& ex)
range	/usr/include/boost/xpressive/regex_primitives.hpp	/^range(Char ch_min, Char ch_max)$/;"	f	class:boost::xpressive::proto::terminal	signature:(Char ch_min, Char ch_max)
ranges_begin	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator ranges_begin()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
ranges_end	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator ranges_end()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
range_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::pair<const_iterator, const_iterator> range_type;$/;"	t	class:boost::re_detail::named_subexpressions	access:public
raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   raw_storage();$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:()
raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   raw_storage(size_type n);$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:(size_type n)
raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^class BOOST_REGEX_DECL raw_storage$/;"	c	namespace:boost::re_detail
raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^inline raw_storage::raw_storage()$/;"	f	class:boost::re_detail::raw_storage	signature:()
raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^inline raw_storage::raw_storage(size_type n)$/;"	f	class:boost::re_detail::raw_storage	signature:(size_type n)
re	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const basic_regex<char_type, traits>& re;$/;"	m	class:boost::re_detail::perl_matcher	access:private
re	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   const regex_type                     re;   \/\/ the expression$/;"	m	class:boost::regex_iterator_implementation	access:private
re	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   const regex_type                     re;    \/\/ the expression$/;"	m	class:boost::regex_token_iterator_implementation	access:private
re	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   const regex_type                     re;   \/\/ the expression$/;"	m	class:boost::u32regex_iterator_implementation	access:private
re	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   const regex_type                     re;     \/\/ the expression$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
re	/usr/include/boost/xpressive/regex_algorithms.hpp	/^      , basic_regex<BidiIter> const &re$/;"	m	namespace:boost::xpressive::detail
read_fault	/usr/include/boost/system/windows_error.hpp	/^        read_fault = ERROR_READ_FAULT,$/;"	e	enum:boost::system::windows_error::windows_error_code
read_only_file_system	/usr/include/boost/system/error_code.hpp	/^        read_only_file_system = EROFS,$/;"	e	enum:boost::system::errc::errc_t
read_symlink	/usr/include/boost/filesystem/operations.hpp	/^    path read_symlink(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
read_symlink	/usr/include/boost/filesystem/operations.hpp	/^  path read_symlink(const path& p)     {return detail::read_symlink(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
read_symlink	/usr/include/boost/filesystem/operations.hpp	/^  path read_symlink(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
rebind	/usr/include/boost/regex/concepts.hpp	/^   struct rebind$/;"	s	class:allocator_architype	access:public
rebind	/usr/include/boost/regex/v4/iterator_category.hpp	/^   struct rebind$/;"	s	struct:boost::detail::is_random_imp_selector	access:public
recursion_id	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   int recursion_id;$/;"	m	struct:boost::re_detail::saved_recursion	access:public
recursion_info	/usr/include/boost/regex/v4/perl_matcher.hpp	/^struct recursion_info$/;"	s	namespace:boost::re_detail
recursion_stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::vector<recursion_info<results_type> > recursion_stack;$/;"	m	class:boost::re_detail::perl_matcher	access:private
recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    explicit recursive_directory_iterator(const path& dir_path,$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(const path& dir_path, BOOST_SCOPED_ENUM(symlink_option) opt = symlink_option::none)
recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator(){}  \/\/ creates the "end" iterator$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:()
recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator(const path& dir_path,$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(const path& dir_path, BOOST_SCOPED_ENUM(symlink_option) opt, system::error_code & ec)
recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^    recursive_directory_iterator(const path& dir_path,$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:(const path& dir_path, system::error_code & ec)
recursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^  class recursive_directory_iterator$/;"	c	namespace:boost::filesystem	inherits:boost::iterator_facade
recur_dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^      recur_dir_itr_imp() : m_level(0), m_options(symlink_option::none) {}$/;"	f	struct:boost::filesystem::detail::recur_dir_itr_imp	access:public	signature:()
recur_dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^    struct recur_dir_itr_imp$/;"	s	namespace:boost::filesystem::detail
ref	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator_ref* ref;$/;"	m	class:boost::re_detail::directory_iterator	access:private
ref	/usr/include/boost/regex/v4/fileiter.hpp	/^   file_iterator_ref* ref;$/;"	m	class:boost::re_detail::file_iterator	access:private
ref	/usr/include/boost/xpressive/regex_actions.hpp	/^    reference<T> const ref(T &t)$/;"	f	namespace:boost::xpressive	signature:(T &t)
reference	/usr/include/boost/regex/concepts.hpp	/^   typedef T& reference;$/;"	t	class:allocator_architype	access:public
reference	/usr/include/boost/regex/icu.hpp	/^   typedef value_type& reference;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
reference	/usr/include/boost/regex/mfc.hpp	/^   typedef value_type& reference;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
reference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t&                       reference;$/;"	t	class:boost::utf16_output_iterator	access:public
reference	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef boost::uint32_t&                       reference;$/;"	t	class:boost::utf8_output_iterator	access:public
reference	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef charT&                                reference;$/;"	t	class:boost::basic_regex	access:public
reference	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*&              reference;$/;"	t	class:boost::re_detail::directory_iterator	access:public
reference	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*&              reference;$/;"	t	class:boost::re_detail::file_iterator	access:public
reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef const T& reference;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T& reference;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::reference         reference;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
reference	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef value_type&                   reference;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
reference	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          const_reference                                         reference;$/;"	t	class:boost::match_results	access:public
reference	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef value_type& reference;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
reference	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::regex_iterator	access:public
reference	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::regex_token_iterator	access:public
reference	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::u32regex_iterator	access:public
reference	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          const value_type&                                       reference; $/;"	t	class:boost::u32regex_token_iterator	access:public
reference	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef typename add_reference<T>::type reference;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
reference	/usr/include/boost/xpressive/regex_actions.hpp	/^        explicit reference(T &t)$/;"	f	struct:boost::xpressive::reference	access:public	signature:(T &t)
reference	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct reference$/;"	s	namespace:boost::xpressive	inherits:proto::extends
reference	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
reference	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
regbase	/usr/include/boost/regex/v4/regbase.hpp	/^class BOOST_REGEX_DECL regbase$/;"	c	namespace:boost
regcomp	/usr/include/boost/regex/v4/cregex.hpp	174;"	d
regcomp	/usr/include/boost/regex/v4/cregex.hpp	180;"	d
regcompA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regcompA(regex_tA*, const char*, int);$/;"	p	signature:(regex_tA*, const char*, int)
regcompW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regcompW(regex_tW*, const wchar_t*, int);$/;"	p	signature:(regex_tW*, const wchar_t*, int)
regerror	/usr/include/boost/regex/v4/cregex.hpp	175;"	d
regerror	/usr/include/boost/regex/v4/cregex.hpp	181;"	d
regerrorA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL regsize_t BOOST_REGEX_CCALL regerrorA(int, const regex_tA*, char*, regsize_t);$/;"	p	signature:(int, const regex_tA*, char*, regsize_t)
regerrorW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL regsize_t BOOST_REGEX_CCALL regerrorW(int, const regex_tW*, wchar_t*, regsize_t);$/;"	p	signature:(int, const regex_tW*, wchar_t*, regsize_t)
RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   explicit RegEx(const char* c, bool icase = false);$/;"	p	class:boost::RegEx	access:public	signature:(const char* c, bool icase = false)
RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   explicit RegEx(const std::string& s, bool icase = false);$/;"	p	class:boost::RegEx	access:public	signature:(const std::string& s, bool icase = false)
RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx();$/;"	p	class:boost::RegEx	access:public	signature:()
RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   RegEx(const RegEx& o);$/;"	p	class:boost::RegEx	access:public	signature:(const RegEx& o)
RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^class BOOST_REGEX_DECL RegEx$/;"	c	namespace:boost
regex	/usr/include/boost/regex/v4/regex.hpp	/^typedef basic_regex<char, regex_traits<char> > regex;$/;"	t	namespace:boost
regex	/usr/include/boost/regex/v4/regex_fwd.hpp	/^typedef basic_regex<char, regex_traits<char> > regex;$/;"	t	namespace:boost
RegexConcept	/usr/include/boost/regex/concepts.hpp	/^   RegexConcept();$/;"	p	struct:boost::RegexConcept	access:public	signature:()
RegexConcept	/usr/include/boost/regex/concepts.hpp	/^   RegexConcept(const RegexConcept&);$/;"	p	struct:boost::RegexConcept	access:public	signature:(const RegexConcept&)
RegexConcept	/usr/include/boost/regex/concepts.hpp	/^struct RegexConcept$/;"	s	namespace:boost
regexec	/usr/include/boost/regex/v4/cregex.hpp	176;"	d
regexec	/usr/include/boost/regex/v4/cregex.hpp	182;"	d
regexecA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regexecA(const regex_tA*, const char*, regsize_t, regmatch_t*, int);$/;"	p	signature:(const regex_tA*, const char*, regsize_t, regmatch_t*, int)
regexecW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL int BOOST_REGEX_CCALL regexecW(const regex_tW*, const wchar_t*, regsize_t, regmatch_t*, int);$/;"	p	signature:(const regex_tW*, const wchar_t*, regsize_t, regmatch_t*, int)
RegexTraitsConcept	/usr/include/boost/regex/concepts.hpp	/^   RegexTraitsConcept();$/;"	p	struct:boost::RegexTraitsConcept	access:public	signature:()
RegexTraitsConcept	/usr/include/boost/regex/concepts.hpp	/^struct RegexTraitsConcept$/;"	s	namespace:boost
regex_byref_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_byref_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
regex_byref_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^    struct regex_byref_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
regex_compiler	/usr/include/boost/xpressive/regex_compiler.hpp	/^    explicit regex_compiler(RegexTraits const &traits = RegexTraits())$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(RegexTraits const &traits = RegexTraits())
regex_compiler	/usr/include/boost/xpressive/regex_compiler.hpp	/^struct regex_compiler$/;"	s	namespace:boost::xpressive
regex_constants	/usr/include/boost/regex/v4/error_type.hpp	/^namespace regex_constants{$/;"	n	namespace:boost
regex_constants	/usr/include/boost/regex/v4/match_flags.hpp	/^   namespace regex_constants{$/;"	n	namespace:boost
regex_constants	/usr/include/boost/regex/v4/regbase.hpp	/^namespace regex_constants{$/;"	n	namespace:boost
regex_constants	/usr/include/boost/regex/v4/syntax_type.hpp	/^namespace regex_constants{$/;"	n	namespace:boost
regex_constants	/usr/include/boost/tr1/regex.hpp	/^namespace regex_constants {$/;"	n	namespace:std::tr1
regex_constants	/usr/include/boost/xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
regex_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   regex_data() $/;"	f	struct:boost::re_detail::regex_data	access:public	signature:()
regex_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^   regex_data(const ::boost::shared_ptr<$/;"	f	struct:boost::re_detail::regex_data	access:public	signature:(const ::boost::shared_ptr< ::boost::regex_traits_wrapper<traits> >& t)
regex_data	/usr/include/boost/regex/v4/basic_regex.hpp	/^struct regex_data : public named_subexpressions$/;"	s	namespace:boost::re_detail	inherits:named_subexpressions
regex_domain	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	/^    struct regex_domain$/;"	s	namespace:boost::xpressive::detail	inherits:proto::domain
regex_error	/usr/include/boost/regex/pattern_except.hpp	/^   explicit regex_error(const std::string& s, regex_constants::error_type err = regex_constants::error_unknown, std::ptrdiff_t pos = 0);$/;"	p	class:boost::regex_error	access:public	signature:(const std::string& s, regex_constants::error_type err = regex_constants::error_unknown, std::ptrdiff_t pos = 0)
regex_error	/usr/include/boost/regex/pattern_except.hpp	/^   explicit regex_error(regex_constants::error_type err);$/;"	p	class:boost::regex_error	access:public	signature:(regex_constants::error_type err)
regex_error	/usr/include/boost/regex/pattern_except.hpp	/^class BOOST_REGEX_DECL regex_error : public std::runtime_error$/;"	c	namespace:boost	inherits:std::runtime_error
regex_error	/usr/include/boost/xpressive/regex_error.hpp	/^    explicit regex_error(regex_constants::error_type code, char const *str = "")$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:(regex_constants::error_type code, char const *str = )
regex_error	/usr/include/boost/xpressive/regex_error.hpp	/^struct regex_error$/;"	s	namespace:boost::xpressive	inherits:std::runtime_error,boost::exception
regex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^typedef basic_regex_filter<char>     regex_filter;$/;"	t	namespace:boost::iostreams
regex_finder	/usr/include/boost/algorithm/string/regex_find_format.hpp	/^        regex_finder($/;"	f	namespace:boost::algorithm	signature:( const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type MatchFlags=match_default )
regex_format	/usr/include/boost/regex/v4/regex_format.hpp	/^inline OutputIterator regex_format(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, const match_results<Iterator, Allocator>& m, Functor fmt, match_flag_type flags = format_all )
regex_format	/usr/include/boost/regex/v4/regex_format.hpp	/^inline std::basic_string<typename match_results<Iterator, Allocator>::char_type> regex_format(const match_results<Iterator, Allocator>& m, $/;"	f	namespace:boost	signature:(const match_results<Iterator, Allocator>& m, Functor fmt, match_flag_type flags = format_all)
regex_formatF	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                regex_formatF( const StringT& Fmt, match_flag_type Flags=format_default ) :$/;"	f	struct:boost::algorithm::detail::regex_formatF	access:public	signature:( const StringT& Fmt, match_flag_type Flags=format_default )
regex_formatF	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^            struct regex_formatF$/;"	s	namespace:boost::algorithm::detail
regex_formatter	/usr/include/boost/algorithm/string/regex_find_format.hpp	/^        regex_formatter( $/;"	f	namespace:boost::algorithm	signature:( const std::basic_string<CharT, TraitsT, AllocT>& Format, match_flag_type Flags=format_default )
regex_format_imp	/usr/include/boost/regex/v4/regex_format.hpp	/^OutputIterator regex_format_imp(OutputIterator out,$/;"	f	namespace:boost::re_detail	signature:(OutputIterator out, const match_results<Iterator, Alloc>& m, ForwardIter p1, ForwardIter p2, match_flag_type flags, const traits& t )
regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const cmatch&), const char* str, $/;"	f	namespace:boost	signature:(bool (foo)const cmatch&), const char* str, const regex& e, match_flag_type flags = match_default)
regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const match_results<std::basic_string<wchar_t>::const_iterator>&), $/;"	f	namespace:boost	signature:(bool (foo)const match_results<std::basic_string<wchar_t>::const_iterator>&), const std::basic_string<wchar_t>& s, const wregex& e, match_flag_type flags = match_default)
regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const match_results<std::string::const_iterator>&), const std::string& s,$/;"	f	namespace:boost	signature:(bool (foo)const match_results<std::string::const_iterator>&), const std::string& s, const regex& e, match_flag_type flags = match_default)
regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(bool (*foo)(const wcmatch&), const wchar_t* str, $/;"	f	namespace:boost	signature:(bool (foo)const wcmatch&), const wchar_t* str, const wregex& e, match_flag_type flags = match_default)
regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(Predicate foo, $/;"	f	namespace:boost	signature:(Predicate foo, BidiIterator first, BidiIterator last, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(Predicate foo, const charT* str, $/;"	f	namespace:boost	signature:(Predicate foo, const charT* str, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_grep	/usr/include/boost/regex/v4/regex_grep.hpp	/^inline unsigned int regex_grep(Predicate foo, const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(Predicate foo, const std::basic_string<charT, ST, SA>& s, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_id	/usr/include/boost/xpressive/basic_regex.hpp	/^    regex_id_type regex_id() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    regex_impl(regex_impl<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> const &that)
regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct regex_impl$/;"	s	namespace:boost::xpressive::detail	inherits:enable_reference_tracking
regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator(){}$/;"	f	class:boost::regex_iterator	access:public	signature:()
regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator(BidirectionalIterator a, BidirectionalIterator b, $/;"	f	class:boost::regex_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, match_flag_type m = match_default)
regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator(const regex_iterator& that)$/;"	f	class:boost::regex_iterator	access:public	signature:(const regex_iterator& that)
regex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^class regex_iterator $/;"	c	namespace:boost	inherits:std::iterator
regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
regex_iterator	/usr/include/boost/xpressive/regex_iterator.hpp	/^struct regex_iterator$/;"	s	namespace:boost::xpressive
regex_iterator_impl	/usr/include/boost/xpressive/regex_iterator.hpp	/^    regex_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags , bool not_null = false )
regex_iterator_impl	/usr/include/boost/xpressive/regex_iterator.hpp	/^struct regex_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
regex_iterator_implementation	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   regex_iterator_implementation(const regex_type* p, BidirectionalIterator last, match_flag_type f)$/;"	f	class:boost::regex_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, match_flag_type f)
regex_iterator_implementation	/usr/include/boost/regex/v4/regex_iterator.hpp	/^class regex_iterator_implementation $/;"	c	namespace:boost
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits $/;"	s	namespace:boost::re_detail
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<char*> : pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const char*> : const_pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const int*> : const_pointer_iterator_traits<int>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const unsigned char*> : const_pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const unsigned short*> : const_pointer_iterator_traits<unsigned short>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<const wchar_t*> : const_pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<int*> : pointer_iterator_traits<int>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::string::const_iterator> : const_pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::string::iterator> : pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::wstring::const_iterator> : const_pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:const_pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<std::wstring::iterator> : pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<unsigned char*> : pointer_iterator_traits<char>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<unsigned short*> : pointer_iterator_traits<unsigned short>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
regex_iterator_traits	/usr/include/boost/regex/v4/iterator_traits.hpp	/^struct regex_iterator_traits<wchar_t*> : pointer_iterator_traits<wchar_t>{};$/;"	s	namespace:boost::re_detail	inherits:pointer_iterator_traits
regex_iterator_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::regex_iterator<BidiIterator, value_type, traits_type> regex_iterator_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
regex_match	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_match(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
regex_match	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_match(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, match_results<const B*, A>& what, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^bool regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^bool regex_match(iterator first, iterator last, $/;"	f	namespace:boost	signature:(iterator first, iterator last, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const regex& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const regex& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, match_results<const charT*, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const wregex& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, match_results<std::basic_string<wchar_t>::const_iterator>& m, const wregex& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const regex& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const basic_regex<char, cpp_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const basic_regex<char, c_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const basic_regex<char, w32_regex_traits<char> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const regex& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const wregex& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const basic_regex<wchar_t, cpp_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const basic_regex<wchar_t, c_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const basic_regex<wchar_t, w32_regex_traits<wchar_t> >& e, match_flag_type flags = match_default)
regex_match	/usr/include/boost/regex/v4/regex_match.hpp	/^inline bool regex_match(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const wregex& e, match_flag_type flags = match_default)
regex_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
regex_matcher	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^    struct regex_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline OutputIterator regex_merge(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const basic_regex<charT, traits>& e, const charT* fmt, match_flag_type flags = match_default)
regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline OutputIterator regex_merge(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const basic_regex<charT, traits>& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline std::basic_string<charT> regex_merge(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const basic_regex<charT, traits>& e, const charT* fmt, match_flag_type flags = match_default)
regex_merge	/usr/include/boost/regex/v4/regex_merge.hpp	/^inline std::basic_string<charT> regex_merge(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const basic_regex<charT, traits>& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
regex_p	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^regex_p(CharT const *first)$/;"	f	namespace:boost::spirit	signature:(CharT const *first)
regex_p	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^regex_p(CharT const *first, CharT const *last)$/;"	f	namespace:boost::spirit	signature:(CharT const *first, CharT const *last)
regex_reference_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef const RegExT& regex_reference_type;$/;"	t	struct:boost::algorithm::detail::find_regexF	access:public
regex_replace	/usr/include/boost/regex/mfc.hpp	/^ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST> regex_replace(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B, traits>& e, const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& fmt, match_flag_type flags = match_default)
regex_replace	/usr/include/boost/regex/mfc.hpp	/^OutputIterator regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last, const basic_regex<B, traits>& e, const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& fmt, match_flag_type flags = match_default)
regex_replace	/usr/include/boost/regex/v4/regex_replace.hpp	/^OutputIterator regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last, const basic_regex<charT, traits>& e, Formatter fmt, match_flag_type flags = match_default)
regex_replace	/usr/include/boost/regex/v4/regex_replace.hpp	/^std::basic_string<charT> regex_replace(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const basic_regex<charT, traits>& e, Formatter fmt, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_search(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
regex_search	/usr/include/boost/regex/mfc.hpp	/^inline bool regex_search(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s,$/;"	f	namespace:boost	signature:(const ATL::CSimpleStringT<SIMPLE_STRING_ARG_LIST>& s, match_results<const B*, A>& what, const basic_regex<B, T>& e, boost::regex_constants::match_flag_type f = boost::regex_constants::match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^bool regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^bool regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^bool regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags, BidiIterator base)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const char* first, const char* last, $/;"	f	namespace:boost	signature:(const char* first, const char* last, const regex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const char* str, $/;"	f	namespace:boost	signature:(const char* str, cmatch& m, const regex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const char* str, $/;"	f	namespace:boost	signature:(const char* str, const regex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const charT* str, $/;"	f	namespace:boost	signature:(const charT* str, match_results<const charT*, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<charT, ST, SA>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<charT, ST, SA>& s, match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator>& m, const basic_regex<charT, traits>& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, const wregex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::basic_string<wchar_t>& s, $/;"	f	namespace:boost	signature:(const std::basic_string<wchar_t>& s, wsmatch& m, const wregex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const regex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, smatch& m, const regex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const wchar_t* first, const wchar_t* last, $/;"	f	namespace:boost	signature:(const wchar_t* first, const wchar_t* last, const wregex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, const wregex& e, match_flag_type flags = match_default)
regex_search	/usr/include/boost/regex/v4/regex_search.hpp	/^inline bool regex_search(const wchar_t* str, $/;"	f	namespace:boost	signature:(const wchar_t* str, wcmatch& m, const wregex& e, match_flag_type flags = match_default)
regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result( const match_results_type& MatchResults ) :$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( const match_results_type& MatchResults )
regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result( const regex_search_result& Other ) :$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( const regex_search_result& Other )
regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                regex_search_result( IteratorT End ) :$/;"	f	struct:boost::algorithm::detail::regex_search_result	access:public	signature:( IteratorT End )
regex_search_result	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^            struct regex_search_result : $/;"	s	namespace:boost::algorithm::detail	inherits:iterator_range
regex_split	/usr/include/boost/regex/v4/regex_split.hpp	/^inline std::size_t regex_split(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, std::basic_string<charT, Traits1, Alloc1>& s)
regex_split	/usr/include/boost/regex/v4/regex_split.hpp	/^inline std::size_t regex_split(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, std::basic_string<charT, Traits1, Alloc1>& s, const basic_regex<charT, Traits2>& e, match_flag_type flags = match_default)
regex_split	/usr/include/boost/regex/v4/regex_split.hpp	/^std::size_t regex_split(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, std::basic_string<charT, Traits1, Alloc1>& s, const basic_regex<charT, Traits2>& e, match_flag_type flags, std::size_t max_split)
regex_t	/usr/include/boost/regex/v4/cregex.hpp	178;"	d
regex_t	/usr/include/boost/regex/v4/cregex.hpp	184;"	d
regex_tA	/usr/include/boost/regex/v4/cregex.hpp	/^} regex_tA;$/;"	t	typeref:struct:boost::__anon3
regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(){}$/;"	f	class:boost::regex_token_iterator	access:public	signature:()
regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const std::vector<int>& submatches, match_flag_type m = match_default)
regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, int submatch = 0, match_flag_type m = match_default)
regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const int (&submatches)[N], match_flag_type m = match_default)
regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const T& submatches, match_flag_type m = match_default)
regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator(const regex_token_iterator& that)$/;"	f	class:boost::regex_token_iterator	access:public	signature:(const regex_token_iterator& that)
regex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^class regex_token_iterator $/;"	c	namespace:boost	inherits:std::iterator
regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex )
regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args )
regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
regex_token_iterator	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator$/;"	s	namespace:boost::xpressive
regex_token_iterator_impl	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    regex_token_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default , std::vector<int> subs = std::vector<int>(1, 0) , int n = -2 , bool not_null = false )
regex_token_iterator_impl	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)
regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)
regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)
regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)$/;"	f	class:boost::regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
regex_token_iterator_implementation	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^class regex_token_iterator_implementation $/;"	c	namespace:boost
regex_token_iterator_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::regex_token_iterator<BidiIterator, value_type, traits_type> regex_token_iterator_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
regex_traits	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits() : implementationT() {}$/;"	f	struct:boost::regex_traits	access:public	signature:()
regex_traits	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct regex_traits : public implementationT$/;"	s	namespace:boost	inherits:implementationT
regex_traits	/usr/include/boost/xpressive/regex_traits.hpp	/^    explicit regex_traits(locale_type const &loc)$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:(locale_type const &loc)
regex_traits	/usr/include/boost/xpressive/regex_traits.hpp	/^    regex_traits()$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:()
regex_traits	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits$/;"	s	namespace:boost::xpressive	inherits:Impl
regex_traits_architype	/usr/include/boost/regex/concepts.hpp	/^   regex_traits_architype();$/;"	p	struct:boost::regex_traits_architype	access:public	signature:()
regex_traits_architype	/usr/include/boost/regex/concepts.hpp	/^   regex_traits_architype(const regex_traits_architype&);$/;"	p	struct:boost::regex_traits_architype	access:private	signature:(const regex_traits_architype&)
regex_traits_architype	/usr/include/boost/regex/concepts.hpp	/^struct regex_traits_architype$/;"	s	namespace:boost
regex_traits_computer	/usr/include/boost/regex/concepts.hpp	/^struct regex_traits_computer< global_regex_namespace::basic_regex<charT, traits> >$/;"	s	namespace:boost
regex_traits_version_1_case_fold_tag	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits_version_1_case_fold_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
regex_traits_version_1_tag	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits_version_1_tag$/;"	s	namespace:boost::xpressive
regex_traits_version_2_tag	/usr/include/boost/xpressive/regex_traits.hpp	/^struct regex_traits_version_2_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
regex_traits_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits_wrapper(){}$/;"	f	struct:boost::regex_traits_wrapper	access:public	signature:()
regex_traits_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^   regex_traits_wrapper(const regex_traits_wrapper&);$/;"	p	struct:boost::regex_traits_wrapper	access:private	signature:(const regex_traits_wrapper&)
regex_traits_wrapper	/usr/include/boost/regex/v4/regex_traits.hpp	/^struct regex_traits_wrapper $/;"	s	namespace:boost	inherits:::boost::re_detail::compute_wrapper_base::type
regex_tW	/usr/include/boost/regex/v4/cregex.hpp	/^} regex_tW;$/;"	t	typeref:struct:boost::__anon4
regex_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef RegExT regex_type;$/;"	t	struct:boost::algorithm::detail::find_regexF	access:public
regex_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef basic_regex<Ch, Tr>                        regex_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
regex_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          basic_regex<charT, traits>                   regex_type;$/;"	t	class:boost::regex_iterator	access:public
regex_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef basic_regex<charT, traits> regex_type;$/;"	t	class:boost::regex_iterator_implementation	access:private
regex_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          basic_regex<charT, traits>                   regex_type;$/;"	t	class:boost::regex_token_iterator	access:public
regex_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef basic_regex<charT, traits> regex_type;$/;"	t	class:boost::regex_token_iterator_implementation	access:private
regex_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          u32regex                                                regex_type;$/;"	t	class:boost::u32regex_iterator	access:public
regex_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef u32regex regex_type;$/;"	t	class:boost::u32regex_iterator_implementation	access:private
regex_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          u32regex                                                regex_type;$/;"	t	class:boost::u32regex_token_iterator	access:public
regex_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef u32regex                              regex_type;$/;"	t	class:boost::u32regex_token_iterator_implementation	access:private
regex_type	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
regex_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
regfree	/usr/include/boost/regex/v4/cregex.hpp	177;"	d
regfree	/usr/include/boost/regex/v4/cregex.hpp	183;"	d
regfreeA	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CCALL regfreeA(regex_tA*);$/;"	p	signature:(regex_tA*)
regfreeW	/usr/include/boost/regex/v4/cregex.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CCALL regfreeW(regex_tW*);$/;"	p	signature:(regex_tW*)
regmatch_t	/usr/include/boost/regex/v4/cregex.hpp	/^} regmatch_t;$/;"	t	typeref:struct:boost::__anon5
regoff_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef std::ptrdiff_t regoff_t;$/;"	t
regsize_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef std::size_t regsize_t;$/;"	t
regular_file	/usr/include/boost/filesystem/operations.hpp	/^    regular_file,$/;"	e	enum:boost::filesystem::file_type
REG_ASSERT	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ASSERT = 15,$/;"	e	enum:boost::__anon6
REG_ATOI	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ATOI = 255,   \/* convert name to number (!) *\/$/;"	e	enum:boost::__anon6
REG_AWK	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_AWK = REG_EXTENDED | REG_ESCAPE_IN_LISTS,$/;"	e	enum:boost::__anon6
REG_BADBR	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_BADBR = 10;    \/* Invalid contents of \\{\\}.  *\/$/;"	v
REG_BADPAT	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_BADPAT = 2;    \/* Invalid pattern.  *\/$/;"	v
REG_BADRPT	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_BADRPT = 13;   \/* No preceding re for repetition op.  *\/$/;"	v
REG_BASIC	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_BASIC = 0000,$/;"	e	enum:boost::__anon6
reg_comp_flags	/usr/include/boost/regex/v4/cregex.hpp	/^} reg_comp_flags;$/;"	t	typeref:enum:boost::__anon6
REG_DUMP	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_DUMP = 0200,$/;"	e	enum:boost::__anon6
REG_EBRACE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EBRACE = 9;    \/* Unmatched \\{.  *\/$/;"	v
REG_EBRACK	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EBRACK = 7;    \/* Unmatched left bracket.  *\/$/;"	v
REG_ECOLLATE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ECOLLATE = 3;  \/* Undefined collating element.  *\/$/;"	v
REG_ECOMPLEXITY	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ECOMPLEXITY = 18; \/* complexity too high *\/$/;"	v
REG_ECTYPE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ECTYPE = 4;    \/* Invalid character class name.  *\/$/;"	v
REG_EEND	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EEND = 14;     \/* unexpected end of expression *\/$/;"	v
REG_EESCAPE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EESCAPE = 5;   \/* Trailing backslash.  *\/$/;"	v
REG_EGREP	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_EGREP = REG_EXTENDED | REG_NEWLINE_ALT,$/;"	e	enum:boost::__anon6
REG_EMPTY	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EMPTY = 17;    \/* empty expression *\/$/;"	v
REG_ENOSYS	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ENOSYS = 21;   \/* = REG_E_UNKNOWN : Reserved. *\/$/;"	v
REG_EPAREN	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_EPAREN = 8;    \/* Parenthesis imbalance.  *\/$/;"	v
REG_ERANGE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ERANGE = 11;   \/* Invalid range end.  *\/$/;"	v
REG_ERPAREN	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ERPAREN = 8;   \/* = REG_EPAREN : unmatched right parenthesis *\/$/;"	v
reg_errcode_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef reg_error_t reg_errcode_t;  \/* backwards compatibility *\/$/;"	t
reg_error_t	/usr/include/boost/regex/v4/cregex.hpp	/^typedef unsigned reg_error_t;$/;"	t
REG_ESCAPE_IN_LISTS	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ESCAPE_IN_LISTS = 01000,$/;"	e	enum:boost::__anon6
REG_ESIZE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESIZE = 15;    \/* expression too big *\/$/;"	v
REG_ESPACE	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESPACE = 12;   \/* Ran out of memory.  *\/$/;"	v
REG_ESTACK	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESTACK = 19;   \/* out of stack space *\/$/;"	v
REG_ESUBREG	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_ESUBREG = 6;   \/* Invalid back reference.  *\/$/;"	v
reg_exec_flags	/usr/include/boost/regex/v4/cregex.hpp	/^} reg_exec_flags;$/;"	t	typeref:enum:boost::__anon7
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(){}$/;"	f	class:boost::reg_expression	access:public	signature:()
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(const charT* p, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   explicit reg_expression(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(const charT* p, size_type len, flag_type f)$/;"	f	class:boost::reg_expression	access:public	signature:(const charT* p, size_type len, flag_type f)
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(const reg_expression& that)$/;"	f	class:boost::reg_expression	access:public	signature:(const reg_expression& that)
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   reg_expression(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)$/;"	f	class:boost::reg_expression	access:public	signature:(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^class reg_expression : public basic_regex<charT, traits>$/;"	c	namespace:boost	inherits:basic_regex
REG_EXTENDED	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_EXTENDED = 0001,$/;"	e	enum:boost::__anon6
REG_E_MEMORY	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_E_MEMORY = 15; \/* = REG_ESIZE : out of memory *\/$/;"	v
REG_E_PERL	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_E_PERL = 20;   \/* Perl (?...) error *\/$/;"	v
REG_E_UNKNOWN	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_E_UNKNOWN = 21; \/* unknown error *\/$/;"	v
REG_GREP	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_GREP = REG_BASIC | REG_NEWLINE_ALT,$/;"	e	enum:boost::__anon6
REG_ICASE	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ICASE = 0002,$/;"	e	enum:boost::__anon6
REG_INVARG	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_INVARG = 16,$/;"	e	enum:boost::__anon6
REG_ITOA	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_ITOA = 0400   \/* convert number to name (!) *\/$/;"	e	enum:boost::__anon6
REG_NEWLINE	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NEWLINE = 0010,$/;"	e	enum:boost::__anon6
REG_NEWLINE_ALT	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NEWLINE_ALT = 02000,$/;"	e	enum:boost::__anon6
REG_NOCOLLATE	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOCOLLATE = 0400,$/;"	e	enum:boost::__anon6
REG_NOERROR	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_NOERROR = 0;   \/* Success.  *\/$/;"	v
REG_NOMATCH	/usr/include/boost/regex/v4/cregex.hpp	/^static const reg_error_t REG_NOMATCH = 1;   \/* Didn't find a match (for regexec).  *\/$/;"	v
REG_NOSPEC	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOSPEC = 0020,$/;"	e	enum:boost::__anon6
REG_NOSUB	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOSUB = 0004,$/;"	e	enum:boost::__anon6
REG_NOTBOL	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOTBOL =    00001,$/;"	e	enum:boost::__anon7
REG_NOTEOL	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_NOTEOL =    00002,$/;"	e	enum:boost::__anon7
REG_PEND	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_PEND = 0040,$/;"	e	enum:boost::__anon6
REG_PERL	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_PERL = REG_EXTENDED | REG_NOCOLLATE | REG_ESCAPE_IN_LISTS | REG_PERLEX,$/;"	e	enum:boost::__anon6
REG_PERLEX	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_PERLEX = 04000,$/;"	e	enum:boost::__anon6
REG_STARTEND	/usr/include/boost/regex/v4/cregex.hpp	/^   REG_STARTEND =  00004$/;"	e	enum:boost::__anon7
relative_path	/usr/include/boost/filesystem/path.hpp	/^    path  relative_path() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
reluctance	/usr/include/boost/units/systems/si/reluctance.hpp	/^typedef unit<reluctance_dimension,si::system>    reluctance;$/;"	t	namespace:boost::units::si
remote_address_changed	/usr/include/boost/system/linux_error.hpp	/^        remote_address_changed = EREMCHG,$/;"	e	enum:boost::system::linux_error::linux_errno
remote_io_error	/usr/include/boost/system/linux_error.hpp	/^        remote_io_error = EREMOTEIO,$/;"	e	enum:boost::system::linux_error::linux_errno
remote_object	/usr/include/boost/system/linux_error.hpp	/^        remote_object = EREMOTE,$/;"	e	enum:boost::system::linux_error::linux_errno
remove	/usr/include/boost/filesystem/operations.hpp	/^    bool remove(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
remove	/usr/include/boost/filesystem/operations.hpp	/^  bool remove(const path& p)           {return detail::remove(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
remove	/usr/include/boost/filesystem/operations.hpp	/^  bool remove(const path& p, system::error_code& ec) {return detail::remove(p, &ec);}$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
remove_all	/usr/include/boost/filesystem/operations.hpp	/^    boost::uintmax_t remove_all(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
remove_all	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t remove_all(const path& p) {return detail::remove_all(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
remove_all	/usr/include/boost/filesystem/operations.hpp	/^  boost::uintmax_t remove_all(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
remove_filename	/usr/include/boost/filesystem/path.hpp	/^    path&  remove_filename();$/;"	p	class:boost::filesystem::path	access:public	signature:()
remove_leaf	/usr/include/boost/filesystem/path.hpp	/^    path&  remove_leaf()            { return remove_filename(); }$/;"	f	class:boost::filesystem::path	access:public	signature:()
remove_perms	/usr/include/boost/filesystem/operations.hpp	/^    remove_perms = 0x2000,  \/\/ removes the given permission bits from the current bits;$/;"	e	enum:boost::filesystem::perms
rem_not_list	/usr/include/boost/system/windows_error.hpp	/^        rem_not_list = ERROR_REM_NOT_LIST,$/;"	e	enum:boost::system::windows_error::windows_error_code
rename	/usr/include/boost/filesystem/operations.hpp	/^    void rename(const path& old_p, const path& new_p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& old_p, const path& new_p, system::error_code* ec=0)
rename	/usr/include/boost/filesystem/operations.hpp	/^  void rename(const path& old_p, const path& new_p) {detail::rename(old_p, new_p);}$/;"	f	namespace:boost::filesystem	signature:(const path& old_p, const path& new_p)
rename	/usr/include/boost/filesystem/operations.hpp	/^  void rename(const path& old_p, const path& new_p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& old_p, const path& new_p, system::error_code& ec)
rep	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::rep                        rep;$/;"	t	class:boost::chrono::steady_clock	access:public
rep	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef duration::rep                        rep;$/;"	t	class:boost::chrono::system_clock	access:public
rep	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   const re_repeat* rep;$/;"	m	struct:boost::re_detail::saved_single_repeat	access:public
reparse_file	/usr/include/boost/filesystem/operations.hpp	/^    reparse_file,  \/\/ Windows: FILE_ATTRIBUTE_REPARSE_POINT that is not a symlink$/;"	e	enum:boost::filesystem::file_type
repeat	/usr/include/boost/xpressive/regex_primitives.hpp	/^repeat(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
repeat	/usr/include/boost/xpressive/regex_primitives.hpp	/^repeat(Expr2 const &expr2)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr2 const &expr2)
repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count(int i, repeater_count** s, BidiIterator start)$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:(int i, repeater_count** s, BidiIterator start)
repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count(repeater_count** s)$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:(repeater_count** s)
repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^class repeater_count$/;"	c	namespace:boost::re_detail
repeater_stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count<iterator>* repeater_stack;$/;"	m	struct:boost::re_detail::recursion_info	access:public
repeat_max	/usr/include/boost/xpressive/regex_primitives.hpp	/^unsigned int const repeat_max = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
ReplaceAlgo	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct ReplaceAlgo$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
replace_	/usr/include/boost/iostreams/filter/regex.hpp	/^    formatter   replace_;$/;"	m	class:boost::iostreams::basic_regex_filter	access:private
replace_all_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void replace_all_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
replace_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT replace_all_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
replace_all_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT replace_all_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
replace_extension	/usr/include/boost/filesystem/path.hpp	/^    path&  replace_extension(const path& new_extension = path());$/;"	p	class:boost::filesystem::path	access:public	signature:(const path& new_extension = path())
replace_filename	/usr/include/boost/filesystem/operations.hpp	/^  void replace_filename(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st = file_status(), file_status symlink_st = file_status())
replace_leaf	/usr/include/boost/filesystem/operations.hpp	/^  void replace_leaf(const boost::filesystem::path& p,$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(const boost::filesystem::path& p, file_status st, file_status symlink_st)
replace_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline void replace_regex( $/;"	f	namespace:boost::algorithm	signature:( SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
replace_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline OutputIteratorT replace_regex_copy($/;"	f	namespace:boost::algorithm	signature:( OutputIteratorT Output, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
replace_regex_copy	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceT replace_regex_copy( $/;"	f	namespace:boost::algorithm	signature:( const SequenceT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, const std::basic_string<CharT, FormatStringTraitsT, FormatStringAllocatorT>& Format, match_flag_type Flags=match_default | format_default )
rep_obj	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count<BidiIterator> rep_obj;$/;"	m	class:boost::re_detail::perl_matcher	access:private
reset	/usr/include/boost/xpressive/regex_compiler.hpp	/^    void reset()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
reset_stack_guard_page	/usr/include/boost/regex/config.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL reset_stack_guard_page();$/;"	p	namespace:boost::re_detail	signature:()
resistance	/usr/include/boost/units/systems/si/resistance.hpp	/^typedef unit<resistance_dimension,si::system>    resistance;$/;"	t	namespace:boost::units::si
resistivity	/usr/include/boost/units/systems/si/resistivity.hpp	/^typedef unit<resistivity_dimension,si::system>    resistivity;$/;"	t	namespace:boost::units::si
resize	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void BOOST_REGEX_CALL resize(size_type n);$/;"	p	class:boost::re_detail::raw_storage	access:public	signature:(size_type n)
resize_file	/usr/include/boost/filesystem/operations.hpp	/^    void resize_file(const path& p, uintmax_t size, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, uintmax_t size, system::error_code* ec=0)
resize_file	/usr/include/boost/filesystem/operations.hpp	/^  void resize_file(const path& p, uintmax_t size) {detail::resize_file(p, size);}$/;"	f	namespace:boost::filesystem	signature:(const path& p, uintmax_t size)
resize_file	/usr/include/boost/filesystem/operations.hpp	/^  void resize_file(const path& p, uintmax_t size, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, uintmax_t size, system::error_code& ec)
resolution_traits	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::resolution_traits   resolution_traits;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
resolution_traits	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::resolution_traits   resolution_traits;$/;"	t	class:boost::date_time::split_timedate_system	access:public
resource_deadlock_would_occur	/usr/include/boost/system/error_code.hpp	/^        resource_deadlock_would_occur = EDEADLK,$/;"	e	enum:boost::system::errc::errc_t
resource_unavailable_try_again	/usr/include/boost/system/error_code.hpp	/^        resource_unavailable_try_again = EAGAIN,$/;"	e	enum:boost::system::errc::errc_t
restart	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator restart;$/;"	m	class:boost::re_detail::perl_matcher	access:private
restart_any	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_any = 0,$/;"	e	enum:boost::regbase::restart_info
restart_buf	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_buf = 3,$/;"	e	enum:boost::regbase::restart_info
restart_continue	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_continue = 4,$/;"	e	enum:boost::regbase::restart_info
restart_count	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_count = 7$/;"	e	enum:boost::regbase::restart_info
restart_fixed_lit	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_fixed_lit = 6, $/;"	e	enum:boost::regbase::restart_info
restart_info	/usr/include/boost/regex/v4/regbase.hpp	/^   enum restart_info$/;"	g	class:boost::regbase	access:public
restart_line	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_line = 2,$/;"	e	enum:boost::regbase::restart_info
restart_lit	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_lit = 5,$/;"	e	enum:boost::regbase::restart_info
restart_needed	/usr/include/boost/system/linux_error.hpp	/^        restart_needed = ERESTART,$/;"	e	enum:boost::system::linux_error::linux_errno
restart_word	/usr/include/boost/regex/v4/regbase.hpp	/^      restart_word = 1,$/;"	e	enum:boost::regbase::restart_info
restore	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   void restore(match_results<BidiIterator, A>& w)$/;"	f	class:boost::re_detail::backup_subex	access:public	signature:(match_results<BidiIterator, A>& w)
result	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   value_type                           result; \/\/ the current string result$/;"	m	class:boost::regex_token_iterator_implementation	access:private
result	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   value_type                           result; \/\/ the current string result$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::back	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::first	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::front	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::length	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::make_pair	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::second	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::str	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::top	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result$/;"	s	struct:boost::xpressive::op::insert	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont const &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Idx)>$/;"	s	struct:boost::xpressive::op::at	inherits:result	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, It, It), void>$/;"	s	struct:boost::xpressive::op::insert	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, It, Size, Value),$/;"	s	struct:boost::xpressive::op::insert	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, It, Value),$/;"	s	struct:boost::xpressive::op::insert	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Size, A0, A1),$/;"	s	struct:boost::xpressive::op::insert	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Size, T),$/;"	s	struct:boost::xpressive::op::insert	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Cont, Value), void>$/;"	s	struct:boost::xpressive::op::insert	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(First, Second)>$/;"	s	struct:boost::xpressive::op::make_pair	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(MatchResults, Expr)>$/;"	s	struct:boost::xpressive::detail::BindArg	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::first	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::second	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Ref &)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Ref)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::back	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::front	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::top	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::length	access:public
result	/usr/include/boost/xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::str	access:public
result	/usr/include/boost/xpressive/regex_primitives.hpp	/^        struct result<This(Expr)>$/;"	s	struct:boost::xpressive::detail::skip_directive	access:public
results	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   Results results;$/;"	m	struct:boost::re_detail::recursion_info	access:public
results	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   Results results;$/;"	m	struct:boost::re_detail::saved_recursion	access:public
results_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef match_results<BidiIterator, Allocator> results_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
result_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    value_type result_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
result_out_of_range	/usr/include/boost/system/error_code.hpp	/^        result_out_of_range = ERANGE,$/;"	e	enum:boost::system::errc::errc_t
result_type	/usr/include/boost/algorithm/string/detail/formatter_regex.hpp	/^                typedef StringT result_type;$/;"	t	struct:boost::algorithm::detail::regex_formatF	access:private
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef bool result_type;$/;"	t	struct:boost::xpressive::op::matched	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_nbr	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::as	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::construct	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::const_cast_	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::dynamic_cast_	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::static_cast_	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_back	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_front	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_back	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_front	access:public
result_type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::throw_	access:public
result_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::skip_primitives::impl	access:public
result_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_number	access:public
result_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::push_back	access:public
revolution	/usr/include/boost/units/systems/angle/revolutions.hpp	/^namespace revolution {$/;"	n	namespace:boost::units
rex_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    basic_regex<BidiIter> rex_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
re_	/usr/include/boost/iostreams/filter/regex.hpp	/^    regex_type  re_;$/;"	m	class:boost::iostreams::basic_regex_filter	access:private
re_alt	/usr/include/boost/regex/v4/states.hpp	/^struct re_alt : public re_jump$/;"	s	namespace:boost::re_detail	inherits:re_jump
re_alt_size	/usr/include/boost/regex/v4/states.hpp	/^   re_alt_size = (sizeof(re_alt) + padding_mask) & ~(padding_mask)$/;"	e	enum:boost::re_detail::re_jump_size_type
re_brace	/usr/include/boost/regex/v4/states.hpp	/^struct re_brace : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
re_case	/usr/include/boost/regex/v4/states.hpp	/^struct re_case : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
re_detail	/usr/include/boost/regex/config.hpp	/^namespace boost{ namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/config.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/icu.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/mfc.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/pattern_except.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/basic_regex.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/cregex.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/fileiter.hpp	/^   namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/iterator_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/match_results.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/perl_matcher.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/perl_matcher_common.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/primary_transform.hpp	/^   namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/protected_call.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/regex_format.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/regex_split.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/regex_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^namespace boost{ namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/regex_workaround.hpp	/^namespace boost{ namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/states.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/sub_match.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_detail	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^namespace re_detail{$/;"	n	namespace:boost
re_dot	/usr/include/boost/regex/v4/states.hpp	/^struct re_dot : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
re_endp	/usr/include/boost/regex/v4/cregex.hpp	/^   const char*  re_endp;       \/* end pointer for REG_PEND *\/$/;"	m	struct:boost::__anon3	access:public
re_endp	/usr/include/boost/regex/v4/cregex.hpp	/^   const wchar_t* re_endp;       \/* end pointer for REG_PEND *\/$/;"	m	struct:boost::__anon4	access:public
re_is_set_member	/usr/include/boost/regex/v4/perl_matcher.hpp	/^iterator BOOST_REGEX_CALL re_is_set_member(iterator next, $/;"	f	namespace:boost::re_detail	signature:(iterator next, iterator last, const re_set_long<char_classT>* set_, const regex_data<charT, traits_type>& e, bool icase)
re_is_set_member	/usr/include/boost/regex/v4/states.hpp	/^iterator BOOST_REGEX_CALL re_is_set_member(iterator next, $/;"	p	namespace:boost::re_detail	signature:(iterator next, iterator last, const re_set_long<char_classT>* set_, const regex_data<charT, traits_type>& e, bool icase)
re_jump	/usr/include/boost/regex/v4/states.hpp	/^struct re_jump : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
re_jump_size	/usr/include/boost/regex/v4/states.hpp	/^   re_jump_size = (sizeof(re_jump) + padding_mask) & ~(padding_mask),$/;"	e	enum:boost::re_detail::re_jump_size_type
re_jump_size_type	/usr/include/boost/regex/v4/states.hpp	/^enum re_jump_size_type$/;"	g	namespace:boost::re_detail
re_literal	/usr/include/boost/regex/v4/states.hpp	/^struct re_literal : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
re_magic	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int re_magic;$/;"	m	struct:boost::__anon3	access:public
re_magic	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int re_magic;$/;"	m	struct:boost::__anon4	access:public
re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   size_t re_nsub; $/;"	m	struct:boost::__anon3	access:public
re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   size_t re_nsub;$/;"	m	struct:boost::__anon4	access:public
re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t  re_nsub;         \/* number of parenthesized subexpressions *\/$/;"	m	struct:boost::__anon4	access:public
re_nsub	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t  re_nsub;      \/* number of parenthesized subexpressions *\/$/;"	m	struct:boost::__anon3	access:public
re_recurse	/usr/include/boost/regex/v4/states.hpp	/^struct re_recurse : public re_jump$/;"	s	namespace:boost::re_detail	inherits:re_jump
re_repeat	/usr/include/boost/regex/v4/states.hpp	/^struct re_repeat : public re_alt$/;"	s	namespace:boost::re_detail	inherits:re_alt
re_repeater_size	/usr/include/boost/regex/v4/states.hpp	/^   re_repeater_size = (sizeof(re_repeat) + padding_mask) & ~(padding_mask),$/;"	e	enum:boost::re_detail::re_jump_size_type
re_set	/usr/include/boost/regex/v4/states.hpp	/^struct re_set : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
re_set_long	/usr/include/boost/regex/v4/states.hpp	/^struct re_set_long : public re_syntax_base$/;"	s	namespace:boost::re_detail	inherits:re_syntax_base
re_skip_past_null	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline const charT* re_skip_past_null(const charT* p)$/;"	f	namespace:boost::re_detail	signature:(const charT* p)
re_syntax_base	/usr/include/boost/regex/v4/states.hpp	/^struct re_syntax_base$/;"	s	namespace:boost::re_detail
rm_eo	/usr/include/boost/regex/v4/cregex.hpp	/^   regoff_t rm_eo;      \/* end of match *\/$/;"	m	struct:boost::__anon5	access:public
rm_so	/usr/include/boost/regex/v4/cregex.hpp	/^   regoff_t rm_so;      \/* start of match *\/$/;"	m	struct:boost::__anon5	access:public
root	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* root()const { return _root; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:() const
root	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* root()const { return _root; }$/;"	f	class:boost::re_detail::file_iterator	access:public	signature:() const
root_directory	/usr/include/boost/filesystem/path.hpp	/^    path  root_directory() const;    \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
root_name	/usr/include/boost/filesystem/path.hpp	/^    path  root_name() const;         \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
root_path	/usr/include/boost/filesystem/path.hpp	/^    path  root_path() const; $/;"	p	class:boost::filesystem::path	access:public	signature:() const
rules_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    std::map<string_type, basic_regex<BidiIter> > rules_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
runtime_error	/usr/include/boost/xpressive/regex_error.hpp	/^    struct runtime_error {};$/;"	s	namespace:std
rx	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    impl::rx_parser<CharT> rx;   \/\/ contains the boost regular expression parser$/;"	m	struct:boost::spirit::rxstrlit	access:private
rxstrlit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    rxstrlit(CharT const *first)$/;"	f	struct:boost::spirit::rxstrlit	access:public	signature:(CharT const *first)
rxstrlit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    rxstrlit(CharT const *first, CharT const *last)$/;"	f	struct:boost::spirit::rxstrlit	access:public	signature:(CharT const *first, CharT const *last)
rxstrlit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^struct rxstrlit : public parser<rxstrlit<CharT> > {$/;"	s	namespace:boost::spirit	inherits:parser
rxtraits	/usr/include/boost/xpressive/regex_compiler.hpp	/^    traits_type &rxtraits()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
rxtraits	/usr/include/boost/xpressive/regex_compiler.hpp	/^    traits_type const &rxtraits() const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:() const
saved_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_assertion(bool p, const re_syntax_base* ps, BidiIterator pos) $/;"	f	struct:boost::re_detail::saved_assertion	access:public	signature:(bool p, const re_syntax_base* ps, BidiIterator pos)
saved_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_assertion : public saved_position<BidiIterator>$/;"	s	namespace:boost::re_detail	inherits:saved_position
saved_extra_block	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_extra_block(saved_state* b, saved_state* e) $/;"	f	struct:boost::re_detail::saved_extra_block	access:public	signature:(saved_state* b, saved_state* e)
saved_extra_block	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_extra_block : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
saved_matched_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_matched_paren(int i, const sub_match<BidiIterator>& s) : saved_state(1), index(i), sub(s){};$/;"	f	struct:boost::re_detail::saved_matched_paren	access:public	signature:(int i, const sub_match<BidiIterator>& s)
saved_matched_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_matched_paren : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
saved_position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_position(const re_syntax_base* ps, BidiIterator pos, int i) : saved_state(i), pstate(ps), position(pos){};$/;"	f	struct:boost::re_detail::saved_position	access:public	signature:(const re_syntax_base* ps, BidiIterator pos, int i)
saved_position	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_position : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
saved_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_recursion(int idx, const re_syntax_base* p, Results* pr) $/;"	f	struct:boost::re_detail::saved_recursion	access:public	signature:(int idx, const re_syntax_base* p, Results* pr)
saved_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_recursion : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
saved_repeater	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_repeater(int i, repeater_count<BidiIterator>** s, BidiIterator start) $/;"	f	struct:boost::re_detail::saved_repeater	access:public	signature:(int i, repeater_count<BidiIterator>** s, BidiIterator start)
saved_repeater	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_repeater : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
saved_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_single_repeat(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id) $/;"	f	struct:boost::re_detail::saved_single_repeat	access:public	signature:(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id)
saved_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_single_repeat : public saved_state$/;"	s	namespace:boost::re_detail	inherits:saved_state
saved_state	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state(unsigned i) : state_id(i) {}$/;"	f	struct:boost::re_detail::saved_state	access:public	signature:(unsigned i)
saved_state	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct saved_state$/;"	s	namespace:boost::re_detail
saved_state_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_alt = 4,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_count = 14$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_extra_block	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_extra_block = 6,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_greedy_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_greedy_single_repeat = 7,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_non_greedy_long_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_non_greedy_long_repeat = 13, $/;"	e	enum:boost::re_detail::saved_state_type
saved_state_repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_repeater_count = 5,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_rep_char	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_char = 10,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_rep_fast_dot	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_fast_dot = 9,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_rep_long_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_long_set = 12,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_rep_short_set	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_short_set = 11,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_rep_slow_dot	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_state_rep_slow_dot = 8,$/;"	e	enum:boost::re_detail::saved_state_type
saved_state_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^enum saved_state_type$/;"	g	namespace:boost::re_detail
saved_type_assertion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_assertion = 3,$/;"	e	enum:boost::re_detail::saved_state_type
saved_type_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_end = 0,$/;"	e	enum:boost::re_detail::saved_state_type
saved_type_paren	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_paren = 1,$/;"	e	enum:boost::re_detail::saved_state_type
saved_type_recurse	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   saved_type_recurse = 2,$/;"	e	enum:boost::re_detail::saved_state_type
save_state_init	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   save_state_init(saved_state** base, saved_state** end)$/;"	f	struct:boost::re_detail::save_state_init	access:public	signature:(saved_state** base, saved_state** end)
save_state_init	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^struct save_state_init$/;"	s	namespace:boost::re_detail
save_subexpression_location	/usr/include/boost/regex/v4/regbase.hpp	/^      save_subexpression_location = 1 << 23,            \/\/ save subexpression locations$/;"	e	enum:boost::regbase::flag_type_
save_subexpression_location	/usr/include/boost/regex/v4/regbase.hpp	/^      save_subexpression_location = ::boost::regbase::save_subexpression_location,$/;"	e	enum:boost::regex_constants::flag_type_
scale	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Scale scale;$/;"	t	struct:boost::units::heterogeneous_system_impl	access:public
scont_	/usr/include/boost/xpressive/regex_actions.hpp	/^                static cont_type &scont_;$/;"	m	struct:boost::xpressive::op::insert::result	access:public
scoped_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   typedef scoped_static_mutex_lock scoped_lock;$/;"	t	class:boost::static_mutex	access:public
scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   scoped_static_mutex_lock(static_mutex& mut, bool lk = true);$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:(static_mutex& mut, bool lk = true)
scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^class BOOST_REGEX_DECL scoped_static_mutex_lock$/;"	c	namespace:boost
scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^class BOOST_REGEX_DECL scoped_static_mutex_lock;$/;"	m	namespace:boost	typeref:class:boost::BOOST_REGEX_DECL
Search	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Search(const char* p, match_flag_type flags = match_default);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p, match_flag_type flags = match_default)
Search	/usr/include/boost/regex/v4/cregex.hpp	/^   bool Search(const std::string& s, match_flag_type flags = match_default) { return Search(s.c_str(), flags); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s, match_flag_type flags = match_default)
search_base	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator search_base;$/;"	m	class:boost::re_detail::perl_matcher	access:private
second	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct second$/;"	s	namespace:boost::xpressive::op
second	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::second>::type const second = {{}};$/;"	m	class:boost::xpressive::function
sector_not_found	/usr/include/boost/system/windows_error.hpp	/^        sector_not_found = ERROR_SECTOR_NOT_FOUND,$/;"	e	enum:boost::system::windows_error::windows_error_code
sed	/usr/include/boost/regex/v4/regbase.hpp	/^      sed = basic,$/;"	e	enum:boost::regbase::flag_type_
sed	/usr/include/boost/regex/v4/regbase.hpp	/^      sed = basic,$/;"	e	enum:boost::regex_constants::flag_type_
seek	/usr/include/boost/system/windows_error.hpp	/^        seek = ERROR_SEEK,$/;"	e	enum:boost::system::windows_error::windows_error_code
seekoff	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typename parser_buf<charT, traits>::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which);$/;"	p	class:boost::re_detail::parser_buf	access:protected	signature:(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
seekoff	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^parser_buf<charT, traits>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)$/;"	f	class:boost::re_detail::parser_buf	signature:(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
seekpos	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typename parser_buf<charT, traits>::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which);$/;"	p	class:boost::re_detail::parser_buf	access:protected	signature:(pos_type sp, ::std::ios_base::openmode which)
seekpos	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^parser_buf<charT, traits>::seekpos(pos_type sp, ::std::ios_base::openmode which)$/;"	f	class:boost::re_detail::parser_buf	signature:(pos_type sp, ::std::ios_base::openmode which)
selector	/usr/include/boost/regex/v4/iterator_category.hpp	/^   typedef detail::is_random_imp_selector< ::boost::is_pointer<I>::value> selector;$/;"	t	struct:boost::is_random_access_iterator	access:private
self	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::self_placeholder>::type const self = {{}};$/;"	m	class:boost::xpressive::proto::terminal
self_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    shared_ptr<detail::regex_impl<BidiIter> > self_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
self_t	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^    typedef rxstrlit self_t;$/;"	t	struct:boost::spirit::rxstrlit	access:public
self_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef perl_matcher<BidiIterator, Allocator, traits> self_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
separator	/usr/include/boost/regex/v4/fileiter.hpp	/^   static const char* separator() { return _fi_sep; }$/;"	f	class:boost::re_detail::directory_iterator	access:public	signature:()
sequence_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sequence) sequence_type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
sequence_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sequence) sequence_type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
sequence_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sequence) sequence_type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
set	/usr/include/boost/xpressive/regex_primitives.hpp	/^detail::set_initializer_type const set = {{}};$/;"	m	class:boost::xpressive::detail
setbuf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   std::basic_streambuf<charT, traits>* setbuf(char_type* s, streamsize n);$/;"	p	class:boost::re_detail::parser_buf	access:protected	signature:(char_type* s, streamsize n)
setbuf	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^parser_buf<charT, traits>::setbuf(char_type* s, streamsize n)$/;"	f	class:boost::re_detail::parser_buf	signature:(char_type* s, streamsize n)
SetExpression	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int SetExpression(const char* p, bool icase = false);$/;"	p	class:boost::RegEx	access:public	signature:(const char* p, bool icase = false)
SetExpression	/usr/include/boost/regex/v4/cregex.hpp	/^   unsigned int SetExpression(const std::string& s, bool icase = false){ return SetExpression(s.c_str(), icase); }$/;"	f	class:boost::RegEx	access:public	signature:(const std::string& s, bool icase = false)
setf	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void setf(match_flag_type f)$/;"	f	class:boost::re_detail::perl_matcher	access:public	signature:(match_flag_type f)
set_all_masks	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void set_all_masks(unsigned char* bits, unsigned char);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(unsigned char* bits, unsigned char)
set_all_masks	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::set_all_masks(unsigned char* bits, unsigned char mask)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(unsigned char* bits, unsigned char mask)
set_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   void set_bad_repeat(re_syntax_base* pt);$/;"	p	class:boost::re_detail::basic_regex_creator	access:private	signature:(re_syntax_base* pt)
set_bad_repeat	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^void basic_regex_creator<charT, traits>::set_bad_repeat(re_syntax_base* pt)$/;"	f	class:boost::re_detail::basic_regex_creator	signature:(re_syntax_base* pt)
set_base	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_base(BidiIterator pos)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator pos)
set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const charT* p, flag_type f = regex_constants::normal) $/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p, flag_type f = regex_constants::normal)
set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
set_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   unsigned int BOOST_REGEX_CALL set_expression(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)$/;"	f	class:boost::basic_regex	access:public	signature:(const std::basic_string<charT>& p, flag_type f = regex_constants::normal)
set_first	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_first(BidiIterator i)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i)
set_first	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_first(BidiIterator i, size_type pos, bool escape_k = false)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i, size_type pos, bool escape_k = false)
set_gid_on_exe	/usr/include/boost/filesystem/operations.hpp	/^    set_gid_on_exe = 02000, \/\/ S_ISGID, Set-group-ID on execution$/;"	e	enum:boost::filesystem::perms
set_name	/usr/include/boost/regex/v4/basic_regex.hpp	/^   void set_name(const charT* i, const charT* j, int index)$/;"	f	class:boost::re_detail::named_subexpressions	access:public	signature:(const charT* i, const charT* j, int index)
set_named_subs	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_named_subs(boost::shared_ptr<named_sub_type> subs)$/;"	f	class:boost::match_results	access:public	signature:(boost::shared_ptr<named_sub_type> subs)
set_second	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_second(BidiIterator i)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i)
set_second	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_second(BidiIterator i, size_type pos, bool m = true, bool escape_k = false)$/;"	f	class:boost::match_results	access:public	signature:(BidiIterator i, size_type pos, bool m = true, bool escape_k = false)
set_size	/usr/include/boost/regex/v4/match_results.hpp	/^   void BOOST_REGEX_CALL set_size(size_type n, BidiIterator i, BidiIterator j)$/;"	f	class:boost::match_results	access:public	signature:(size_type n, BidiIterator i, BidiIterator j)
set_uid_on_exe	/usr/include/boost/filesystem/operations.hpp	/^    set_uid_on_exe = 04000, \/\/ S_ISUID, Set-user-ID on execution$/;"	e	enum:boost::filesystem::perms
shared_library_access	/usr/include/boost/system/linux_error.hpp	/^        shared_library_access = ELIBACC,$/;"	e	enum:boost::system::linux_error::linux_errno
shared_library_bad	/usr/include/boost/system/linux_error.hpp	/^        shared_library_bad = ELIBBAD,$/;"	e	enum:boost::system::linux_error::linux_errno
shared_library_execute	/usr/include/boost/system/linux_error.hpp	/^        shared_library_execute = ELIBEXEC,$/;"	e	enum:boost::system::linux_error::linux_errno
shared_library_max_	/usr/include/boost/system/linux_error.hpp	/^        shared_library_max_ = ELIBMAX,$/;"	e	enum:boost::system::linux_error::linux_errno
shared_library_section	/usr/include/boost/system/linux_error.hpp	/^        shared_library_section= ELIBSCN,$/;"	e	enum:boost::system::linux_error::linux_errno
sharing_buffer_exceeded	/usr/include/boost/system/windows_error.hpp	/^        sharing_buffer_exceeded = ERROR_SHARING_BUFFER_EXCEEDED,$/;"	e	enum:boost::system::windows_error::windows_error_code
sharing_violation	/usr/include/boost/system/windows_error.hpp	/^        sharing_violation = ERROR_SHARING_VIOLATION,$/;"	e	enum:boost::system::windows_error::windows_error_code
shutdown	/usr/include/boost/system/linux_error.hpp	/^        shutdown = ESHUTDOWN,$/;"	e	enum:boost::system::linux_error::linux_errno
si	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/acceleration.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/action.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/activity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/amount.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/angular_acceleration.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/angular_momentum.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/area.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/base.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/capacitance.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/conductance.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/conductivity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/current.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/dimensionless.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/electric_charge.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/electric_potential.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/energy.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/force.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/frequency.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/illuminance.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/impedance.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/inductance.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/length.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/mass.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/mass_density.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/momentum.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/permeability.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/permittivity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/plane_angle.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/power.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/prefixes.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/pressure.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/reluctance.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/resistance.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/resistivity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/solid_angle.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/surface_density.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/surface_tension.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/temperature.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/time.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/torque.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/velocity.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/volume.hpp	/^namespace si {$/;"	n	namespace:boost::units
si	/usr/include/boost/units/systems/si/wavenumber.hpp	/^namespace si {$/;"	n	namespace:boost::units
simple_formatter	/usr/include/boost/iostreams/filter/regex.hpp	/^        simple_formatter(const string_type& fmt, flag_type fmt_flags) $/;"	f	struct:boost::iostreams::basic_regex_filter::simple_formatter	access:public	signature:(const string_type& fmt, flag_type fmt_flags)
simple_formatter	/usr/include/boost/iostreams/filter/regex.hpp	/^    struct simple_formatter {$/;"	s	class:boost::iostreams::basic_regex_filter	access:private
SIMPLE_STRING_ARG_LIST	/usr/include/boost/regex/mfc.hpp	36;"	d
SIMPLE_STRING_ARG_LIST	/usr/include/boost/regex/mfc.hpp	39;"	d
SIMPLE_STRING_PARAM	/usr/include/boost/regex/mfc.hpp	35;"	d
SIMPLE_STRING_PARAM	/usr/include/boost/regex/mfc.hpp	38;"	d
since	/usr/include/boost/chrono/system_clocks.hpp	/^    static std::basic_string<CharT> since()$/;"	f	struct:boost::chrono::clock_string	access:public	signature:()
singles_begin	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator singles_begin()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
singles_end	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   list_iterator singles_end()const$/;"	f	class:boost::re_detail::basic_char_set	access:public	signature:() const
singleton	/usr/include/boost/regex/v4/states.hpp	/^   bool                    singleton;$/;"	m	struct:boost::re_detail::re_set_long	access:public
single_line	/usr/include/boost/xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::single_line;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
single_line	/usr/include/boost/xpressive/regex_constants.hpp	/^    single_line         = 1 << 10,  \/\/\/< Specifies that the ^ and \\$ metacharacters DO NOT match at$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
size	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL size()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
size	/usr/include/boost/regex/v4/basic_regex.hpp	/^   size_type BOOST_REGEX_CALL size()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
size	/usr/include/boost/regex/v4/fileiter.hpp	/^   size_t size(){ return _last - _first; }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
size	/usr/include/boost/regex/v4/match_results.hpp	/^   size_type size() const$/;"	f	class:boost::match_results	access:public	signature:() const
size	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   size_type BOOST_REGEX_CALL size()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
sizeof	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   BOOST_STATIC_ASSERT(sizeof(long) >= sizeof(void*));$/;"	p	class:boost::re_detail::basic_regex_parser	access:private	signature:(long)
sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(std::ctype_base::mask)
sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umaskex_t)
sizeof	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
size_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::size_type size_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
size_type	/usr/include/boost/regex/concepts.hpp	/^   typedef unsigned size_type;$/;"	t	class:allocator_architype	access:public
size_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::size_t                  size_type;$/;"	t	class:boost::icu_regex_traits	access:public
size_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::size_t                  size_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
size_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef typename list_type::size_type size_type;$/;"	t	class:boost::object_cache	access:public
size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           size_type;   $/;"	t	class:boost::basic_regex	access:public
size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           size_type;  $/;"	t	struct:boost::re_detail::regex_data	access:public
size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           size_type; $/;"	t	class:boost::re_detail::basic_regex_implementation	access:public
size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename basic_regex<charT, traits>::size_type size_type;$/;"	t	class:boost::reg_expression	access:public
size_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef unsigned int size_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
size_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::size_t                  size_type;$/;"	t	class:boost::cpp_regex_traits	access:public
size_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::size_t size_type;$/;"	t	struct:boost::c_regex_traits	access:public
size_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef typename Allocator::size_type                                    size_type;$/;"	t	class:boost::match_results	access:public
size_type	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   typedef std::size_t           size_type;$/;"	t	class:boost::re_detail::raw_storage	access:public
size_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::size_t                   size_type;$/;"	t	class:boost::w32_regex_traits	access:public
skip	/usr/include/boost/xpressive/regex_primitives.hpp	/^detail::skip_directive<Skip> skip(Skip const &skip)$/;"	f	namespace:boost::xpressive	signature:(Skip const &skip)
SkipGrammar	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct SkipGrammar$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
skip_	/usr/include/boost/xpressive/regex_primitives.hpp	/^        skip_type skip_;$/;"	m	struct:boost::xpressive::detail::skip_directive	access:private
skip_directive	/usr/include/boost/xpressive/regex_primitives.hpp	/^        skip_directive(Skip const &skip)$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Skip const &skip)
skip_directive	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct skip_directive$/;"	s	namespace:boost::xpressive::detail
skip_primitives	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct skip_primitives : proto::transform<skip_primitives>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
skip_transform	/usr/include/boost/xpressive/regex_primitives.hpp	/^            skip_transform;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
skip_type	/usr/include/boost/xpressive/regex_primitives.hpp	/^        typedef typename proto::result_of::as_expr<Skip>::type skip_type;$/;"	t	struct:boost::xpressive::detail::skip_directive	access:public
smatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<std::string::const_iterator> smatch;$/;"	t	namespace:boost
socket_file	/usr/include/boost/filesystem/operations.hpp	/^    socket_file,$/;"	e	enum:boost::filesystem::file_type
socket_type_not_supported	/usr/include/boost/system/linux_error.hpp	/^        socket_type_not_supported = ESOCKTNOSUPPORT,$/;"	e	enum:boost::system::linux_error::linux_errno
solid_angle	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<solid_angle_dimension,system>           solid_angle;            \/\/\/< abstract unit of solid angle$/;"	t	namespace:boost::units::abstract
solid_angle	/usr/include/boost/units/systems/si/solid_angle.hpp	/^typedef unit<solid_angle_dimension,si::system>      solid_angle;$/;"	t	namespace:boost::units::si
solid_angle_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct solid_angle_unit_tag : base_unit<solid_angle_unit_tag, solid_angle_dimension, -22> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
sort_C	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_C,$/;"	e	enum:boost::re_detail::__anon9
sort_delim	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_delim,$/;"	e	enum:boost::re_detail::__anon9
sort_fixed	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_fixed,$/;"	e	enum:boost::re_detail::__anon9
sort_unknown	/usr/include/boost/regex/v4/primary_transform.hpp	/^   sort_unknown$/;"	e	enum:boost::re_detail::__anon9
space	/usr/include/boost/filesystem/operations.hpp	/^    space_info space(const path& p, system::error_code* ec=0); $/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
space	/usr/include/boost/filesystem/operations.hpp	/^  space_info space(const path& p)      {return detail::space(p);} $/;"	f	namespace:boost::filesystem	signature:(const path& p)
space	/usr/include/boost/filesystem/operations.hpp	/^  space_info space(const path& p, system::error_code& ec) {return detail::space(p, &ec);} $/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
space	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const space = {{"space", false}};$/;"	m	class:boost::xpressive::proto::terminal
space_info	/usr/include/boost/filesystem/operations.hpp	/^  struct space_info$/;"	s	namespace:boost::filesystem
spirit	/usr/include/boost/spirit/home/classic/utility/regex.hpp	/^namespace boost { namespace spirit {$/;"	n	namespace:boost
Split	/usr/include/boost/regex/v4/cregex.hpp	/^   std::size_t Split(std::vector<std::string>& v, std::string& s, match_flag_type flags = match_default, unsigned max_count = ~0);$/;"	p	class:boost::RegEx	access:public	signature:(std::vector<std::string>& v, std::string& s, match_flag_type flags = match_default, unsigned max_count = ~0)
split_pred	/usr/include/boost/regex/v4/regex_split.hpp	/^   split_pred(iterator_type* a, OutputIterator* b, std::size_t* c)$/;"	f	class:boost::re_detail::split_pred	access:public	signature:(iterator_type* a, OutputIterator* b, std::size_t* c)
split_pred	/usr/include/boost/regex/v4/regex_split.hpp	/^class split_pred$/;"	c	namespace:boost::re_detail
split_regex	/usr/include/boost/algorithm/string/regex.hpp	/^        inline SequenceSequenceT& split_regex($/;"	f	namespace:boost::algorithm	signature:( SequenceSequenceT& Result, const RangeT& Input, const basic_regex<CharT, RegexTraitsT>& Rx, match_flag_type Flags=match_default )
split_timedate_system	/usr/include/boost/date_time/time_system_split.hpp	/^  class split_timedate_system$/;"	c	namespace:boost::date_time
sregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<std::string::const_iterator> sregex_iterator;$/;"	t	namespace:boost
sregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<std::string::const_iterator> sregex_token_iterator;$/;"	t	namespace:boost
srmount_error	/usr/include/boost/system/linux_error.hpp	/^        srmount_error = ESRMNT,$/;"	e	enum:boost::system::linux_error::linux_errno
ssub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<std::string::const_iterator> ssub_match;$/;"	t	namespace:boost
stack	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   repeater_count** stack;$/;"	m	class:boost::re_detail::repeater_count	access:private
stack	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   saved_state** stack;$/;"	m	struct:boost::re_detail::save_state_init	access:public
start	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   pointer last, start, end;$/;"	m	class:boost::re_detail::raw_storage	access:private
start_pos	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   BidiIterator start_pos;   \/\/ where the last repeat started$/;"	m	class:boost::re_detail::repeater_count	access:private
state_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    match_state<BidiIter> state_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
state_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   std::ptrdiff_t state_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
state_id	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   int state_id;$/;"	m	class:boost::re_detail::repeater_count	access:private
state_id	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^      unsigned int state_id;$/;"	m	union:boost::re_detail::saved_state::__anon8	access:public
state_id	/usr/include/boost/regex/v4/states.hpp	/^   int           state_id;        \/\/ Unique identifier for this repeat$/;"	m	struct:boost::re_detail::re_repeat	access:public
state_id	/usr/include/boost/regex/v4/states.hpp	/^   int state_id;             \/\/ identifier of first nested repeat within the recursion.$/;"	m	struct:boost::re_detail::re_recurse	access:public
state_not_recoverable	/usr/include/boost/system/error_code.hpp	/^        state_not_recoverable = ENOTRECOVERABLE,$/;"	e	enum:boost::system::errc::errc_t
static_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct static_cast_$/;"	s	namespace:boost::xpressive::op
static_cast_	/usr/include/boost/xpressive/regex_actions.hpp	/^    static_cast_(A0 const &a0)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A0 const &a0)
static_mutex	/usr/include/boost/regex/pending/static_mutex.hpp	/^class static_mutex$/;"	c	namespace:boost
static_power	/usr/include/boost/units/heterogeneous_system.hpp	/^struct static_power<heterogeneous_system<S>, static_rational<N,D> >$/;"	s	namespace:boost::units
static_power	/usr/include/boost/units/homogeneous_system.hpp	/^struct static_power<homogeneous_system<L>, static_rational<N,D> >$/;"	s	namespace:boost::units
static_root	/usr/include/boost/units/heterogeneous_system.hpp	/^struct static_root<heterogeneous_system<S>, static_rational<N,D> >$/;"	s	namespace:boost::units
static_root	/usr/include/boost/units/homogeneous_system.hpp	/^struct static_root<homogeneous_system<L>, static_rational<N,D> >$/;"	s	namespace:boost::units
status	/usr/include/boost/filesystem/operations.hpp	/^    file_status status() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
status	/usr/include/boost/filesystem/operations.hpp	/^    file_status status(const path&p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path&p, system::error_code* ec=0)
status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   status() const                               {return m_get_status();}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:() const
status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   status(system::error_code& ec) const         {return m_get_status(&ec);}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(system::error_code& ec) const
status	/usr/include/boost/filesystem/operations.hpp	/^  file_status status(const path& p)    {return detail::status(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
status	/usr/include/boost/filesystem/operations.hpp	/^  file_status status(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
status	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int BOOST_REGEX_CALL status()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
status	/usr/include/boost/regex/v4/basic_regex.hpp	/^   int status()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
status_error	/usr/include/boost/filesystem/operations.hpp	/^    status_error,$/;"	e	enum:boost::filesystem::file_type
status_known	/usr/include/boost/filesystem/operations.hpp	/^  inline bool status_known(file_status f) { return type_present(f) && permissions_present(f); }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
status_unknown	/usr/include/boost/filesystem/operations.hpp	/^    status_unknown = status_error,$/;"	e	enum:boost::filesystem::file_type
std	/usr/include/boost/iostreams/detail/system_failure.hpp	/^namespace std { using ::strlen; }$/;"	n
std	/usr/include/boost/regex/concepts.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/regex/config/cwchar.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/regex/v4/regex_traits_defaults.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/regex/v4/regex_workaround.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/tr1/regex.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/xpressive/regex_error.hpp	/^namespace std$/;"	n
std::basic_string	/usr/include/boost/regex/config.hpp	/^      extern template class __declspec(dllimport) std::basic_string<unsigned short>;$/;"	m	class:std
std::char_traits	/usr/include/boost/regex/concepts.hpp	/^   template<> struct char_traits<boost::char_architype>$/;"	s	namespace:std
std::char_traits::char_type	/usr/include/boost/regex/concepts.hpp	/^      typedef boost::char_architype char_type;$/;"	t	struct:std::char_traits	access:public
std::iswalnum	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswalnum)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswalpha	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswalpha)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswcntrl	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswcntrl)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswdigit	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswdigit)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswgraph	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswgraph)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswlower	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswlower)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswprint	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswprint)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswpunct	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswpunct)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswspace	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswspace)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswupper	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswupper)(wint_t i)$/;"	f	signature:(wint_t i)
std::iswxdigit	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (iswxdigit)(wint_t i)$/;"	f	signature:(wint_t i)
std::runtime_error	/usr/include/boost/xpressive/regex_error.hpp	/^    struct runtime_error {};$/;"	s	namespace:std
std::towlower	/usr/include/boost/regex/config/cwchar.hpp	/^inline wint_t (towlower)(wint_t i)$/;"	f	signature:(wint_t i)
std::towupper	/usr/include/boost/regex/config/cwchar.hpp	/^inline wint_t (towupper)(wint_t i)$/;"	f	signature:(wint_t i)
std::tr1	/usr/include/boost/tr1/regex.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1::regex_constants	/usr/include/boost/tr1/regex.hpp	/^namespace regex_constants {$/;"	n	namespace:std::tr1
std::wcscmp	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (wcscmp)(const wchar_t *p1, const wchar_t *p2)$/;"	f	signature:(const wchar_t *p1, const wchar_t *p2)
std::wcscoll	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (wcscoll)(const wchar_t *p1, const wchar_t *p2)$/;"	f	signature:(const wchar_t *p1, const wchar_t *p2)
std::wcscpy	/usr/include/boost/regex/config/cwchar.hpp	/^inline wchar_t *(wcscpy)(wchar_t *p1, const wchar_t *p2)$/;"	f	signature:(wchar_t *p1, const wchar_t *p2)
std::wcslen	/usr/include/boost/regex/config/cwchar.hpp	/^inline size_t (wcslen)(const wchar_t *p)$/;"	f	signature:(const wchar_t *p)
std::wcsxfrm	/usr/include/boost/regex/config/cwchar.hpp	/^size_t wcsxfrm(wchar_t *p1, const wchar_t *p2, size_t s)$/;"	f	signature:(wchar_t *p1, const wchar_t *p2, size_t s)
std_ctype_alnum	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = 1 << 0;$/;"	m	namespace:boost::xpressive::detail
std_ctype_alnum	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = mask_cast<std::ctype_base::alnum>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_alpha	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = 1 << 1;$/;"	m	namespace:boost::xpressive::detail
std_ctype_alpha	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = mask_cast<std::ctype_base::alpha>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_cntrl	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = 1 << 2;$/;"	m	namespace:boost::xpressive::detail
std_ctype_cntrl	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = mask_cast<std::ctype_base::cntrl>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_digit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = 1 << 3;$/;"	m	namespace:boost::xpressive::detail
std_ctype_digit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = mask_cast<std::ctype_base::digit>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_graph	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = 1 << 4;$/;"	m	namespace:boost::xpressive::detail
std_ctype_graph	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = mask_cast<std::ctype_base::graph>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_lower	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = 1 << 5;$/;"	m	namespace:boost::xpressive::detail
std_ctype_lower	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = mask_cast<std::ctype_base::lower>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_print	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = 1 << 6;$/;"	m	namespace:boost::xpressive::detail
std_ctype_print	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = mask_cast<std::ctype_base::print>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_punct	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = 1 << 7;$/;"	m	namespace:boost::xpressive::detail
std_ctype_punct	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = mask_cast<std::ctype_base::punct>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_reserved	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0;$/;"	m	namespace:boost::xpressive::detail
std_ctype_reserved	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8000;$/;"	m	namespace:boost::xpressive::detail
std_ctype_reserved	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8200;$/;"	m	namespace:boost::xpressive::detail
std_ctype_space	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = 1 << 8;$/;"	m	namespace:boost::xpressive::detail
std_ctype_space	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = mask_cast<std::ctype_base::space>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_upper	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = 1 << 9;$/;"	m	namespace:boost::xpressive::detail
std_ctype_upper	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = mask_cast<std::ctype_base::upper>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_xdigit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = 1 << 10;$/;"	m	namespace:boost::xpressive::detail
std_ctype_xdigit	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = mask_cast<std::ctype_base::xdigit>::value;$/;"	m	namespace:boost::xpressive::detail
std_masks	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static umaskex_t const std_masks[] =$/;"	m	namespace:boost::xpressive::detail
steady_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL steady_clock$/;"	c	namespace:boost::chrono
steady_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL steady_clock;$/;"	m	namespace:boost::chrono	typeref:class:boost::chrono::BOOST_CHRONO_DECL
stem	/usr/include/boost/filesystem/path.hpp	/^    path  stem() const;              \/\/ returns 0 or 1 element path$/;"	p	class:boost::filesystem::path	access:public	signature:() const
sticky_bit	/usr/include/boost/filesystem/operations.hpp	/^    sticky_bit     = 01000, \/\/ S_ISVTX,$/;"	e	enum:boost::filesystem::perms
str	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::basic_string<charT> BOOST_REGEX_CALL str()const$/;"	f	class:boost::basic_regex	access:public	signature:() const
str	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::basic_string<charT> BOOST_REGEX_CALL str()const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:() const
str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const charT* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const charT* sub) const
str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const char_type* sub) const$/;"	f	class:boost::match_results	access:public	signature:(const char_type* sub) const
str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const std::basic_string<charT, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<charT, Traits, A>& sub) const
str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(const std::basic_string<char_type, Traits, A>& sub) const$/;"	f	class:boost::match_results	access:public	signature:(const std::basic_string<char_type, Traits, A>& sub) const
str	/usr/include/boost/regex/v4/match_results.hpp	/^   string_type str(int sub = 0) const$/;"	f	class:boost::match_results	access:public	signature:(int sub = 0) const
str	/usr/include/boost/regex/v4/sub_match.hpp	/^   std::basic_string<value_type> str()const$/;"	f	struct:boost::sub_match	access:public	signature:() const
str	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct str$/;"	s	namespace:boost::xpressive::op
str	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::str>::type const str = {{}};$/;"	m	class:boost::xpressive::function
strcmp	/usr/include/boost/regex/config/borland.hpp	66;"	d
strcpy	/usr/include/boost/regex/config/borland.hpp	67;"	d
streamsize	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef ::std::streamsize streamsize;$/;"	t	class:boost::re_detail::parser_buf	access:private
stream_pipe_error	/usr/include/boost/system/linux_error.hpp	/^        stream_pipe_error = ESTRPIPE,$/;"	e	enum:boost::system::linux_error::linux_errno
stream_timeout	/usr/include/boost/system/error_code.hpp	/^        stream_timeout = ETIME,$/;"	e	enum:boost::system::errc::errc_t
string	/usr/include/boost/filesystem/path.hpp	/^    const std::string string() const { return string(codecvt()); } $/;"	f	class:boost::filesystem::path	access:public	signature:() const
string	/usr/include/boost/filesystem/path.hpp	/^    const std::string string(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  string() const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
string	/usr/include/boost/filesystem/path.hpp	/^    const std::string&  string(const codecvt_type&) const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
string	/usr/include/boost/filesystem/path.hpp	/^    String string() const;$/;"	p	class:boost::filesystem::path	access:public	signature:() const
string	/usr/include/boost/filesystem/path.hpp	/^    String string(const codecvt_type& cvt) const;$/;"	p	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::string<std::string>() const$/;"	f	class:boost::filesystem::path	signature:() const
string	/usr/include/boost/filesystem/path.hpp	/^  std::string path::string<std::string>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::string<std::wstring>() const$/;"	f	class:boost::filesystem::path	signature:() const
string	/usr/include/boost/filesystem/path.hpp	/^  std::wstring path::string<std::wstring>(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	signature:(const codecvt_type& cvt) const
string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const Seq& s, const C* p)$/;"	f	namespace:boost::re_detail	signature:(const Seq& s, const C* p)
string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const std::basic_string<C,T,A>& s, const C* p)$/;"	f	namespace:boost::re_detail	signature:(const std::basic_string<C,T,A>& s, const C* p)
string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const std::string& s, const char* p)$/;"	f	namespace:boost::re_detail	signature:(const std::string& s, const char* p)
string_compare	/usr/include/boost/regex/v4/perl_matcher.hpp	/^inline int string_compare(const std::wstring& s, const wchar_t* p)$/;"	f	namespace:boost::re_detail	signature:(const std::wstring& s, const wchar_t* p)
string_out_iterator	/usr/include/boost/regex/v4/regex_format.hpp	/^   string_out_iterator(S& s) : out(&s) {}$/;"	f	class:boost::re_detail::string_out_iterator	access:public	signature:(S& s)
string_out_iterator	/usr/include/boost/regex/v4/regex_format.hpp	/^class string_out_iterator$/;"	c	namespace:boost::re_detail	inherits:std::iterator
string_type	/usr/include/boost/filesystem/path.hpp	/^    typedef std::basic_string<value_type>  string_type;  $/;"	t	class:boost::filesystem::path	access:public
string_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef std::basic_string<Ch>                      string_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:public
string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef std::basic_string<value_type> string_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef std::basic_string<value_type> string_type;$/;"	t	struct:boost::RegexConcept	access:public
string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef std::vector<char_type> string_type;$/;"	t	struct:boost::regex_traits_architype	access:public
string_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename traits::string_type string_type;$/;"	t	struct:boost::RegexTraitsConcept	access:public
string_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::vector<char_type>       string_type;$/;"	t	class:boost::icu_regex_traits	access:public
string_type	/usr/include/boost/regex/icu.hpp	/^   typedef std::vector<char_type>       string_type;$/;"	t	class:boost::re_detail::icu_regex_traits_implementation	access:private
string_type	/usr/include/boost/regex/v4/basic_regex_creator.hpp	/^   typedef typename traits::string_type     string_type;$/;"	t	class:boost::re_detail::basic_char_set	access:public
string_type	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   typedef typename traits::string_type string_type;$/;"	t	class:boost::re_detail::basic_regex_parser	access:private
string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_implementation	access:public
string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::basic_string<char_type> string_type;$/;"	t	class:boost::cpp_regex_traits	access:public
string_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   typedef std::string string_type;$/;"	t	class:boost::re_detail::cpp_regex_traits_char_layer	access:private
string_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::basic_string<unsigned short> string_type;$/;"	t	struct:boost::c_regex_traits	access:public
string_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::string string_type;$/;"	t	struct:boost::c_regex_traits	access:public
string_type	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   typedef std::wstring string_type;$/;"	t	struct:boost::c_regex_traits	access:public
string_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          std::basic_string<char_type>                            string_type;$/;"	t	class:boost::match_results	access:public
string_type	/usr/include/boost/regex/v4/regex_split.hpp	/^   typedef std::basic_string<charT, Traits1, Alloc1> string_type;$/;"	t	class:boost::re_detail::split_pred	access:private
string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::basic_string<charT> string_type;$/;"	t	class:boost::re_detail::w32_regex_traits_implementation	access:public
string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::basic_string<char_type>  string_type;$/;"	t	class:boost::w32_regex_traits	access:public
string_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   typedef std::string string_type;$/;"	t	class:boost::re_detail::w32_regex_traits_char_layer	access:private
string_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef typename detail::string_type<char_type>::type string_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
string_type	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    typedef typename detail::string_type<Char>::type string_type;$/;"	t	struct:boost::xpressive::detail::named_mark	access:public
string_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef typename traits_type::string_type string_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
string_type	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
string_type	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
string_type	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef std::vector<char_type> string_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
STR_COMP	/usr/include/boost/regex/v4/perl_matcher.hpp	131;"	d
sub	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   sub_match<BidiIterator> sub;$/;"	m	struct:boost::re_detail::saved_matched_paren	access:public
sub	/usr/include/boost/regex/v4/perl_matcher_recursive.hpp	/^   sub_match<BidiIterator> sub;$/;"	m	class:boost::re_detail::backup_subex	access:private
subexpression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::pair<const_iterator, const_iterator> BOOST_REGEX_CALL subexpression(std::size_t n)const$/;"	f	class:boost::basic_regex	access:public	signature:(std::size_t n) const
subexpression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   std::pair<const_iterator, const_iterator> BOOST_REGEX_CALL subexpression(std::size_t n)const$/;"	f	class:boost::re_detail::basic_regex_implementation	access:public	signature:(std::size_t n) const
SubMatch	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct SubMatch$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
SubMatchList	/usr/include/boost/xpressive/regex_primitives.hpp	/^    struct SubMatchList$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
subs	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   std::vector<int>                     subs;   \/\/ the sub-expressions to enumerate$/;"	m	class:boost::regex_token_iterator_implementation	access:private
subs	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   std::vector<int>                     subs;   \/\/ the sub-expressions to enumerate$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
subs_	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    std::vector<int> subs_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
subtract_days	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type subtract_days(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
subtract_days	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type subtract_days(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, const date_duration_type& dd)
subtract_times	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_duration_type subtract_times(const time_rep_type& lhs,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
subtract_times	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_duration_type subtract_times(const time_rep_type& lhs,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& lhs, const time_rep_type& rhs)
subtract_time_duration	/usr/include/boost/date_time/time_system_counted.hpp	/^    static time_rep_type subtract_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type& base, const time_duration_type& td)
subtract_time_duration	/usr/include/boost/date_time/time_system_split.hpp	/^    static time_rep_type subtract_time_duration(const time_rep_type& base,$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type& base, const time_duration_type& td)
sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match() : std::pair<BidiIterator, BidiIterator>(), matched(false) {}$/;"	f	struct:boost::sub_match	access:public	signature:()
sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match(BidiIterator i) : std::pair<BidiIterator, BidiIterator>(i, i), matched(false) {}$/;"	f	struct:boost::sub_match	access:public	signature:(BidiIterator i)
sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^   sub_match(const sub_match& that, bool $/;"	f	struct:boost::sub_match	access:public	signature:(const sub_match& that, bool deep_copy = true )
sub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^struct sub_match : public std::pair<BidiIterator, BidiIterator>$/;"	s	namespace:boost	inherits:std::pair
sub_match_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
sub_match_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
sub_match_type	/usr/include/boost/regex/concepts.hpp	/^   typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;$/;"	t	struct:boost::RegexConcept	access:public
sub_match_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename Results::value_type sub_match_type;$/;"	t	class:boost::re_detail::basic_regex_formatter	access:private
success	/usr/include/boost/system/error_code.hpp	/^        success = 0,$/;"	e	enum:boost::system::errc::errc_t
success	/usr/include/boost/system/windows_error.hpp	/^        success = 0,$/;"	e	enum:boost::system::windows_error::windows_error_code
suffix	/usr/include/boost/regex/v4/match_results.hpp	/^   const_reference suffix() const$/;"	f	class:boost::match_results	access:public	signature:() const
surface_density	/usr/include/boost/units/systems/si/surface_density.hpp	/^typedef unit<surface_density_dimension,si::system>  surface_density;$/;"	t	namespace:boost::units::si
surface_tension	/usr/include/boost/units/systems/si/surface_tension.hpp	/^typedef unit<surface_tension_dimension,si::system>     surface_tension;$/;"	t	namespace:boost::units::si
svalue_	/usr/include/boost/xpressive/regex_actions.hpp	/^                static value_type &svalue_;$/;"	m	struct:boost::xpressive::op::insert::result	access:public
swap	/usr/include/boost/filesystem/path.hpp	/^    void   swap(path& rhs)     { m_pathname.swap(rhs.m_pathname); }$/;"	f	class:boost::filesystem::path	access:public	signature:(path& rhs)
swap	/usr/include/boost/filesystem/path.hpp	/^  inline void swap(path& lhs, path& rhs)                   { lhs.swap(rhs); }$/;"	f	namespace:boost::filesystem	signature:(path& lhs, path& rhs)
swap	/usr/include/boost/regex/v4/basic_regex.hpp	/^      void swap(name& other)$/;"	f	struct:boost::re_detail::named_subexpressions::name	access:public	signature:(name& other)
swap	/usr/include/boost/regex/v4/basic_regex.hpp	/^   void BOOST_REGEX_CALL swap(basic_regex& that)throw()$/;"	f	class:boost::basic_regex	access:public	signature:(basic_regex& that)
swap	/usr/include/boost/regex/v4/basic_regex.hpp	/^void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)$/;"	f	namespace:boost	signature:(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)
swap	/usr/include/boost/regex/v4/match_results.hpp	/^   void swap(match_results& that)$/;"	f	class:boost::match_results	access:public	signature:(match_results& that)
swap	/usr/include/boost/regex/v4/match_results.hpp	/^void swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)$/;"	f	namespace:boost	signature:(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)
swap	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   void swap(raw_storage& that)$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:(raw_storage& that)
swap	/usr/include/boost/xpressive/basic_regex.hpp	/^    void swap(basic_regex<BidiIter> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> &that)
swap	/usr/include/boost/xpressive/basic_regex.hpp	/^inline void swap(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right) \/\/ throw()$/;"	f	namespace:boost::xpressive	signature:(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right)
swap	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    void swap(regex_impl<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> &that)
swap	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^void swap(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)$/;"	f	namespace:boost::xpressive::detail	signature:(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[I]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[J]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[L]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[M]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[N]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[QP]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[QS]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[Theta]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbol	/usr/include/boost/units/systems/abstract.hpp	/^    static std::string symbol()     { return "[T]"; }$/;"	f	struct:boost::units::base_unit_info	access:public	signature:()
symbolic_link_exists	/usr/include/boost/filesystem/operations.hpp	/^  inline bool symbolic_link_exists(const path& p)$/;"	f	namespace:boost::filesystem	signature:(const path& p)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::acceleration>::type&) { return "Gal"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::acceleration>::type&)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::current>::type&) { return "Bi"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::current>::type&)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::dynamic_viscosity>::type&) { return "P"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::dynamic_viscosity>::type&)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::energy>::type&) { return "erg"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::energy>::type&)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::force>::type&) { return "dyn"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::force>::type&)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::kinematic_viscosity>::type&) { return "St"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::kinematic_viscosity>::type&)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::pressure>::type&) { return "Ba"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::pressure>::type&)
symbol_string	/usr/include/boost/units/systems/cgs/io.hpp	/^inline std::string symbol_string(const reduce_unit<cgs::wavenumber>::type&) { return "K"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<cgs::wavenumber>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::absorbed_dose>::type&) { return "Gy"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::absorbed_dose>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::capacitance>::type&) { return "F"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::capacitance>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::catalytic_activity>::type&) { return "kat"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::catalytic_activity>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::conductance>::type&) { return "S"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::conductance>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::electric_charge>::type&) { return "C"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_charge>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::electric_potential>::type&) { return "V"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::electric_potential>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::energy>::type&) { return "J"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::energy>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::force>::type&) { return "N"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::force>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::frequency>::type&) { return "Hz"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::frequency>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::illuminance>::type&) { return "lx"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::illuminance>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::inductance>::type&) { return "H"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::inductance>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::luminous_flux>::type&) { return "lm"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::luminous_flux>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::magnetic_flux>::type&) { return "Wb"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::magnetic_flux_density>::type&) { return "T"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::magnetic_flux_density>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::power>::type&) { return "W"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::power>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::pressure>::type&) { return "Pa"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::pressure>::type&)
symbol_string	/usr/include/boost/units/systems/si/io.hpp	/^inline std::string symbol_string(const reduce_unit<si::resistance>::type&) { return "Ohm"; }$/;"	f	namespace:boost::units	signature:(const reduce_unit<si::resistance>::type&)
symlink_file	/usr/include/boost/filesystem/operations.hpp	/^    symlink_file,$/;"	e	enum:boost::filesystem::file_type
symlink_perms	/usr/include/boost/filesystem/operations.hpp	/^    symlink_perms = 0x4000  \/\/ on POSIX, don't resolve symlinks; implied on Windows$/;"	e	enum:boost::filesystem::perms
symlink_status	/usr/include/boost/filesystem/operations.hpp	/^    file_status symlink_status() const$/;"	f	class:boost::filesystem::recursive_directory_iterator	access:public	signature:() const
symlink_status	/usr/include/boost/filesystem/operations.hpp	/^    file_status symlink_status(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   symlink_status() const                       {return m_get_symlink_status();}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:() const
symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status   symlink_status(system::error_code& ec) const {return m_get_symlink_status(&ec);}$/;"	f	class:boost::filesystem::directory_entry	access:public	signature:(system::error_code& ec) const
symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status symlink_status(const path& p) {return detail::symlink_status(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
symlink_status	/usr/include/boost/filesystem/operations.hpp	/^  file_status symlink_status(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
syntax_caret	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_caret = 4;$/;"	m	namespace:boost::regex_constants
syntax_char	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_char = 0;$/;"	m	namespace:boost::regex_constants
syntax_close_brace	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_close_brace = 16;$/;"	m	namespace:boost::regex_constants
syntax_close_mark	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_close_mark = 2;$/;"	m	namespace:boost::regex_constants
syntax_close_set	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_close_set = 10;$/;"	m	namespace:boost::regex_constants
syntax_colon	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_colon = 36;$/;"	m	namespace:boost::regex_constants
syntax_comma	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_comma = 27;$/;"	m	namespace:boost::regex_constants
syntax_dash	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_dash = 14;$/;"	m	namespace:boost::regex_constants
syntax_digit	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_digit = 17;$/;"	m	namespace:boost::regex_constants
syntax_dollar	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_dollar = 3;$/;"	m	namespace:boost::regex_constants
syntax_dot	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_dot = 5;$/;"	m	namespace:boost::regex_constants
syntax_element_alt	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_alt = syntax_element_jump + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_assert_backref	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_assert_backref = syntax_element_backstep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_backref	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_backref = syntax_element_buffer_end + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_backstep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_backstep = syntax_element_long_set_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_buffer_end	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_buffer_end = syntax_element_buffer_start + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_buffer_start	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_buffer_start = syntax_element_word_end + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_char_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_char_rep = syntax_element_dot_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_combining	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_combining = syntax_element_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_dot_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_dot_rep = syntax_element_restart_continue + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_endmark	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_endmark = syntax_element_startmark + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_end_line	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_end_line = syntax_element_start_line + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_jump	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_jump = syntax_element_set + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_literal	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_literal = syntax_element_endmark + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_long_set	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_long_set = syntax_element_backref + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_long_set_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_long_set_rep = syntax_element_short_set_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_match	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_match = syntax_element_wild + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_recurse	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_recurse = syntax_element_toggle_case + 1$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_rep = syntax_element_alt + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_restart_continue	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_restart_continue = syntax_element_soft_buffer_end + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_set	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_set = syntax_element_long_set + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_short_set_rep	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_short_set_rep = syntax_element_char_rep + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_soft_buffer_end	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_soft_buffer_end = syntax_element_combining + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_startmark	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_startmark = 0,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_start_line	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_start_line = syntax_element_literal + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_toggle_case	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_toggle_case = syntax_element_assert_backref + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_type	/usr/include/boost/regex/v4/states.hpp	/^enum syntax_element_type$/;"	g	namespace:boost::re_detail
syntax_element_wild	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_wild = syntax_element_end_line + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_within_word	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_within_word = syntax_element_word_boundary + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_word_boundary	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_word_boundary = syntax_element_match + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_word_end	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_word_end = syntax_element_word_start + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_element_word_start	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_word_start = syntax_element_within_word + 1,$/;"	e	enum:boost::re_detail::syntax_element_type
syntax_equal	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_equal = 37;$/;"	m	namespace:boost::regex_constants
syntax_escape	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_escape = 12;$/;"	m	namespace:boost::regex_constants
syntax_hash	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_hash = 13;$/;"	m	namespace:boost::regex_constants
syntax_max	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const escape_syntax_type syntax_max = 60;$/;"	m	namespace:boost::regex_constants
syntax_newline	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_newline = 26;$/;"	m	namespace:boost::regex_constants
syntax_not	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_not = 53;$/;"	m	namespace:boost::regex_constants
syntax_open_brace	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_open_brace = 15;$/;"	m	namespace:boost::regex_constants
syntax_open_mark	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_open_mark = 1;$/;"	m	namespace:boost::regex_constants
syntax_open_set	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_open_set = 9;$/;"	m	namespace:boost::regex_constants
syntax_option_type	/usr/include/boost/regex/v4/regbase.hpp	/^   typedef ::boost::regbase::flag_type syntax_option_type;$/;"	t	namespace:boost::regex_constants
syntax_option_type	/usr/include/boost/xpressive/regex_constants.hpp	/^enum syntax_option_type$/;"	g	namespace:boost::xpressive::regex_constants
syntax_or	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_or = 11;$/;"	m	namespace:boost::regex_constants
syntax_plus	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_plus = 7;$/;"	m	namespace:boost::regex_constants
syntax_question	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_question = 8;$/;"	m	namespace:boost::regex_constants
syntax_star	/usr/include/boost/regex/v4/syntax_type.hpp	/^static const syntax_type syntax_star = 6;$/;"	m	namespace:boost::regex_constants
syntax_type	/usr/include/boost/regex/icu.hpp	/^   ::boost::regex_constants::syntax_type syntax_type(char_type c)const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(char c)const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(char c) const
syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
syntax_type	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::re_detail::cpp_regex_traits_char_layer	access:public	signature:(charT c) const
syntax_type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   ::boost::regex_constants::syntax_type syntax_type(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
syntax_type	/usr/include/boost/regex/v4/syntax_type.hpp	/^typedef unsigned char syntax_type;$/;"	t	namespace:boost::regex_constants
syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(char c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(char c) const
syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(charT c) const
syntax_type	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   regex_constants::syntax_type syntax_type(charT c)const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
system	/usr/include/boost/system/cygwin_error.hpp	/^  namespace system$/;"	n	namespace:boost
system	/usr/include/boost/system/error_code.hpp	/^  namespace system$/;"	n	namespace:boost
system	/usr/include/boost/system/linux_error.hpp	/^  namespace system$/;"	n	namespace:boost
system	/usr/include/boost/system/system_error.hpp	/^  namespace system$/;"	n	namespace:boost
system	/usr/include/boost/system/windows_error.hpp	/^  namespace system$/;"	n	namespace:boost
system	/usr/include/boost/units/systems/abstract.hpp	/^>::type system;$/;"	t	namespace:boost::units::abstract
system	/usr/include/boost/units/systems/angle/degrees.hpp	/^typedef make_system<boost::units::angle::degree_base_unit>::type system;$/;"	t	namespace:boost::units::degree
system	/usr/include/boost/units/systems/angle/gradians.hpp	/^typedef make_system<boost::units::angle::gradian_base_unit>::type system;$/;"	t	namespace:boost::units::gradian
system	/usr/include/boost/units/systems/angle/revolutions.hpp	/^typedef make_system<boost::units::angle::revolution_base_unit>::type system;$/;"	t	namespace:boost::units::revolution
system	/usr/include/boost/units/systems/cgs/base.hpp	/^                    biot_base_unit>::type system;$/;"	t	namespace:boost::units::cgs
system	/usr/include/boost/units/systems/si/base.hpp	/^                    angle::steradian_base_unit>::type system;$/;"	t	namespace:boost::units::si
system	/usr/include/boost/units/systems/temperature/celsius.hpp	/^typedef make_system<boost::units::temperature::celsius_base_unit>::type system;$/;"	t	namespace:boost::units::celsius
system	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^typedef make_system<boost::units::temperature::fahrenheit_base_unit>::type system;$/;"	t	namespace:boost::units::fahrenheit
system_category	/usr/include/boost/system/error_code.hpp	/^    BOOST_SYSTEM_DECL const error_category &  system_category();$/;"	p	namespace:boost::system	signature:()
system_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL system_clock$/;"	c	namespace:boost::chrono
system_clock	/usr/include/boost/chrono/system_clocks.hpp	/^  class BOOST_CHRONO_DECL system_clock;$/;"	m	namespace:boost::chrono	typeref:class:boost::chrono::BOOST_CHRONO_DECL
system_complete	/usr/include/boost/filesystem/operations.hpp	/^    path system_complete(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
system_complete	/usr/include/boost/filesystem/operations.hpp	/^  path system_complete(const path& p)  {return detail::system_complete(p);}$/;"	f	namespace:boost::filesystem	signature:(const path& p)
system_complete	/usr/include/boost/filesystem/operations.hpp	/^  path system_complete(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( error_code ec )$/;"	f	class:boost::system::system_error	access:public	signature:( error_code ec )
system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( error_code ec, const char* what_arg )$/;"	f	class:boost::system::system_error	access:public	signature:( error_code ec, const char* what_arg )
system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( error_code ec, const std::string & what_arg )$/;"	f	class:boost::system::system_error	access:public	signature:( error_code ec, const std::string & what_arg )
system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( int ev, const error_category & ecat )$/;"	f	class:boost::system::system_error	access:public	signature:( int ev, const error_category & ecat )
system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( int ev, const error_category & ecat,$/;"	f	class:boost::system::system_error	access:public	signature:( int ev, const error_category & ecat, const char * what_arg )
system_error	/usr/include/boost/system/system_error.hpp	/^      system_error( int ev, const error_category & ecat,$/;"	f	class:boost::system::system_error	access:public	signature:( int ev, const error_category & ecat, const std::string & what_arg )
system_error	/usr/include/boost/system/system_error.hpp	/^    class BOOST_SYMBOL_VISIBLE system_error : public std::runtime_error$/;"	c	namespace:boost::system	inherits:std::runtime_error
system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline BOOST_IOSTREAMS_FAILURE system_failure(const char* msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const char* msg)
system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline BOOST_IOSTREAMS_FAILURE system_failure(const std::string& msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const std::string& msg)
SYSTEM_INFO_	/usr/include/boost/detail/win/system.hpp	/^    typedef ::SYSTEM_INFO SYSTEM_INFO_;$/;"	t	namespace:boost::detail::win32
system_timer	/usr/include/boost/asio/system_timer.hpp	/^typedef basic_waitable_timer<chrono::system_clock> system_timer;$/;"	t	namespace:boost::asio
tag	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename format_traits<Func, Match, OutputIterator>::type tag;$/;"	t	struct:boost::re_detail::compute_functor_type	access:public
tag	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system_dim_tag tag;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
tag_type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Unit tag_type;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
temperature	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<temperature_dimension,system>           temperature;            \/\/\/< abstract unit of temperature$/;"	t	namespace:boost::units::abstract
temperature	/usr/include/boost/units/systems/si/temperature.hpp	/^typedef unit<temperature_dimension,si::system>   temperature;$/;"	t	namespace:boost::units::si
temperature	/usr/include/boost/units/systems/temperature/celsius.hpp	/^typedef unit<temperature_dimension,system>   temperature;$/;"	t	namespace:boost::units::celsius
temperature	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^typedef unit<temperature_dimension,system>   temperature;$/;"	t	namespace:boost::units::fahrenheit
temperature_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct temperature_unit_tag : base_unit<temperature_unit_tag, temperature_dimension, -26> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
temp_directory_path	/usr/include/boost/filesystem/operations.hpp	/^    path temp_directory_path(system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(system::error_code* ec=0)
temp_directory_path	/usr/include/boost/filesystem/operations.hpp	/^  path temp_directory_path()           {return detail::temp_directory_path();}$/;"	f	namespace:boost::filesystem	signature:()
temp_directory_path	/usr/include/boost/filesystem/operations.hpp	/^  path temp_directory_path(system::error_code& ec) $/;"	f	namespace:boost::filesystem	signature:(system::error_code& ec)
ten_bit_mask	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^static const ::boost::uint32_t ten_bit_mask = 0x3FFu;$/;"	m	namespace:boost::detail
ternary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    typedef ternary_type (*ternary_fun)(any_type, any_type, any_type);$/;"	t	struct:boost::re_detail::unary_binary_ternary	access:public
ternary_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char (&ternary_type)[4];$/;"	t	namespace:boost::re_detail
test_newline	/usr/include/boost/regex/v4/states.hpp	/^   test_newline = 3$/;"	e	enum:boost::re_detail::__anon16
test_not_newline	/usr/include/boost/regex/v4/states.hpp	/^   test_not_newline = 2,$/;"	e	enum:boost::re_detail::__anon16
text_file_busy	/usr/include/boost/system/error_code.hpp	/^        text_file_busy = ETXTBSY,$/;"	e	enum:boost::system::errc::errc_t
this_type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef placeholder<T, I, Dummy> this_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
throws	/usr/include/boost/system/error_code.hpp	/^  inline system::error_code & throws()$/;"	f	namespace:boost	signature:()
throws	/usr/include/boost/system/error_code.hpp	/^  namespace detail { inline system::error_code * throws() { return 0; } }$/;"	f	namespace:boost::detail	signature:()
throw_	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct throw_$/;"	s	namespace:boost::xpressive::op
throw_on_stack_error	/usr/include/boost/xpressive/basic_regex.hpp	/^    inline void throw_on_stack_error(bool stack_error)$/;"	f	namespace:boost::xpressive::detail	signature:(bool stack_error)
throw_system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline void throw_system_failure(const char* msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const char* msg)
throw_system_failure	/usr/include/boost/iostreams/detail/system_failure.hpp	/^inline void throw_system_failure(const std::string& msg)$/;"	f	namespace:boost::iostreams::detail	signature:(const std::string& msg)
time	/usr/include/boost/units/systems/abstract.hpp	/^typedef unit<time_dimension,system>                  time;                   \/\/\/< abstract unit of time$/;"	t	namespace:boost::units::abstract
time	/usr/include/boost/units/systems/cgs/time.hpp	/^typedef unit<time_dimension,cgs::system>     time;$/;"	t	namespace:boost::units::cgs
time	/usr/include/boost/units/systems/si/time.hpp	/^typedef unit<time_dimension,si::system>      time;$/;"	t	namespace:boost::units::si
timed_out	/usr/include/boost/system/error_code.hpp	/^        timed_out = ETIMEDOUT,$/;"	e	enum:boost::system::errc::errc_t
times_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct times_impl<boost::units::heterogeneous_system_dim_tag, boost::units::detail::static_rational_tag>$/;"	s	namespace:boost::mpl
time_count	/usr/include/boost/date_time/time_system_counted.hpp	/^    int_type time_count() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
time_count_	/usr/include/boost/date_time/time_system_counted.hpp	/^    impl_type time_count_;$/;"	m	struct:boost::date_time::counted_time_rep	access:private
time_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename config::time_duration_type time_duration_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
time_duration_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename time_rep_type::time_duration_type time_duration_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
time_duration_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::time_duration_type time_duration_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
time_point	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef chrono::time_point<steady_clock>  time_point;$/;"	t	class:boost::chrono::steady_clock	access:public
time_point	/usr/include/boost/chrono/system_clocks.hpp	/^      typedef chrono::time_point<system_clock>     time_point;$/;"	t	class:boost::chrono::system_clock	access:public
time_rep_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef time_rep time_rep_type;$/;"	t	class:boost::date_time::counted_time_system	access:public
time_rep_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef typename config::time_rep_type time_rep_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
time_unit_tag	/usr/include/boost/units/systems/abstract.hpp	/^struct time_unit_tag : base_unit<time_unit_tag, time_dimension, -28> { };$/;"	s	namespace:boost::units::abstract	inherits:base_unit
tmatch	/usr/include/boost/regex/mfc.hpp	/^typedef match_results<TCHAR const*> tmatch;$/;"	t	namespace:boost
tod	/usr/include/boost/date_time/time_system_counted.hpp	/^    int_type tod() const$/;"	f	struct:boost::date_time::counted_time_rep	access:public	signature:() const
toi	/usr/include/boost/regex/icu.hpp	/^   int toi(const char_type*& p1, const char_type* p2, int radix)const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(const char_type*& p1, const char_type* p2, int radix) const
toi	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   int toi(const charT*& p1, const charT* p2, int radix)const;$/;"	p	class:boost::cpp_regex_traits	access:public	signature:(const charT*& p1, const charT* p2, int radix) const
toi	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^int cpp_regex_traits<charT>::toi(const charT*& first, const charT* last, int radix)const$/;"	f	class:boost::cpp_regex_traits	signature:(const charT*& first, const charT* last, int radix) const
toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int toi(ForwardIter& i, ForwardIter j, int base)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter& i, ForwardIter j, int base)
toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int toi(ForwardIter& i, ForwardIter j, int base, const boost::mpl::false_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter& i, ForwardIter j, int base, const boost::mpl::false_&)
toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   inline int toi(ForwardIter& i, ForwardIter j, int base, const boost::mpl::true_&)$/;"	f	class:boost::re_detail::basic_regex_formatter	access:private	signature:(ForwardIter& i, ForwardIter j, int base, const boost::mpl::true_&)
toi	/usr/include/boost/regex/v4/regex_format.hpp	/^   int toi(const charT*& p1, const charT* p2, int radix)const$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(const charT*& p1, const charT* p2, int radix) const
toi	/usr/include/boost/regex/v4/regex_traits.hpp	/^   int toi(const char_type*& p1, const char_type* p2, int radix)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(const char_type*& p1, const char_type* p2, int radix) const
toi	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   int toi(const charT*& p1, const charT* p2, int radix)const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT*& p1, const charT* p2, int radix) const
tolower	/usr/include/boost/regex/icu.hpp	/^   char_type tolower(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
tolower	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT tolower(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
tolower	/usr/include/boost/regex/v4/regex_format.hpp	/^   static charT tolower(charT c)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(charT c)
tolower	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type tolower(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   char tolower(char c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(char c) const
tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT tolower(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT tolower(charT c)const$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(charT c) const
tolower	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
tolower	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual Char tolower(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
tolower	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
tolower	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type tolower(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
tolower_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
tolower_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
too_many_files_open	/usr/include/boost/system/error_code.hpp	/^        too_many_files_open = EMFILE,$/;"	e	enum:boost::system::errc::errc_t
too_many_files_open_in_system	/usr/include/boost/system/error_code.hpp	/^        too_many_files_open_in_system = ENFILE,$/;"	e	enum:boost::system::errc::errc_t
too_many_links	/usr/include/boost/system/error_code.hpp	/^        too_many_links = EMLINK,$/;"	e	enum:boost::system::errc::errc_t
too_many_open_files	/usr/include/boost/system/windows_error.hpp	/^        too_many_open_files = ERROR_TOO_MANY_OPEN_FILES,$/;"	e	enum:boost::system::windows_error::windows_error_code
too_many_references	/usr/include/boost/system/linux_error.hpp	/^        too_many_references = ETOOMANYREFS,$/;"	e	enum:boost::system::linux_error::linux_errno
too_many_symbolic_link_levels	/usr/include/boost/system/error_code.hpp	/^        too_many_symbolic_link_levels = ELOOP,$/;"	e	enum:boost::system::errc::errc_t
too_many_users	/usr/include/boost/system/linux_error.hpp	/^        too_many_users = EUSERS,$/;"	e	enum:boost::system::linux_error::linux_errno
top	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct top$/;"	s	namespace:boost::xpressive::op
top	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::top>::type const top = {{}};$/;"	m	class:boost::xpressive::function
torque	/usr/include/boost/units/systems/si/torque.hpp	/^typedef unit<torque_dimension,si::system>     torque;$/;"	t	namespace:boost::units::si
toupper	/usr/include/boost/regex/icu.hpp	/^   char_type toupper(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
toupper	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT toupper(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
toupper	/usr/include/boost/regex/v4/regex_format.hpp	/^   static charT toupper(charT c)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(charT c)
toupper	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type toupper(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
toupper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT toupper(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
toupper	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
toupper	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual Char toupper(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
toupper	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
toupper	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type toupper(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
toupper_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
toupper_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
towctrans	/usr/include/boost/regex/config/cwchar.hpp	44;"	d
towlower	/usr/include/boost/regex/config/cwchar.hpp	/^inline wint_t (towlower)(wint_t i)$/;"	f	signature:(wint_t i)
towlower	/usr/include/boost/regex/config/cwchar.hpp	146;"	d
towlower	/usr/include/boost/regex/config/cwchar.hpp	42;"	d
towupper	/usr/include/boost/regex/config/cwchar.hpp	/^inline wint_t (towupper)(wint_t i)$/;"	f	signature:(wint_t i)
towupper	/usr/include/boost/regex/config/cwchar.hpp	154;"	d
towupper	/usr/include/boost/regex/config/cwchar.hpp	43;"	d
to_vector	/usr/include/boost/xpressive/regex_primitives.hpp	/^    to_vector(Subs const &subs)$/;"	f	namespace:boost::xpressive::detail	signature:(Subs const &subs)
to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> const &to_vector(std::vector<int> const &subs)$/;"	f	class:boost::xpressive::detail::std	signature:(std::vector<int> const &subs)
to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(Int const (&sub_matches)[ Size ])$/;"	f	namespace:boost::xpressive::detail	signature:(Int const (&sub_matches)[ Size ])
to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(int subs)$/;"	f	namespace:boost::xpressive::detail	signature:(int subs)
to_vector	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(std::vector<Int> const &sub_matches)$/;"	f	namespace:boost::xpressive::detail	signature:(std::vector<Int> const &sub_matches)
tr1	/usr/include/boost/tr1/regex.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
traits	/usr/include/boost/geometry/core/coordinate_system.hpp	/^namespace traits$/;"	n	namespace:boost::geometry
traits	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    Traits const &traits() const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:() const
traits	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct traits$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
traits_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<traits<char_type> const> traits_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
traits_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    Traits traits_;$/;"	m	struct:boost::xpressive::detail::traits_holder	access:private
traits_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    CompilerTraits traits_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
traits_holder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    explicit traits_holder(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(Traits const &tr)
traits_holder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^struct traits_holder$/;"	s	namespace:boost::xpressive::detail	inherits:traits
traits_inst	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   const ::boost::regex_traits_wrapper<traits>& traits_inst;$/;"	m	class:boost::re_detail::perl_matcher	access:private
traits_size_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef std::size_t                           traits_size_type;$/;"	t	class:boost::basic_regex	access:public
traits_size_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef std::size_t traits_size_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
traits_string_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef typename traits::string_type          traits_string_type;$/;"	t	class:boost::basic_regex	access:public
traits_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename regex_traits_computer<Regex>::type traits_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
traits_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef traits                                traits_type;$/;"	t	class:boost::basic_regex	access:public
traits_type	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typedef RegexTraits traits_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
transform	/usr/include/boost/regex/concepts.hpp	/^   string_type transform(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
transform	/usr/include/boost/regex/icu.hpp	/^   string_type transform(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
transform	/usr/include/boost/regex/icu.hpp	/^   string_type transform(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const char_type* p1, const char_type* p2) const
transform	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
transform	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
transform	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
transform	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
transform	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
transform	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
transform	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform(FwdIter begin, FwdIter end) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end) const
transform	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
transform	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
transform_primary	/usr/include/boost/regex/concepts.hpp	/^   string_type transform_primary(ForwardIterator , ForwardIterator ) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(ForwardIterator , ForwardIterator ) const
transform_primary	/usr/include/boost/regex/icu.hpp	/^   string_type transform_primary(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(const char_type* p1, const char_type* p2) const
transform_primary	/usr/include/boost/regex/icu.hpp	/^   string_type transform_primary(const char_type* p1, const char_type* p2) const$/;"	f	class:boost::re_detail::icu_regex_traits_implementation	access:public	signature:(const char_type* p1, const char_type* p2) const
transform_primary	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   cpp_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::cpp_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
transform_primary	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
transform_primary	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::cpp_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
transform_primary	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform_primary(const char* p1, const char* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const char* p1, const char* p2)
transform_primary	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform_primary(const unsigned short* p1, const unsigned short* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const unsigned short* p1, const unsigned short* p2)
transform_primary	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static string_type BOOST_REGEX_CALL transform_primary(const wchar_t* p1, const wchar_t* p2);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(const wchar_t* p1, const wchar_t* p2)
transform_primary	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(const charT* p1, const charT* p2) const
transform_primary	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   string_type transform_primary(const charT* p1, const charT* p2) const;$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(const charT* p1, const charT* p2) const
transform_primary	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(const charT* p1, const charT* p2) const
transform_primary	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform_primary(FwdIter begin, FwdIter end) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end) const
transform_primary	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
transform_primary	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
translate	/usr/include/boost/regex/concepts.hpp	/^   charT translate(charT ) const { return charT(); }$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT ) const
translate	/usr/include/boost/regex/icu.hpp	/^   char_type translate(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
translate	/usr/include/boost/regex/icu.hpp	/^   char_type translate(char_type c, bool icase) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c, bool icase) const
translate	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT translate(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
translate	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT translate(charT c, bool icase) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c, bool icase) const
translate	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   char translate(char c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(char c) const
translate	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   unsigned short translate(unsigned short c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(unsigned short c) const
translate	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   wchar_t translate(wchar_t c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(wchar_t c) const
translate	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type translate(char_type c)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c) const
translate	/usr/include/boost/regex/v4/regex_traits.hpp	/^   char_type translate(char_type c, bool icase)const$/;"	f	struct:boost::re_detail::default_wrapper	access:public	signature:(char_type c, bool icase) const
translate	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT translate(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
translate	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT translate(charT c, bool icase) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c, bool icase) const
translate	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
translate	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
translate	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
translate_nocase	/usr/include/boost/regex/concepts.hpp	/^   charT translate_nocase(charT ) const { return static_object<charT>::get(); }$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT ) const
translate_nocase	/usr/include/boost/regex/icu.hpp	/^   char_type translate_nocase(char_type c) const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c) const
translate_nocase	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   charT translate_nocase(charT c) const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c) const
translate_nocase	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   char translate_nocase(char c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(char c) const
translate_nocase	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   unsigned short translate_nocase(unsigned short c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(unsigned short c) const
translate_nocase	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   wchar_t translate_nocase(wchar_t c) const $/;"	f	struct:boost::c_regex_traits	access:public	signature:(wchar_t c) const
translate_nocase	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   charT translate_nocase(charT c) const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c) const
translate_nocase	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type translate_nocase(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
translate_nocase	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
translate_nocase	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
tregex	/usr/include/boost/regex/mfc.hpp	/^typedef basic_regex<TCHAR> tregex;$/;"	t	namespace:boost
tregex_iterator	/usr/include/boost/regex/mfc.hpp	/^typedef regex_iterator<TCHAR const*> tregex_iterator;$/;"	t	namespace:boost
tregex_token_iterator	/usr/include/boost/regex/mfc.hpp	/^typedef regex_token_iterator<TCHAR const*> tregex_token_iterator;$/;"	t	namespace:boost
trivial_format_traits	/usr/include/boost/regex/v4/regex_format.hpp	/^struct trivial_format_traits$/;"	s	namespace:boost::re_detail
type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef regex_search_result<IteratorT> type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
type	/usr/include/boost/filesystem/operations.hpp	/^    file_type  type() const                       { return m_value; }$/;"	f	class:boost::filesystem::file_status	access:public	signature:() const
type	/usr/include/boost/filesystem/operations.hpp	/^    void       type(file_type v)                  { m_value = v; }$/;"	f	class:boost::filesystem::file_status	access:public	signature:(file_type v)
type	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        >::type type;$/;"	t	struct:boost::geometry::coordinate_system	access:public
type	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        typedef typename coordinate_system<point_tag, P>::type type;$/;"	t	struct:boost::geometry::core_dispatch::coordinate_system	access:public
type	/usr/include/boost/geometry/core/coordinate_system.hpp	/^        typedef typename traits::coordinate_system<P>::type type;$/;"	t	struct:boost::geometry::core_dispatch::coordinate_system	access:public
type	/usr/include/boost/regex/concepts.hpp	/^   typedef traits type;$/;"	t	struct:boost::regex_traits_computer	access:public
type	/usr/include/boost/regex/v4/iterator_category.hpp	/^      typedef is_random_imp<I> type;$/;"	t	struct:boost::detail::is_random_imp_selector::rebind	access:public
type	/usr/include/boost/regex/v4/iterator_category.hpp	/^      typedef is_random_pointer_imp<I> type;$/;"	t	struct:boost::detail::is_random_imp_selector::rebind	access:public
type	/usr/include/boost/regex/v4/regex_format.hpp	/^   >::type type;$/;"	t	struct:boost::re_detail::compute_functor_type	access:public
type	/usr/include/boost/regex/v4/regex_format.hpp	/^   >::type type;$/;"	t	struct:boost::re_detail::format_traits	access:public
type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef BaseT type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef default_wrapper<BaseT> type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef default_wrapper<c_regex_traits<char> > type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
type	/usr/include/boost/regex/v4/regex_traits.hpp	/^   typedef default_wrapper<c_regex_traits<wchar_t> > type;$/;"	t	struct:boost::re_detail::compute_wrapper_base	access:public
type	/usr/include/boost/regex/v4/states.hpp	/^   syntax_element_type   type;         \/\/ what kind of state this is$/;"	m	struct:boost::re_detail::re_syntax_base	access:public
type	/usr/include/boost/units/get_system.hpp	/^    typedef System type;$/;"	t	struct:boost::units::get_system	access:public
type	/usr/include/boost/units/get_system.hpp	/^    typedef typename get_system<Unit>::type     type;$/;"	t	struct:boost::units::get_system	access:public
type	/usr/include/boost/units/get_system.hpp	/^    typedef typename get_system<Unit>::type type;$/;"	t	struct:boost::units::get_system	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        > type;$/;"	t	struct:boost::mpl::divides_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        > type;$/;"	t	struct:boost::mpl::plus_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        > type;$/;"	t	struct:boost::mpl::times_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        >::type type;$/;"	t	struct:boost::units::detail::get_scale_list_of_heterogeneous_system_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        >::type type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        >::type type;$/;"	t	struct:boost::units::detail::unscale_heterogeneous_system_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef boost::units::heterogeneous_system_dim<typename T::tag_type, typename mpl::negate<typename T::value_type>::type> type;$/;"	t	struct:boost::mpl::negate_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef dimensionless_type type;$/;"	t	struct:boost::units::detail::get_scale_list_of_heterogeneous_system_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef dimensionless_type type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^        typedef dimensionless_type type;$/;"	t	struct:boost::units::detail::unscale_heterogeneous_system_impl::apply	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::detail::divide_systems	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::detail::multiply_systems	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::static_power	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::static_root	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    > type;$/;"	t	struct:boost::units::unscale	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    >::type type;$/;"	t	struct:boost::units::get_scale_list	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system<heterogeneous_system_impl<unit_list, Dimensions, no_scale> > type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system<T> type;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system_dim type;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef heterogeneous_system_dim<typename unscale<Unit>::type, Exponent> type;$/;"	t	struct:boost::units::unscale	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef L type;$/;"	t	struct:boost::units::heterogeneous_system_impl	access:public
type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef typename static_power<typename get_scale_list<Unit>::type, Exponent>::type type;$/;"	t	struct:boost::units::get_scale_list	access:public
type	/usr/include/boost/units/homogeneous_system.hpp	/^    typedef homogeneous_system<L> type;$/;"	t	struct:boost::units::static_power	access:public
type	/usr/include/boost/units/homogeneous_system.hpp	/^    typedef homogeneous_system<L> type;$/;"	t	struct:boost::units::static_root	access:public
type	/usr/include/boost/units/homogeneous_system.hpp	/^    typedef L type;$/;"	t	struct:boost::units::homogeneous_system	access:public
type	/usr/include/boost/units/make_system.hpp	/^    typedef homogeneous_system<detail::unspecified> type;$/;"	t	struct:boost::units::make_system	access:public
type	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef typename base::type type;$/;"	t	struct:boost::units::power_typeof_helper	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef Expr type;$/;"	t	struct:boost::xpressive::detail::BindArg::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef std::pair<UNCVREF(First), UNCVREF(Second)> type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef typename boost::unwrap_reference<Ref>::type &type;$/;"	t	struct:boost::xpressive::op::unwrap_reference::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef typename Cont::const_reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef typename Cont::reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Cont) &type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Cont)::iterator type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Pair)::first_type type;$/;"	t	struct:boost::xpressive::op::first::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Pair)::second_type type;$/;"	t	struct:boost::xpressive::op::second::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sub)::difference_type type;$/;"	t	struct:boost::xpressive::op::length::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Sub)::string_type type;$/;"	t	struct:boost::xpressive::op::str::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef void type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^            typedef T type;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
type	/usr/include/boost/xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<Fun>::type type;$/;"	t	struct:boost::xpressive::function	access:public
type	/usr/include/boost/xpressive/regex_primitives.hpp	/^            type;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
type_present	/usr/include/boost/filesystem/operations.hpp	/^  inline bool type_present(file_status f) { return f.type() != status_error; }$/;"	f	namespace:boost::filesystem	signature:(file_status f)
type_unknown	/usr/include/boost/filesystem/operations.hpp	/^    type_unknown,  \/\/ file does exist, but isn't one of the above types or$/;"	e	enum:boost::filesystem::file_type
u16match	/usr/include/boost/regex/icu.hpp	/^typedef match_results<const ::UChar*> u16match;$/;"	t	namespace:boost
u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u16_to_u32_iterator() : m_position()$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:()
u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u16_to_u32_iterator(BaseIterator b) : m_position(b)$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:(BaseIterator b)
u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u16_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)$/;"	f	class:boost::u16_to_u32_iterator	access:public	signature:(BaseIterator b, BaseIterator start, BaseIterator end)
u16_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u16_to_u32_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
u32match	/usr/include/boost/regex/icu.hpp	/^typedef match_results<const ::UChar32*> u32match;$/;"	t	namespace:boost
u32regex	/usr/include/boost/regex/icu.hpp	/^typedef basic_regex< ::UChar32, icu_regex_traits> u32regex;$/;"	t	namespace:boost
u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator(){}$/;"	f	class:boost::u32regex_iterator	access:public	signature:()
u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator(BidirectionalIterator a, BidirectionalIterator b, $/;"	f	class:boost::u32regex_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, match_flag_type m = match_default)
u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator(const u32regex_iterator& that)$/;"	f	class:boost::u32regex_iterator	access:public	signature:(const u32regex_iterator& that)
u32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^class u32regex_iterator $/;"	c	namespace:boost	inherits:std::iterator
u32regex_iterator_implementation	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   u32regex_iterator_implementation(const regex_type* p, BidirectionalIterator last, match_flag_type f)$/;"	f	class:boost::u32regex_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, match_flag_type f)
u32regex_iterator_implementation	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^class u32regex_iterator_implementation $/;"	c	namespace:boost
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const char* p, $/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const char* p, $/;"	f	namespace:boost	signature:(const char* p, match_results<const char*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, match_results<std::string::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, match_results<std::wstring::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, match_results<const unsigned char*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_match	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_match(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, match_results<const wchar_t*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator u32regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last, const u32regex& e, const charT* fmt, match_flag_type flags = match_default)
u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator u32regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const u32regex& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline OutputIterator u32regex_replace(OutputIterator out,$/;"	f	namespace:boost	signature:(OutputIterator out, Iterator first, Iterator last, const u32regex& e, const U_NAMESPACE_QUALIFIER UnicodeString& fmt, match_flag_type flags = match_default)
u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline U_NAMESPACE_QUALIFIER UnicodeString u32regex_replace(const U_NAMESPACE_QUALIFIER UnicodeString& s,$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const UChar* fmt, match_flag_type flags = match_default)
u32regex_replace	/usr/include/boost/regex/icu.hpp	/^inline U_NAMESPACE_QUALIFIER UnicodeString u32regex_replace(const U_NAMESPACE_QUALIFIER UnicodeString& s,$/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const U_NAMESPACE_QUALIFIER UnicodeString& fmt, match_flag_type flags = match_default)
u32regex_replace	/usr/include/boost/regex/icu.hpp	/^std::basic_string<charT> u32regex_replace(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const u32regex& e, const charT* fmt, match_flag_type flags = match_default)
u32regex_replace	/usr/include/boost/regex/icu.hpp	/^std::basic_string<charT> u32regex_replace(const std::basic_string<charT>& s,$/;"	f	namespace:boost	signature:(const std::basic_string<charT>& s, const u32regex& e, const std::basic_string<charT>& fmt, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(BidiIterator first, BidiIterator last, $/;"	f	namespace:boost	signature:(BidiIterator first, BidiIterator last, match_results<BidiIterator, Allocator>& m, const u32regex& e, match_flag_type flags, BidiIterator base)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const char* p, $/;"	f	namespace:boost	signature:(const char* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const char* p, $/;"	f	namespace:boost	signature:(const char* p, match_results<const char*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::string& s, $/;"	f	namespace:boost	signature:(const std::string& s, match_results<std::string::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const std::wstring& s, $/;"	f	namespace:boost	signature:(const std::wstring& s, match_results<std::wstring::const_iterator>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const UChar* p, $/;"	f	namespace:boost	signature:(const UChar* p, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const unsigned char* p, $/;"	f	namespace:boost	signature:(const unsigned char* p, match_results<const unsigned char*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const U_NAMESPACE_QUALIFIER UnicodeString& s, $/;"	f	namespace:boost	signature:(const U_NAMESPACE_QUALIFIER UnicodeString& s, match_results<const UChar*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, const u32regex& e, match_flag_type flags = match_default)
u32regex_search	/usr/include/boost/regex/icu.hpp	/^inline bool u32regex_search(const wchar_t* p, $/;"	f	namespace:boost	signature:(const wchar_t* p, match_results<const wchar_t*>& m, const u32regex& e, match_flag_type flags = match_default)
u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(){}$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:()
u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const std::vector<int>& submatches, match_flag_type m = match_default)
u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, $/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, int submatch = 0, match_flag_type m = match_default)
u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const int (&submatches)[N], match_flag_type m = match_default)
u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, const T& submatches, match_flag_type m = match_default)
u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator(const u32regex_token_iterator& that)$/;"	f	class:boost::u32regex_token_iterator	access:public	signature:(const u32regex_token_iterator& that)
u32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^class u32regex_token_iterator $/;"	c	namespace:boost	inherits:std::iterator
u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)
u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)
u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, const T& submatches, match_flag_type f)
u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)$/;"	f	class:boost::u32regex_token_iterator_implementation	access:public	signature:(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
u32regex_token_iterator_implementation	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^class u32regex_token_iterator_implementation $/;"	c	namespace:boost
u32_to_u16_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u16_iterator() : m_position(), m_current(0)$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:()
u32_to_u16_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u16_iterator(BaseIterator b) : m_position(b), m_current(2)$/;"	f	class:boost::u32_to_u16_iterator	access:public	signature:(BaseIterator b)
u32_to_u16_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u32_to_u16_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
u32_to_u8_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u8_iterator() : m_position(), m_current(0)$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:()
u32_to_u8_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u32_to_u8_iterator(BaseIterator b) : m_position(b), m_current(4)$/;"	f	class:boost::u32_to_u8_iterator	access:public	signature:(BaseIterator b)
u32_to_u8_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u32_to_u8_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u8_to_u32_iterator() : m_position()$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:()
u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u8_to_u32_iterator(BaseIterator b) : m_position(b)$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:(BaseIterator b)
u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   u8_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)$/;"	f	class:boost::u8_to_u32_iterator	access:public	signature:(BaseIterator b, BaseIterator start, BaseIterator end)
u8_to_u32_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class u8_to_u32_iterator$/;"	c	namespace:boost	inherits:boost::iterator_facade
uchar_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef unsigned char uchar_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
uchar_type	/usr/include/boost/regex/v4/char_regex_traits.hpp	/^   typedef unsigned short uchar_type;$/;"	t	class:boost::deprecated::char_regex_traits_i	access:public
umaskex_bits	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    int const umaskex_bits = (14 > (sizeof(umask_t) * CHAR_BIT)) ? 14 : sizeof(umask_t) * CHAR_BIT;$/;"	m	namespace:boost::xpressive::detail
umaskex_t	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<umaskex_bits>::fast umaskex_t;$/;"	t	namespace:boost::xpressive::detail
umask_t	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<sizeof(std::ctype_base::mask) * CHAR_BIT>::least umask_t;$/;"	t	namespace:boost::xpressive::detail
unary_binary_ternary	/usr/include/boost/regex/v4/regex_format.hpp	/^struct unary_binary_ternary$/;"	s	namespace:boost::re_detail
unary_fun	/usr/include/boost/regex/v4/regex_format.hpp	/^    typedef unary_type (*unary_fun)(any_type);$/;"	t	struct:boost::re_detail::unary_binary_ternary	access:public
unary_type	/usr/include/boost/regex/v4/regex_format.hpp	/^typedef char (&unary_type)[2];$/;"	t	namespace:boost::re_detail
unattached	/usr/include/boost/system/linux_error.hpp	/^        unattached = EUNATCH,$/;"	e	enum:boost::system::linux_error::linux_errno
uncertainty	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type uncertainty() const { return Base().uncertainty(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
uncertainty	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type uncertainty() const { return Base().uncertainty(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
unclean	/usr/include/boost/system/linux_error.hpp	/^        unclean = EUCLEAN$/;"	e	enum:boost::system::linux_error::linux_errno
UNCVREF	/usr/include/boost/xpressive/regex_actions.hpp	59;"	d
UNCVREF	/usr/include/boost/xpressive/regex_actions.hpp	998;"	d
unescape_character	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   charT unescape_character();$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:()
unescape_character	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^charT basic_regex_parser<charT, traits>::unescape_character()$/;"	f	class:boost::re_detail::basic_regex_parser	signature:()
UNICODE	/usr/include/boost/regex/config.hpp	69;"	d
unicode_string_out_iterator	/usr/include/boost/regex/icu.hpp	/^   unicode_string_out_iterator(U_NAMESPACE_QUALIFIER UnicodeString& s) : out(&s) {}$/;"	f	class:boost::re_detail::unicode_string_out_iterator	access:public	signature:(U_NAMESPACE_QUALIFIER UnicodeString& s)
unicode_string_out_iterator	/usr/include/boost/regex/icu.hpp	/^class unicode_string_out_iterator$/;"	c	namespace:boost::re_detail
unique_path	/usr/include/boost/filesystem/operations.hpp	/^    path unique_path(const path& p, system::error_code* ec=0);$/;"	p	namespace:boost::filesystem::detail	signature:(const path& p, system::error_code* ec=0)
unique_path	/usr/include/boost/filesystem/operations.hpp	/^  path unique_path(const path& p, system::error_code& ec)$/;"	f	namespace:boost::filesystem	signature:(const path& p, system::error_code& ec)
unique_path	/usr/include/boost/filesystem/operations.hpp	/^  path unique_path(const path& p="%%%%-%%%%-%%%%-%%%%")$/;"	f	namespace:boost::filesystem	signature:(const path& p=)
units	/usr/include/boost/units/get_system.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/heterogeneous_system.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/homogeneous_system.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/is_quantity_of_system.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/is_unit_of_system.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/make_system.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/systems/abstract.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/systems/angle/degrees.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/systems/angle/gradians.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/systems/angle/revolutions.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/acceleration.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/area.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/base.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/current.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/dimensionless.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/dynamic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/energy.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/force.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/frequency.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/io.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/kinematic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/length.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/mass.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/mass_density.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/momentum.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/power.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/pressure.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/time.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/velocity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/volume.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/detail/constants.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/absorbed_dose.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/acceleration.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/action.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/activity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/amount.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/angular_acceleration.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/angular_momentum.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/angular_velocity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/area.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/base.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/capacitance.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/catalytic_activity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/alpha_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/atomic-nuclear_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/deuteron_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/electromagnetic_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/electron_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/helion_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/muon_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/neutron_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/physico-chemical_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/proton_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/tau_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/triton_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/codata/universal_constants.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/conductance.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/conductivity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/current.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/dimensionless.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/dose_equivalent.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/dynamic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/electric_charge.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/electric_potential.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/energy.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/force.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/frequency.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/illuminance.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/impedance.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/inductance.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/io.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/kinematic_viscosity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/length.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/luminous_flux.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/luminous_intensity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/magnetic_field_intensity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/magnetic_flux.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/magnetic_flux_density.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/mass.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/mass_density.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/momentum.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/moment_of_inertia.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/permeability.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/permittivity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/plane_angle.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/power.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/prefixes.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/pressure.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/reluctance.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/resistance.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/resistivity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/solid_angle.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/surface_density.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/surface_tension.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/temperature.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/time.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/torque.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/velocity.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/volume.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/si/wavenumber.hpp	/^namespace units { $/;"	n	namespace:boost
units	/usr/include/boost/units/systems/temperature/celsius.hpp	/^namespace units {$/;"	n	namespace:boost
units	/usr/include/boost/units/systems/temperature/fahrenheit.hpp	/^namespace units {$/;"	n	namespace:boost
unit_list	/usr/include/boost/units/heterogeneous_system.hpp	/^    >::type unit_list;$/;"	t	struct:boost::units::detail::make_heterogeneous_system	access:public
unlock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   void unlock();$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:()
UNREF	/usr/include/boost/xpressive/regex_actions.hpp	55;"	d
UNREF	/usr/include/boost/xpressive/regex_actions.hpp	997;"	d
unscale	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale<heterogeneous_system<T> >$/;"	s	namespace:boost::units
unscale	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale<heterogeneous_system_dim<Unit, Exponent> >$/;"	s	namespace:boost::units
unscale_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale_heterogeneous_system_impl$/;"	s	namespace:boost::units::detail
unscale_heterogeneous_system_impl	/usr/include/boost/units/heterogeneous_system.hpp	/^struct unscale_heterogeneous_system_impl<0>$/;"	s	namespace:boost::units::detail
unsetf	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   void unsetf(match_flag_type f)$/;"	f	class:boost::re_detail::perl_matcher	access:public	signature:(match_flag_type f)
unspecified	/usr/include/boost/units/make_system.hpp	/^struct unspecified {};$/;"	s	namespace:boost::units::detail
unspecified_bool_true	/usr/include/boost/system/error_code.hpp	/^      static void unspecified_bool_true() {}$/;"	f	class:boost::system::error_code	access:public	signature:()
unspecified_bool_true	/usr/include/boost/system/error_code.hpp	/^      static void unspecified_bool_true() {}$/;"	f	class:boost::system::error_condition	access:public	signature:()
unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      typedef void (*unspecified_bool_type)();$/;"	t	class:boost::system::error_code	access:public
unspecified_bool_type	/usr/include/boost/system/error_code.hpp	/^      typedef void (*unspecified_bool_type)();$/;"	t	class:boost::system::error_condition	access:public
unused_mask	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask$/;"	s	namespace:boost::xpressive::detail
unused_mask	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask<In, Out, true>$/;"	s	namespace:boost::xpressive::detail
unused_var	/usr/include/boost/date_time/time_system_counted.hpp	/^    template<class T> static void unused_var(const T&) {}$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const T&)
unwind	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind(bool have_match)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool have_match)
unwind_alt	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_alt(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_alt	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_alt(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_alts	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^   bool unwind_alts(std::ptrdiff_t last_paren_start);$/;"	p	class:boost::re_detail::basic_regex_parser	access:public	signature:(std::ptrdiff_t last_paren_start)
unwind_alts	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool basic_regex_parser<charT, traits>::unwind_alts(std::ptrdiff_t last_paren_start)$/;"	f	class:boost::re_detail::basic_regex_parser	signature:(std::ptrdiff_t last_paren_start)
unwind_assertion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_assertion(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_assertion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_char_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_char_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_char_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_end	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_end(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_end	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_end(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
unwind_extra_block	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_extra_block(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_extra_block	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
unwind_fast_dot_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_fast_dot_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_fast_dot_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_greedy_single_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_greedy_single_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_greedy_single_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_long_set_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_long_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_non_greedy_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_non_greedy_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_paren	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_paren(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_paren	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_paren(bool have_match)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool have_match)
unwind_proc_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef bool (self_type::*unwind_proc_type)(bool);$/;"	t	class:boost::re_detail::perl_matcher	access:private
unwind_recursion	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_recursion(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_recursion	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_recursion_pop	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_recursion_pop(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_recursion_pop	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_pop(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_recursion_stopper(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_recursion_stopper	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
unwind_repeater_counter	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_repeater_counter(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_repeater_counter	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter(bool)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool)
unwind_short_set_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_short_set_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_short_set_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwind_slow_dot_repeat	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   bool unwind_slow_dot_repeat(bool);$/;"	p	class:boost::re_detail::perl_matcher	access:private	signature:(bool)
unwind_slow_dot_repeat	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^bool perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat(bool r)$/;"	f	class:boost::re_detail::perl_matcher	signature:(bool r)
unwrap_reference	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct unwrap_reference$/;"	s	namespace:boost::xpressive::op
unwrap_reference	/usr/include/boost/xpressive/regex_actions.hpp	/^    function<op::unwrap_reference>::type const unwrap_reference = {{}};$/;"	m	class:boost::xpressive::function
upper	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const upper = {{"upper", false}};$/;"	m	class:boost::xpressive::proto::terminal
upper_	/usr/include/boost/xpressive/regex_compiler.hpp	/^    typename RegexTraits::char_class_type upper_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
upper_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type upper_bound() const { return Base().upper_bound(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
upper_bound	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type upper_bound() const { return Base().upper_bound(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
used_block_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   unsigned used_block_count;$/;"	m	class:boost::re_detail::perl_matcher	access:private
utf16regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^typedef u32regex_iterator<const UChar*> utf16regex_iterator;$/;"	t	namespace:boost
utf16regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^typedef u32regex_token_iterator<const UChar*> utf16regex_token_iterator;$/;"	t	namespace:boost
utf16_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator(const BaseIterator& b)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(const BaseIterator& b)
utf16_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf16_output_iterator(const utf16_output_iterator& that)$/;"	f	class:boost::utf16_output_iterator	access:public	signature:(const utf16_output_iterator& that)
utf16_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class utf16_output_iterator$/;"	c	namespace:boost
utf32regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^typedef u32regex_iterator<const UChar32*> utf32regex_iterator;$/;"	t	namespace:boost
utf32regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^typedef u32regex_token_iterator<const UChar32*> utf32regex_token_iterator;$/;"	t	namespace:boost
utf8regex_iterator	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^typedef u32regex_iterator<const char*> utf8regex_iterator;$/;"	t	namespace:boost
utf8regex_token_iterator	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^typedef u32regex_token_iterator<const char*> utf8regex_token_iterator;$/;"	t	namespace:boost
utf8_byte_count	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline unsigned utf8_byte_count(boost::uint8_t c)$/;"	f	namespace:boost::detail	signature:(boost::uint8_t c)
utf8_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator(const BaseIterator& b)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(const BaseIterator& b)
utf8_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   utf8_output_iterator(const utf8_output_iterator& that)$/;"	f	class:boost::utf8_output_iterator	access:public	signature:(const utf8_output_iterator& that)
utf8_output_iterator	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^class utf8_output_iterator$/;"	c	namespace:boost
utf8_trailing_byte_count	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^inline unsigned utf8_trailing_byte_count(boost::uint8_t c)$/;"	f	namespace:boost::detail	signature:(boost::uint8_t c)
util	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost::wave
val	/usr/include/boost/xpressive/regex_actions.hpp	/^    value<T> const val(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
valid	/usr/include/boost/regex/v4/fileiter.hpp	/^   bool valid(){ return (hfile != 0) && (hfile != INVALID_HANDLE_VALUE); }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
valid_value	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool valid_value(charT c, int v)$/;"	f	namespace:boost::re_detail	signature:(charT c, int v)
valid_value	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool valid_value(charT, int v, const mpl::true_&)$/;"	f	namespace:boost::re_detail	signature:(charT, int v, const mpl::true_&)
valid_value	/usr/include/boost/regex/v4/basic_regex_parser.hpp	/^bool valid_value(charT, int, const mpl::false_&)$/;"	f	namespace:boost::re_detail	signature:(charT, int, const mpl::false_&)
value	/usr/include/boost/filesystem/path_traits.hpp	/^  struct is_pathable { static const bool value = false; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<char*>                  { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const char*>            { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<const wchar_t*>         { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<directory_entry>        { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<char> >       { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::list<wchar_t> >    { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::string>            { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<char> >     { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::vector<wchar_t> >  { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<std::wstring>           { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/filesystem/path_traits.hpp	/^  template<> struct is_pathable<wchar_t*>               { static const bool value = true; };$/;"	m	struct:boost::filesystem::path_traits::is_pathable	access:public
value	/usr/include/boost/regex/concepts.hpp	/^   int value(charT, int) const$/;"	f	struct:boost::regex_traits_architype	access:public	signature:(charT, int) const
value	/usr/include/boost/regex/icu.hpp	/^   int value(char_type c, int radix)const$/;"	f	class:boost::icu_regex_traits	access:public	signature:(char_type c, int radix) const
value	/usr/include/boost/regex/v4/cpp_regex_traits.hpp	/^   int value(charT c, int radix)const$/;"	f	class:boost::cpp_regex_traits	access:public	signature:(charT c, int radix) const
value	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static int BOOST_REGEX_CALL value(char, int);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(char, int)
value	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static int BOOST_REGEX_CALL value(unsigned short, int);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(unsigned short, int)
value	/usr/include/boost/regex/v4/c_regex_traits.hpp	/^   static int BOOST_REGEX_CALL value(wchar_t, int);$/;"	p	struct:boost::c_regex_traits	access:public	signature:(wchar_t, int)
value	/usr/include/boost/regex/v4/iterator_category.hpp	/^const bool is_random_access_iterator<I>::value;$/;"	m	class:boost::is_random_access_iterator
value	/usr/include/boost/regex/v4/regex_format.hpp	/^   static int value(const charT c, int radix)$/;"	f	struct:boost::re_detail::trivial_format_traits	access:public	signature:(const charT c, int radix)
value	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   int value(charT c, int radix)const$/;"	f	class:boost::w32_regex_traits	access:public	signature:(charT c, int radix) const
value	/usr/include/boost/system/cygwin_error.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
value	/usr/include/boost/system/error_code.hpp	/^      int                     value() const    { return m_val; }$/;"	f	class:boost::system::error_code	access:public	signature:() const
value	/usr/include/boost/system/error_code.hpp	/^      int                     value() const    { return m_val; }$/;"	f	class:boost::system::error_condition	access:public	signature:() const
value	/usr/include/boost/system/error_code.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_condition_enum	access:public
value	/usr/include/boost/system/error_code.hpp	/^    struct is_error_code_enum { static const bool value = false; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
value	/usr/include/boost/system/error_code.hpp	/^    struct is_error_condition_enum { static const bool value = false; };$/;"	m	struct:boost::system::is_error_condition_enum	access:public
value	/usr/include/boost/system/linux_error.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
value	/usr/include/boost/system/windows_error.hpp	/^      { static const bool value = true; };$/;"	m	struct:boost::system::is_error_code_enum	access:public
value	/usr/include/boost/units/systems/detail/constants.hpp	/^    static type value(const constant<T1>& arg)$/;"	f	struct:boost::units::power_typeof_helper	access:public	signature:(const constant<T1>& arg)
value	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type value() const       { return Base().value(); } $/;"	f	struct:boost::units::constant	access:public	signature:() const
value	/usr/include/boost/units/systems/detail/constants.hpp	/^    value_type value() const       { return Base().value(); } $/;"	f	struct:boost::units::physical_constant	access:public	signature:() const
value	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch, int radix) const
value	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual int value(Char ch, int radix) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch, int radix) const
value	/usr/include/boost/xpressive/regex_actions.hpp	/^            T value;$/;"	m	struct:boost::xpressive::detail::value_wrapper	access:public
value	/usr/include/boost/xpressive/regex_actions.hpp	/^        explicit value(T const &t)$/;"	f	struct:boost::xpressive::value	access:public	signature:(T const &t)
value	/usr/include/boost/xpressive/regex_actions.hpp	/^        value()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
value	/usr/include/boost/xpressive/regex_actions.hpp	/^    struct value$/;"	s	namespace:boost::xpressive	inherits:proto::extends
value	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, int radix) const
value	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const mask_cast<Mask>::value;$/;"	m	class:boost::xpressive::detail::mask_cast
value	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const unused_mask<In, Out, Done>::value;$/;"	m	class:boost::xpressive::detail::unused_mask
value	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static int value(char_type ch, int radix);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, int radix)
value	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<char>::value(char ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch, int radix)
value	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<wchar_t>::value(wchar_t ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch, int radix)
value	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    static int value(char_type ch, int radix)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, int radix)
value_too_large	/usr/include/boost/system/error_code.hpp	/^        value_too_large = EOVERFLOW,$/;"	e	enum:boost::system::errc::errc_t
value_type	/usr/include/boost/algorithm/string/detail/finder_regex.hpp	/^                typedef BOOST_STRING_TYPENAME base_type::value_type value_type;$/;"	t	struct:boost::algorithm::detail::regex_search_result	access:public
value_type	/usr/include/boost/filesystem/path.hpp	/^    typedef wchar_t                        value_type;$/;"	t	class:boost::filesystem::path	access:public
value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef T value_type;$/;"	t	class:allocator_architype	access:public
value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::value_type value_type;$/;"	t	struct:boost::BaseRegexConcept	access:public
value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::value_type value_type;$/;"	t	struct:boost::BoostRegexConcept	access:public
value_type	/usr/include/boost/regex/concepts.hpp	/^   typedef typename Regex::value_type value_type;$/;"	t	struct:boost::RegexConcept	access:public
value_type	/usr/include/boost/regex/icu.hpp	/^   typedef UChar value_type;$/;"	t	class:boost::re_detail::unicode_string_out_iterator	access:public
value_type	/usr/include/boost/regex/mfc.hpp	/^   typedef B value_type;$/;"	t	class:boost::re_detail::mfc_string_out_iterator	access:public
value_type	/usr/include/boost/regex/pending/object_cache.hpp	/^   typedef std::pair< ::boost::shared_ptr<Object const>, Key const*> value_type;$/;"	t	class:boost::object_cache	access:public
value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   value_type;$/;"	t	class:boost::utf16_output_iterator	access:public
value_type	/usr/include/boost/regex/pending/unicode_iterator.hpp	/^   typedef void                                   value_type;$/;"	t	class:boost::utf8_output_iterator	access:public
value_type	/usr/include/boost/regex/v4/basic_regex.hpp	/^   typedef charT                                 value_type;$/;"	t	class:boost::basic_regex	access:public
value_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*               value_type;$/;"	t	class:boost::re_detail::directory_iterator	access:public
value_type	/usr/include/boost/regex/v4/fileiter.hpp	/^   typedef const char*               value_type;$/;"	t	class:boost::re_detail::file_iterator	access:public
value_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T value_type;$/;"	t	struct:boost::re_detail::const_pointer_iterator_traits	access:public
value_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^   typedef T value_type;$/;"	t	struct:boost::re_detail::pointer_iterator_traits	access:public
value_type	/usr/include/boost/regex/v4/iterator_traits.hpp	/^  typedef typename T::value_type        value_type;$/;"	t	struct:boost::re_detail::regex_iterator_traits	access:public
value_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          sub_match<BidiIterator>                         value_type;$/;"	t	class:boost::match_results	access:public
value_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename Results::value_type value_type;$/;"	t	struct:boost::re_detail::recursion_info	access:public
value_type	/usr/include/boost/regex/v4/regex_format.hpp	/^   typedef typename S::value_type value_type;$/;"	t	class:boost::re_detail::string_out_iterator	access:public
value_type	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   typedef          match_results<BidirectionalIterator>                    value_type;$/;"	t	class:boost::regex_iterator	access:public
value_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef          sub_match<BidirectionalIterator>                        value_type;$/;"	t	class:boost::regex_token_iterator	access:public
value_type	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   typedef sub_match<BidirectionalIterator>      value_type;$/;"	t	class:boost::regex_token_iterator_implementation	access:private
value_type	/usr/include/boost/regex/v4/sub_match.hpp	/^   typedef typename re_detail::regex_iterator_traits<BidiIterator>::value_type       value_type;$/;"	t	struct:boost::sub_match	access:public
value_type	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   typedef          match_results<BidirectionalIterator>                    value_type;$/;"	t	class:boost::u32regex_iterator	access:public
value_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef          sub_match<BidirectionalIterator>                        value_type;$/;"	t	class:boost::u32regex_token_iterator	access:public
value_type	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   typedef sub_match<BidirectionalIterator>      value_type;$/;"	t	class:boost::u32regex_token_iterator_implementation	access:private
value_type	/usr/include/boost/units/heterogeneous_system.hpp	/^    typedef Exponent value_type;$/;"	t	struct:boost::units::heterogeneous_system_dim	access:public
value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef typename Base::value_type value_type; $/;"	t	struct:boost::units::constant	access:public
value_type	/usr/include/boost/units/systems/detail/constants.hpp	/^    typedef typename Base::value_type value_type; $/;"	t	struct:boost::units::physical_constant	access:public
value_type	/usr/include/boost/xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type value_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
value_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef UNREF(Value) value_type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
value_type	/usr/include/boost/xpressive/regex_iterator.hpp	/^    typedef match_results<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
value_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
value_type	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
value_wrapper	/usr/include/boost/xpressive/regex_actions.hpp	/^            value_wrapper()$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:()
value_wrapper	/usr/include/boost/xpressive/regex_actions.hpp	/^            value_wrapper(T const &t)$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:(T const &t)
value_wrapper	/usr/include/boost/xpressive/regex_actions.hpp	/^        struct value_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
vector_type	/usr/include/boost/iostreams/filter/regex.hpp	/^    typedef typename base_type::vector_type       vector_type;$/;"	t	class:boost::iostreams::basic_regex_filter	access:private
vector_type	/usr/include/boost/regex/v4/match_results.hpp	/^   typedef          std::vector<sub_match<BidiIterator>, Allocator> vector_type;$/;"	t	class:boost::match_results	access:private
velocity	/usr/include/boost/units/systems/cgs/velocity.hpp	/^typedef unit<velocity_dimension,cgs::system>     velocity;$/;"	t	namespace:boost::units::cgs
velocity	/usr/include/boost/units/systems/si/velocity.hpp	/^typedef unit<velocity_dimension,si::system>      velocity;$/;"	t	namespace:boost::units::si
verify_options	/usr/include/boost/regex/v4/perl_matcher.hpp	/^BOOST_REGEX_DECL void BOOST_REGEX_CALL verify_options(boost::regex_constants::syntax_option_type ef, match_flag_type mf);$/;"	p	namespace:boost::re_detail	signature:(boost::regex_constants::syntax_option_type ef, match_flag_type mf)
version_tag	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
version_tag	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
version_tag	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    typedef regex_traits_version_1_tag version_tag;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
volume	/usr/include/boost/units/systems/cgs/volume.hpp	/^typedef unit<volume_dimension,cgs::system>   volume;$/;"	t	namespace:boost::units::cgs
volume	/usr/include/boost/units/systems/si/volume.hpp	/^typedef unit<volume_dimension,si::system>    volume;$/;"	t	namespace:boost::units::si
volume_over_mass_time_squared	/usr/include/boost/units/systems/si/codata/typedefs.hpp	/^        >::type volume_over_mass_time_squared;$/;"	t	namespace:boost::units::si::constants::codata
w32_cat_get	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::basic_string<unsigned short> BOOST_REGEX_CALL w32_cat_get(const cat_type& cat, lcid_type, int i, const std::basic_string<unsigned short>& def);$/;"	p	namespace:boost::re_detail	signature:(const cat_type& cat, lcid_type, int i, const std::basic_string<unsigned short>& def)
w32_cat_get	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::string BOOST_REGEX_CALL w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::string& def);$/;"	p	namespace:boost::re_detail	signature:(const cat_type& cat, lcid_type state_id, int i, const std::string& def)
w32_cat_get	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::wstring BOOST_REGEX_CALL w32_cat_get(const cat_type& cat, lcid_type state_id, int i, const std::wstring& def);$/;"	p	namespace:boost::re_detail	signature:(const cat_type& cat, lcid_type state_id, int i, const std::wstring& def)
w32_cat_open	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL cat_type BOOST_REGEX_CALL w32_cat_open(const std::string& name);$/;"	p	namespace:boost::re_detail	signature:(const std::string& name)
w32_get_default_locale	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL lcid_type BOOST_REGEX_CALL w32_get_default_locale();$/;"	p	namespace:boost::re_detail	signature:()
w32_is	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is(lcid_type state_id, boost::uint32_t m, unsigned short c);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, boost::uint32_t m, unsigned short c)
w32_is	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is(lcid_type, boost::uint32_t mask, char c);$/;"	p	namespace:boost::re_detail	signature:(lcid_type, boost::uint32_t mask, char c)
w32_is	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is(lcid_type, boost::uint32_t mask, wchar_t c);$/;"	p	namespace:boost::re_detail	signature:(lcid_type, boost::uint32_t mask, wchar_t c)
w32_is_lower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_lower(char, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char, lcid_type)
w32_is_lower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_lower(unsigned short ca, lcid_type state_id);$/;"	p	namespace:boost::re_detail	signature:(unsigned short ca, lcid_type state_id)
w32_is_lower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_lower(wchar_t, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t, lcid_type)
w32_is_upper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_upper(char, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char, lcid_type)
w32_is_upper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_upper(unsigned short ca, lcid_type state_id);$/;"	p	namespace:boost::re_detail	signature:(unsigned short ca, lcid_type state_id)
w32_is_upper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL bool BOOST_REGEX_CALL w32_is_upper(wchar_t, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t, lcid_type)
w32_regex_traits	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits()$/;"	f	class:boost::w32_regex_traits	access:public	signature:()
w32_regex_traits	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class w32_regex_traits$/;"	c	namespace:boost
w32_regex_traits_base	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_base(lcid_type l)$/;"	f	struct:boost::re_detail::w32_regex_traits_base	access:public	signature:(lcid_type l)
w32_regex_traits_base	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^struct w32_regex_traits_base$/;"	s	namespace:boost::re_detail
w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_char_layer(::boost::re_detail::lcid_type l)$/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(::boost::re_detail::lcid_type l)
w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_char_layer(const lcid_type l);$/;"	p	class:boost::re_detail::w32_regex_traits_char_layer	access:public	signature:(const lcid_type l)
w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class BOOST_REGEX_DECL w32_regex_traits_char_layer<char> : public w32_regex_traits_base<char>$/;"	c	namespace:boost::re_detail	inherits:w32_regex_traits_base
w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class w32_regex_traits_char_layer : public w32_regex_traits_base<charT>$/;"	c	namespace:boost::re_detail	inherits:w32_regex_traits_base
w32_regex_traits_char_layer	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^w32_regex_traits_char_layer<charT>::w32_regex_traits_char_layer(::boost::re_detail::lcid_type l) $/;"	f	class:boost::re_detail::w32_regex_traits_char_layer	signature:(::boost::re_detail::lcid_type l)
w32_regex_traits_implementation	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^   w32_regex_traits_implementation(::boost::re_detail::lcid_type l);$/;"	p	class:boost::re_detail::w32_regex_traits_implementation	access:public	signature:(::boost::re_detail::lcid_type l)
w32_regex_traits_implementation	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^class w32_regex_traits_implementation : public w32_regex_traits_char_layer<charT>$/;"	c	namespace:boost::re_detail	inherits:w32_regex_traits_char_layer
w32_regex_traits_implementation	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^w32_regex_traits_implementation<charT>::w32_regex_traits_implementation(::boost::re_detail::lcid_type l)$/;"	f	class:boost::re_detail::w32_regex_traits_implementation	signature:(::boost::re_detail::lcid_type l)
w32_tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL w32_tolower(char c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char c, lcid_type)
w32_tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL unsigned short BOOST_REGEX_CALL w32_tolower(unsigned short c, lcid_type state_id);$/;"	p	namespace:boost::re_detail	signature:(unsigned short c, lcid_type state_id)
w32_tolower	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL w32_tolower(wchar_t c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c, lcid_type)
w32_toupper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL char BOOST_REGEX_CALL w32_toupper(char c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(char c, lcid_type)
w32_toupper	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL wchar_t BOOST_REGEX_CALL w32_toupper(wchar_t c, lcid_type);$/;"	p	namespace:boost::re_detail	signature:(wchar_t c, lcid_type)
w32_transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::basic_string<unsigned short> BOOST_REGEX_CALL w32_transform(lcid_type state_id, const unsigned short* p1, const unsigned short* p2);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, const unsigned short* p1, const unsigned short* p2)
w32_transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::string BOOST_REGEX_CALL w32_transform(lcid_type state_id, const char* p1, const char* p2);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, const char* p1, const char* p2)
w32_transform	/usr/include/boost/regex/v4/w32_regex_traits.hpp	/^BOOST_REGEX_DECL std::wstring BOOST_REGEX_CALL w32_transform(lcid_type state_id, const wchar_t* p1, const wchar_t* p2);$/;"	p	namespace:boost::re_detail	signature:(lcid_type state_id, const wchar_t* p1, const wchar_t* p2)
wave	/usr/include/boost/wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost
wavenumber	/usr/include/boost/units/systems/cgs/wavenumber.hpp	/^typedef unit<wavenumber_dimension,cgs::system>   wavenumber;$/;"	t	namespace:boost::units::cgs
wavenumber	/usr/include/boost/units/systems/si/wavenumber.hpp	/^typedef unit<wavenumber_dimension,si::system>    wavenumber;$/;"	t	namespace:boost::units::si
wcmatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<const wchar_t*> wcmatch;$/;"	t	namespace:boost
wcregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<const wchar_t*> wcregex_iterator;$/;"	t	namespace:boost
wcregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<const wchar_t*> wcregex_token_iterator;$/;"	t	namespace:boost
wcscmp	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (wcscmp)(const wchar_t *p1, const wchar_t *p2)$/;"	f	signature:(const wchar_t *p1, const wchar_t *p2)
wcscmp	/usr/include/boost/regex/config/cwchar.hpp	162;"	d
wcscoll	/usr/include/boost/regex/config/cwchar.hpp	/^inline int (wcscoll)(const wchar_t *p1, const wchar_t *p2)$/;"	f	signature:(const wchar_t *p1, const wchar_t *p2)
wcscoll	/usr/include/boost/regex/config/cwchar.hpp	170;"	d
wcscpy	/usr/include/boost/regex/config/cwchar.hpp	/^inline wchar_t *(wcscpy)(wchar_t *p1, const wchar_t *p2)$/;"	f	signature:(wchar_t *p1, const wchar_t *p2)
wcscpy	/usr/include/boost/regex/config/cwchar.hpp	178;"	d
wcslen	/usr/include/boost/regex/config/cwchar.hpp	/^inline size_t (wcslen)(const wchar_t *p)$/;"	f	signature:(const wchar_t *p)
wcslen	/usr/include/boost/regex/config/cwchar.hpp	186;"	d
wcsub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<const wchar_t*> wcsub_match;$/;"	t	namespace:boost
wcsxfrm	/usr/include/boost/regex/config/cwchar.hpp	/^size_t wcsxfrm(wchar_t *p1, const wchar_t *p2, size_t s)$/;"	f	signature:(wchar_t *p1, const wchar_t *p2, size_t s)
wcsxfrm	/usr/include/boost/regex/config/cwchar.hpp	194;"	d
wctrans	/usr/include/boost/regex/config/cwchar.hpp	45;"	d
wctype	/usr/include/boost/regex/config/cwchar.hpp	46;"	d
wfilebuf	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_filebuf<wchar_t> wfilebuf;$/;"	t	namespace:boost::filesystem
wfstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_fstream<wchar_t> wfstream;$/;"	t	namespace:boost::filesystem
what	/usr/include/boost/filesystem/operations.hpp	/^    const char* what() const throw()$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:() const
What	/usr/include/boost/regex/v4/cregex.hpp	/^   std::string What(int i = 0)const;$/;"	p	class:boost::RegEx	access:public	signature:(int i = 0) const
what	/usr/include/boost/regex/v4/regex_iterator.hpp	/^   match_results<BidirectionalIterator> what;  \/\/ current match$/;"	m	class:boost::regex_iterator_implementation	access:private
what	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^   match_results<BidirectionalIterator> what;   \/\/ current match$/;"	m	class:boost::regex_token_iterator_implementation	access:private
what	/usr/include/boost/regex/v4/u32regex_iterator.hpp	/^   match_results<BidirectionalIterator> what;  \/\/ current match$/;"	m	class:boost::u32regex_iterator_implementation	access:private
what	/usr/include/boost/regex/v4/u32regex_token_iterator.hpp	/^   match_results<BidirectionalIterator> what;   \/\/ current match$/;"	m	class:boost::u32regex_token_iterator_implementation	access:private
what	/usr/include/boost/system/system_error.hpp	/^      const char *        what() const throw();$/;"	p	class:boost::system::system_error	access:public	signature:() const
what	/usr/include/boost/system/system_error.hpp	/^    inline const char * system_error::what() const throw()$/;"	f	class:boost::system::system_error	signature:() const
what	/usr/include/boost/xpressive/regex_algorithms.hpp	/^      , match_results<BidiIter> &what$/;"	m	namespace:boost::xpressive::detail
what_	/usr/include/boost/xpressive/regex_iterator.hpp	/^    match_results<BidiIter> what_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
widen	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char ch) const
widen	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^    static char_type widen(char ch);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char ch)
widen	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline char c_regex_traits<char>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
widen	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^inline wchar_t c_regex_traits<wchar_t>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
widen	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char ch) const
width_type	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   typedef typename is_byte<char_type>::width_type width_type;$/;"	t	class:boost::re_detail::perl_matcher	access:public
width_type	/usr/include/boost/regex/v4/states.hpp	/^template <class charT> struct is_byte               { typedef _wide_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
width_type	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<char>         { typedef _narrow_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
width_type	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<signed char>  { typedef _narrow_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
width_type	/usr/include/boost/regex/v4/states.hpp	/^template<>             struct is_byte<unsigned char>{ typedef _narrow_type width_type; };$/;"	t	struct:boost::re_detail::is_byte	access:public
wifstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ifstream<wchar_t> wifstream;$/;"	t	namespace:boost::filesystem
wimpl_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        weak_ptr<regex_impl<BidiIter> > wimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
win32	/usr/include/boost/detail/win/system.hpp	/^namespace win32 {$/;"	n	namespace:boost::detail
WIN32_LEAN_AND_MEAN	/usr/include/boost/iostreams/detail/system_failure.hpp	30;"	d
windows_error	/usr/include/boost/system/windows_error.hpp	/^    namespace windows_error$/;"	n	namespace:boost::system
windows_error_code	/usr/include/boost/system/windows_error.hpp	/^      enum windows_error_code$/;"	g	namespace:boost::system::windows_error
windows_name	/usr/include/boost/filesystem/path.hpp	/^  BOOST_FILESYSTEM_DECL bool windows_name(const std::string & name);$/;"	p	namespace:boost::filesystem	signature:(const std::string & name)
wofstream	/usr/include/boost/filesystem/fstream.hpp	/^  typedef basic_ofstream<wchar_t> wofstream;$/;"	t	namespace:boost::filesystem
wpath	/usr/include/boost/filesystem/path.hpp	/^  typedef path wpath;$/;"	t	namespace:boost::filesystem
wrap_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static Next const &wrap_(Next const &next, mpl::false_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::false_)
wrap_	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static xpression_adaptor<reference_wrapper<Next const>, matchable<BidiIter> > wrap_(Next const &next, mpl::true_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::true_)
wrap_int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef date_time::wrapping_int< split_timedate_system::int_type, split_timedate_system::ticks_per_day> wrap_int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
wrap_int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef date_time::wrapping_int<int_type, INT64_C(86400) * ticks_per_second > wrap_int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
wrap_int_type	/usr/include/boost/date_time/time_system_split.hpp	/^    typedef date_time::wrapping_int<int_type, ticks_per_day> wrap_int_type;$/;"	t	class:boost::date_time::split_timedate_system	access:public
wrecursive_directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^  typedef recursive_directory_iterator wrecursive_directory_iterator;$/;"	t	namespace:boost::filesystem
wregex	/usr/include/boost/regex/v4/regex.hpp	/^typedef basic_regex<wchar_t, regex_traits<wchar_t> > wregex;$/;"	t	namespace:boost
wregex	/usr/include/boost/regex/v4/regex_fwd.hpp	/^typedef basic_regex<wchar_t, regex_traits<wchar_t> > wregex;$/;"	t	namespace:boost
wregex_filter	/usr/include/boost/iostreams/filter/regex.hpp	/^typedef basic_regex_filter<wchar_t>  wregex_filter;$/;"	t	namespace:boost::iostreams
write_fault	/usr/include/boost/system/windows_error.hpp	/^        write_fault = ERROR_WRITE_FAULT,$/;"	e	enum:boost::system::windows_error::windows_error_code
write_protect	/usr/include/boost/system/windows_error.hpp	/^        write_protect = ERROR_WRITE_PROTECT,$/;"	e	enum:boost::system::windows_error::windows_error_code
wrong_disk	/usr/include/boost/system/windows_error.hpp	/^        wrong_disk = ERROR_WRONG_DISK,$/;"	e	enum:boost::system::windows_error::windows_error_code
wrong_protocol_type	/usr/include/boost/system/error_code.hpp	/^        wrong_protocol_type = EPROTOTYPE$/;"	e	enum:boost::system::errc::errc_t
wsmatch	/usr/include/boost/regex/v4/regex.hpp	/^typedef match_results<std::wstring::const_iterator> wsmatch;$/;"	t	namespace:boost
wsregex_iterator	/usr/include/boost/regex/v4/regex_iterator.hpp	/^typedef regex_iterator<std::wstring::const_iterator> wsregex_iterator;$/;"	t	namespace:boost
wsregex_token_iterator	/usr/include/boost/regex/v4/regex_token_iterator.hpp	/^typedef regex_token_iterator<std::wstring::const_iterator> wsregex_token_iterator;$/;"	t	namespace:boost
wssub_match	/usr/include/boost/regex/v4/sub_match.hpp	/^typedef sub_match<std::wstring::const_iterator> wssub_match;$/;"	t	namespace:boost
wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  wstring() const { return wstring(codecvt()); }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring  wstring(const codecvt_type& cvt) const$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type& cvt) const
wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring&  wstring() const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:() const
wstring	/usr/include/boost/filesystem/path.hpp	/^    const std::wstring&  wstring(const codecvt_type&) const { return m_pathname; }$/;"	f	class:boost::filesystem::path	access:public	signature:(const codecvt_type&) const
xdigit	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const xdigit = {{"xdigit", false}};$/;"	m	class:boost::xpressive::proto::terminal
xpressive	/usr/include/boost/xpressive/basic_regex.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_actions.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_algorithms.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_compiler.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_error.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/traits/cpp_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/traits/c_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	/usr/include/boost/xpressive/traits/null_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpr_	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<matchable_ex<BidiIter> const> xpr_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
yes_type	/usr/include/boost/xpressive/regex_actions.hpp	/^                typedef char yes_type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
ymd_type	/usr/include/boost/date_time/time_system_counted.hpp	/^    typedef typename date_type::ymd_type ymd_type;$/;"	t	struct:boost::date_time::counted_time_rep	access:public
zone_name	/usr/include/boost/date_time/time_system_counted.hpp	/^    static std::string zone_name(const time_rep_type&)$/;"	f	class:boost::date_time::counted_time_system	access:public	signature:(const time_rep_type&)
zone_name	/usr/include/boost/date_time/time_system_split.hpp	/^    static std::string zone_name(const time_rep_type&)$/;"	f	class:boost::date_time::split_timedate_system	access:public	signature:(const time_rep_type&)
_	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::any_matcher>::type const _ = {{}};$/;"	m	class:boost::xpressive::proto::terminal
_b	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_boundary>::type const _b = {{}};$/;"	m	class:boost::xpressive::proto::terminal
_d	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _d = {{"d", false}};$/;"	m	class:boost::xpressive::proto::terminal
_data	/usr/include/boost/regex/v4/fileiter.hpp	/^   _fi_find_data _data;$/;"	m	struct:boost::re_detail::file_iterator_ref	access:public
_detail_directory_symlink	/usr/include/boost/filesystem/operations.hpp	/^    _detail_directory_symlink  \/\/ internal use only; never exposed to users$/;"	e	enum:boost::filesystem::file_type
_first	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* _first;$/;"	m	class:boost::re_detail::mapfile	access:private
_fi_dir	/usr/include/boost/regex/v4/fileiter.hpp	66;"	d
_fi_find_data	/usr/include/boost/regex/v4/fileiter.hpp	/^typedef WIN32_FIND_DATAA _fi_find_data;$/;"	t	namespace:boost::re_detail
_fi_find_handle	/usr/include/boost/regex/v4/fileiter.hpp	/^typedef HANDLE _fi_find_handle;$/;"	t	namespace:boost::re_detail
_fi_invalid_handle	/usr/include/boost/regex/v4/fileiter.hpp	65;"	d
_last	/usr/include/boost/regex/v4/fileiter.hpp	/^   const char* _last;$/;"	m	class:boost::re_detail::mapfile	access:private
_ln	/usr/include/boost/xpressive/regex_primitives.hpp	/^detail::logical_newline_xpression const _ln = {{}};$/;"	m	class:boost::xpressive::detail
_map	/usr/include/boost/regex/v4/states.hpp	/^   unsigned char   _map[1 << CHAR_BIT]; \/\/ which characters can take the jump$/;"	m	struct:boost::re_detail::re_alt	access:public
_map	/usr/include/boost/regex/v4/states.hpp	/^   unsigned char _map[1 << CHAR_BIT];$/;"	m	struct:boost::re_detail::re_set	access:public
_match_flags	/usr/include/boost/regex/v4/match_flags.hpp	/^typedef enum _match_flags$/;"	g	namespace:boost::regex_constants
_n	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<char>::type const _n = {'\\n'};$/;"	m	class:boost::xpressive::proto::terminal
_narrow_type	/usr/include/boost/regex/v4/states.hpp	/^struct _narrow_type{};$/;"	s	namespace:boost::re_detail
_path	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _path;$/;"	m	class:boost::re_detail::directory_iterator	access:private
_path	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _path;$/;"	m	class:boost::re_detail::file_iterator	access:private
_root	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _root;$/;"	m	class:boost::re_detail::directory_iterator	access:private
_root	/usr/include/boost/regex/v4/fileiter.hpp	/^   char* _root;$/;"	m	class:boost::re_detail::file_iterator	access:private
_RWSTD_COMPILE_INSTANTIATE	/usr/include/boost/regex/config/borland.hpp	32;"	d
_s	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _s = {{"s", false}};$/;"	m	class:boost::xpressive::proto::terminal
_STLP_CWCTYPE	/usr/include/boost/regex/config.hpp	117;"	d
_w	/usr/include/boost/xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _w = {{"w", false}};$/;"	m	class:boost::xpressive::proto::terminal
_wide_type	/usr/include/boost/regex/v4/states.hpp	/^struct _wide_type{};$/;"	s	namespace:boost::re_detail
__STLPORT_CWCTYPE	/usr/include/boost/regex/config.hpp	116;"	d
~abstract_protected_call	/usr/include/boost/regex/v4/protected_call.hpp	/^   virtual ~abstract_protected_call(){}$/;"	f	class:boost::re_detail::abstract_protected_call	access:public	signature:()
~basic_filebuf	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_filebuf() {}$/;"	f	class:boost::filesystem::basic_filebuf	access:public	signature:()
~basic_fstream	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_fstream() {}$/;"	f	class:boost::filesystem::basic_fstream	access:public	signature:()
~basic_ifstream	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_ifstream() {}$/;"	f	class:boost::filesystem::basic_ifstream	access:public	signature:()
~basic_ofstream	/usr/include/boost/filesystem/fstream.hpp	/^    virtual ~basic_ofstream() {}$/;"	f	class:boost::filesystem::basic_ofstream	access:public	signature:()
~basic_regex	/usr/include/boost/regex/v4/basic_regex.hpp	/^   ~basic_regex(){}$/;"	f	class:boost::basic_regex	access:public	signature:()
~directory_iterator	/usr/include/boost/filesystem/operations.hpp	/^   ~directory_iterator() {} \/\/ never throws$/;"	f	class:boost::filesystem::directory_iterator	access:public	signature:()
~directory_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   ~directory_iterator();$/;"	p	class:boost::re_detail::directory_iterator	access:public	signature:()
~dir_itr_imp	/usr/include/boost/filesystem/operations.hpp	/^    ~dir_itr_imp() \/\/ never throws$/;"	f	struct:boost::filesystem::detail::dir_itr_imp	access:public	signature:()
~error_category	/usr/include/boost/system/error_code.hpp	/^      virtual ~error_category(){}$/;"	f	class:boost::system::error_category	access:public	signature:()
~filesystem_error	/usr/include/boost/filesystem/operations.hpp	/^    ~filesystem_error() throw() {}$/;"	f	class:boost::filesystem::filesystem_error	access:public	signature:()
~file_iterator	/usr/include/boost/regex/v4/fileiter.hpp	/^   ~file_iterator();$/;"	p	class:boost::re_detail::file_iterator	access:public	signature:()
~finder	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual ~finder() {}$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:()
~mapfile	/usr/include/boost/regex/v4/fileiter.hpp	/^   ~mapfile(){ close(); }$/;"	f	class:boost::re_detail::mapfile	access:public	signature:()
~match_results	/usr/include/boost/regex/v4/match_results.hpp	/^   ~match_results(){}$/;"	f	class:boost::match_results	access:public	signature:()
~mem_block_cache	/usr/include/boost/regex/v4/mem_block_cache.hpp	/^   ~mem_block_cache()$/;"	f	struct:boost::re_detail::mem_block_cache	access:public	signature:()
~raw_storage	/usr/include/boost/regex/v4/regex_raw_buffer.hpp	/^   ~raw_storage()$/;"	f	class:boost::re_detail::raw_storage	access:public	signature:()
~RegEx	/usr/include/boost/regex/v4/cregex.hpp	/^   ~RegEx();$/;"	p	class:boost::RegEx	access:public	signature:()
~regex_error	/usr/include/boost/regex/pattern_except.hpp	/^   ~regex_error() throw();$/;"	p	class:boost::regex_error	access:public	signature:()
~regex_error	/usr/include/boost/xpressive/regex_error.hpp	/^    virtual ~regex_error() throw()$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:()
~regex_impl	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    ~regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
~reg_expression	/usr/include/boost/regex/v4/basic_regex.hpp	/^   ~reg_expression(){}$/;"	f	class:boost::reg_expression	access:public	signature:()
~repeater_count	/usr/include/boost/regex/v4/perl_matcher.hpp	/^   ~repeater_count()$/;"	f	class:boost::re_detail::repeater_count	access:public	signature:()
~save_state_init	/usr/include/boost/regex/v4/perl_matcher_non_recursive.hpp	/^   ~save_state_init()$/;"	f	struct:boost::re_detail::save_state_init	access:public	signature:()
~scoped_static_mutex_lock	/usr/include/boost/regex/pending/static_mutex.hpp	/^   ~scoped_static_mutex_lock();$/;"	p	class:boost::scoped_static_mutex_lock	access:public	signature:()
~system_error	/usr/include/boost/system/system_error.hpp	/^      virtual ~system_error() throw() {}$/;"	f	class:boost::system::system_error	access:public	signature:()
~traits	/usr/include/boost/xpressive/detail/core/regex_impl.hpp	/^    virtual ~traits() {}$/;"	f	struct:boost::xpressive::detail::traits	access:public	signature:()
